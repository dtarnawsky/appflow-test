"use strict";
(self["webpackChunkapp"] = self["webpackChunkapp"] || []).push([["default-node_modules_ionic_core_dist_esm_data-cb72448c_js-node_modules_ionic_core_dist_esm_th-29e28e"],{

/***/ 7101:
/*!************************************************************!*\
  !*** ./node_modules/@ionic/core/dist/esm/data-cb72448c.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "A": () => (/* binding */ getDayColumnData),
/* harmony export */   "B": () => (/* binding */ getYearColumnData),
/* harmony export */   "C": () => (/* binding */ isMonthFirstLocale),
/* harmony export */   "D": () => (/* binding */ getTimeColumnsData),
/* harmony export */   "E": () => (/* binding */ isLocaleDayPeriodRTL),
/* harmony export */   "F": () => (/* binding */ getDaysOfWeek),
/* harmony export */   "G": () => (/* binding */ getMonthAndYear),
/* harmony export */   "H": () => (/* binding */ getDaysOfMonth),
/* harmony export */   "I": () => (/* binding */ generateMonths),
/* harmony export */   "J": () => (/* binding */ is24Hour),
/* harmony export */   "K": () => (/* binding */ getLocalizedTime),
/* harmony export */   "L": () => (/* binding */ getMonthAndDay),
/* harmony export */   "M": () => (/* binding */ formatValue),
/* harmony export */   "N": () => (/* binding */ getNextYear),
/* harmony export */   "O": () => (/* binding */ getPreviousYear),
/* harmony export */   "P": () => (/* binding */ clampDate),
/* harmony export */   "Q": () => (/* binding */ parseAmPm),
/* harmony export */   "R": () => (/* binding */ calculateHourFromAMPM),
/* harmony export */   "S": () => (/* binding */ getLocalizedDateTime),
/* harmony export */   "T": () => (/* binding */ getMonthDayAndYear),
/* harmony export */   "a": () => (/* binding */ getDay),
/* harmony export */   "b": () => (/* binding */ isAfter),
/* harmony export */   "c": () => (/* binding */ isSameDay),
/* harmony export */   "d": () => (/* binding */ getPreviousMonth),
/* harmony export */   "e": () => (/* binding */ getNextMonth),
/* harmony export */   "f": () => (/* binding */ getPartsFromCalendarDay),
/* harmony export */   "g": () => (/* binding */ generateDayAriaLabel),
/* harmony export */   "h": () => (/* binding */ getEndOfWeek),
/* harmony export */   "i": () => (/* binding */ isBefore),
/* harmony export */   "j": () => (/* binding */ getStartOfWeek),
/* harmony export */   "k": () => (/* binding */ getPreviousDay),
/* harmony export */   "l": () => (/* binding */ getNextDay),
/* harmony export */   "m": () => (/* binding */ getPreviousWeek),
/* harmony export */   "n": () => (/* binding */ getNextWeek),
/* harmony export */   "o": () => (/* binding */ parseMaxParts),
/* harmony export */   "p": () => (/* binding */ parseMinParts),
/* harmony export */   "q": () => (/* binding */ parseDate),
/* harmony export */   "r": () => (/* binding */ convertToArrayOfNumbers),
/* harmony export */   "s": () => (/* binding */ convertDataToISO),
/* harmony export */   "t": () => (/* binding */ getToday),
/* harmony export */   "u": () => (/* binding */ getClosestValidDate),
/* harmony export */   "v": () => (/* binding */ validateParts),
/* harmony export */   "w": () => (/* binding */ warnIfValueOutOfBounds),
/* harmony export */   "x": () => (/* binding */ getNumDaysInMonth),
/* harmony export */   "y": () => (/* binding */ getCombinedDateColumnData),
/* harmony export */   "z": () => (/* binding */ getMonthColumnData)
/* harmony export */ });
/* harmony import */ var _index_c4b11676_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-c4b11676.js */ 9273);
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */

/**
 * Returns true if the selected day is equal to the reference day
 */

const isSameDay = (baseParts, compareParts) => {
  return baseParts.month === compareParts.month && baseParts.day === compareParts.day && baseParts.year === compareParts.year;
};
/**
 * Returns true is the selected day is before the reference day.
 */


const isBefore = (baseParts, compareParts) => {
  return !!(baseParts.year < compareParts.year || baseParts.year === compareParts.year && baseParts.month < compareParts.month || baseParts.year === compareParts.year && baseParts.month === compareParts.month && baseParts.day !== null && baseParts.day < compareParts.day);
};
/**
 * Returns true is the selected day is after the reference day.
 */


const isAfter = (baseParts, compareParts) => {
  return !!(baseParts.year > compareParts.year || baseParts.year === compareParts.year && baseParts.month > compareParts.month || baseParts.year === compareParts.year && baseParts.month === compareParts.month && baseParts.day !== null && baseParts.day > compareParts.day);
};

const warnIfValueOutOfBounds = (value, min, max) => {
  const valueArray = Array.isArray(value) ? value : [value];

  for (const val of valueArray) {
    if (min !== undefined && isBefore(val, min) || max !== undefined && isAfter(val, max)) {
      (0,_index_c4b11676_js__WEBPACK_IMPORTED_MODULE_0__.p)('The value provided to ion-datetime is out of bounds.\n\n' + `Min: ${JSON.stringify(min)}\n` + `Max: ${JSON.stringify(max)}\n` + `Value: ${JSON.stringify(value)}`);
      break;
    }
  }
};
/**
 * Determines if given year is a
 * leap year. Returns `true` if year
 * is a leap year. Returns `false`
 * otherwise.
 */


const isLeapYear = year => {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
};

const is24Hour = (locale, hourCycle) => {
  /**
   * If developer has explicitly enabled h23 time
   * then return early and do not look at the system default.
   */
  if (hourCycle !== undefined) {
    return hourCycle === 'h23';
  }
  /**
   * If hourCycle was not specified, check the locale
   * that is set on the user's device. We first check the
   * Intl.DateTimeFormat hourCycle option as developers can encode this
   * option into the locale string. Example: `en-US-u-hc-h23`
   */


  const formatted = new Intl.DateTimeFormat(locale, {
    hour: 'numeric'
  });
  const options = formatted.resolvedOptions();

  if (options.hourCycle !== undefined) {
    return options.hourCycle === 'h23';
  }
  /**
   * If hourCycle is not specified (either through lack
   * of browser support or locale information) then fall
   * back to this slower hourCycle check.
   */


  const date = new Date('5/18/2021 00:00');
  const parts = formatted.formatToParts(date);
  const hour = parts.find(p => p.type === 'hour');

  if (!hour) {
    throw new Error('Hour value not found from DateTimeFormat');
  }

  return hour.value === '00';
};
/**
 * Given a date object, returns the number
 * of days in that month.
 * Month value begin at 1, not 0.
 * i.e. January = month 1.
 */


const getNumDaysInMonth = (month, year) => {
  return month === 4 || month === 6 || month === 9 || month === 11 ? 30 : month === 2 ? isLeapYear(year) ? 29 : 28 : 31;
};
/**
 * Certain locales display month then year while
 * others display year then month.
 * We can use Intl.DateTimeFormat to determine
 * the ordering for each locale.
 * The formatOptions param can be used to customize
 * which pieces of a date to compare against the month
 * with. For example, some locales render dd/mm/yyyy
 * while others render mm/dd/yyyy. This function can be
 * used for variations of the same "month first" check.
 */


const isMonthFirstLocale = (locale, formatOptions = {
  month: 'numeric',
  year: 'numeric'
}) => {
  /**
   * By setting month and year we guarantee that only
   * month, year, and literal (slashes '/', for example)
   * values are included in the formatToParts results.
   *
   * The ordering of the parts will be determined by
   * the locale. So if the month is the first value,
   * then we know month should be shown first. If the
   * year is the first value, then we know year should be shown first.
   *
   * This ordering can be controlled by customizing the locale property.
   */
  const parts = new Intl.DateTimeFormat(locale, formatOptions).formatToParts(new Date());
  return parts[0].type === 'month';
};
/**
 * Determines if the given locale formats the day period (am/pm) to the
 * left or right of the hour.
 * @param locale The locale to check.
 * @returns `true` if the locale formats the day period to the left of the hour.
 */


const isLocaleDayPeriodRTL = locale => {
  const parts = new Intl.DateTimeFormat(locale, {
    hour: 'numeric'
  }).formatToParts(new Date());
  return parts[0].type === 'dayPeriod';
};

const ISO_8601_REGEXP = // eslint-disable-next-line no-useless-escape
/^(\d{4}|[+\-]\d{6})(?:-(\d{2})(?:-(\d{2}))?)?(?:T(\d{2}):(\d{2})(?::(\d{2})(?:\.(\d{3}))?)?(?:(Z)|([+\-])(\d{2})(?::(\d{2}))?)?)?$/; // eslint-disable-next-line no-useless-escape

const TIME_REGEXP = /^((\d{2}):(\d{2})(?::(\d{2})(?:\.(\d{3}))?)?(?:(Z)|([+\-])(\d{2})(?::(\d{2}))?)?)?$/;
/**
 * Use to convert a string of comma separated numbers or
 * an array of numbers, and clean up any user input
 */

const convertToArrayOfNumbers = input => {
  if (input === undefined) {
    return;
  }

  let processedInput = input;

  if (typeof input === 'string') {
    // convert the string to an array of strings
    // auto remove any whitespace and [] characters
    processedInput = input.replace(/\[|\]|\s/g, '').split(',');
  }

  let values;

  if (Array.isArray(processedInput)) {
    // ensure each value is an actual number in the returned array
    values = processedInput.map(num => parseInt(num, 10)).filter(isFinite);
  } else {
    values = [processedInput];
  }

  return values;
};
/**
 * Extracts date information
 * from a .calendar-day element
 * into DatetimeParts.
 */


const getPartsFromCalendarDay = el => {
  return {
    month: parseInt(el.getAttribute('data-month'), 10),
    day: parseInt(el.getAttribute('data-day'), 10),
    year: parseInt(el.getAttribute('data-year'), 10),
    dayOfWeek: parseInt(el.getAttribute('data-day-of-week'), 10)
  };
};

function parseDate(val) {
  if (Array.isArray(val)) {
    return val.map(valStr => parseDate(valStr));
  } // manually parse IS0 cuz Date.parse cannot be trusted
  // ISO 8601 format: 1994-12-15T13:47:20Z


  let parse = null;

  if (val != null && val !== '') {
    // try parsing for just time first, HH:MM
    parse = TIME_REGEXP.exec(val);

    if (parse) {
      // adjust the array so it fits nicely with the datetime parse
      parse.unshift(undefined, undefined);
      parse[2] = parse[3] = undefined;
    } else {
      // try parsing for full ISO datetime
      parse = ISO_8601_REGEXP.exec(val);
    }
  }

  if (parse === null) {
    // wasn't able to parse the ISO datetime
    return undefined;
  } // ensure all the parse values exist with at least 0


  for (let i = 1; i < 8; i++) {
    parse[i] = parse[i] !== undefined ? parseInt(parse[i], 10) : undefined;
  }

  let tzOffset = 0;

  if (parse[9] && parse[10]) {
    // hours
    tzOffset = parseInt(parse[10], 10) * 60;

    if (parse[11]) {
      // minutes
      tzOffset += parseInt(parse[11], 10);
    }

    if (parse[9] === '-') {
      // + or -
      tzOffset *= -1;
    }
  } // can also get second and millisecond from parse[6] and parse[7] if needed


  return {
    year: parse[1],
    month: parse[2],
    day: parse[3],
    hour: parse[4],
    minute: parse[5],
    tzOffset,
    ampm: parse[4] < 12 ? 'am' : 'pm'
  };
}

const clampDate = (dateParts, minParts, maxParts) => {
  if (minParts && isBefore(dateParts, minParts)) {
    return minParts;
  } else if (maxParts && isAfter(dateParts, maxParts)) {
    return maxParts;
  }

  return dateParts;
};
/**
 * Parses an hour and returns if the value is in the morning (am) or afternoon (pm).
 * @param hour The hour to format, should be 0-23
 * @returns `pm` if the hour is greater than or equal to 12, `am` if less than 12.
 */


const parseAmPm = hour => {
  return hour >= 12 ? 'pm' : 'am';
};
/**
 * Takes a max date string and creates a DatetimeParts
 * object, filling in any missing information.
 * For example, max="2012" would fill in the missing
 * month, day, hour, and minute information.
 */


const parseMaxParts = (max, todayParts) => {
  const {
    month,
    day,
    year,
    hour,
    minute
  } = parseDate(max);
  /**
   * When passing in `max` or `min`, developers
   * can pass in any ISO-8601 string. This means
   * that not all of the date/time fields are defined.
   * For example, passing max="2012" is valid even though
   * there is no month, day, hour, or minute data.
   * However, all of this data is required when clamping the date
   * so that the correct initial value can be selected. As a result,
   * we need to fill in any omitted data with the min or max values.
   */

  const yearValue = year !== null && year !== void 0 ? year : todayParts.year;
  const monthValue = month !== null && month !== void 0 ? month : 12;
  return {
    month: monthValue,
    day: day !== null && day !== void 0 ? day : getNumDaysInMonth(monthValue, yearValue),

    /**
     * Passing in "HH:mm" is a valid ISO-8601
     * string, so we just default to the current year
     * in this case.
     */
    year: yearValue,
    hour: hour !== null && hour !== void 0 ? hour : 23,
    minute: minute !== null && minute !== void 0 ? minute : 59
  };
};
/**
 * Takes a min date string and creates a DatetimeParts
 * object, filling in any missing information.
 * For example, min="2012" would fill in the missing
 * month, day, hour, and minute information.
 */


const parseMinParts = (min, todayParts) => {
  const {
    month,
    day,
    year,
    hour,
    minute
  } = parseDate(min);
  /**
   * When passing in `max` or `min`, developers
   * can pass in any ISO-8601 string. This means
   * that not all of the date/time fields are defined.
   * For example, passing max="2012" is valid even though
   * there is no month, day, hour, or minute data.
   * However, all of this data is required when clamping the date
   * so that the correct initial value can be selected. As a result,
   * we need to fill in any omitted data with the min or max values.
   */

  return {
    month: month !== null && month !== void 0 ? month : 1,
    day: day !== null && day !== void 0 ? day : 1,

    /**
     * Passing in "HH:mm" is a valid ISO-8601
     * string, so we just default to the current year
     * in this case.
     */
    year: year !== null && year !== void 0 ? year : todayParts.year,
    hour: hour !== null && hour !== void 0 ? hour : 0,
    minute: minute !== null && minute !== void 0 ? minute : 0
  };
};

const twoDigit = val => {
  return ('0' + (val !== undefined ? Math.abs(val) : '0')).slice(-2);
};

const fourDigit = val => {
  return ('000' + (val !== undefined ? Math.abs(val) : '0')).slice(-4);
};

function convertDataToISO(data) {
  if (Array.isArray(data)) {
    return data.map(parts => convertDataToISO(parts));
  } // https://www.w3.org/TR/NOTE-datetime


  let rtn = '';

  if (data.year !== undefined) {
    // YYYY
    rtn = fourDigit(data.year);

    if (data.month !== undefined) {
      // YYYY-MM
      rtn += '-' + twoDigit(data.month);

      if (data.day !== undefined) {
        // YYYY-MM-DD
        rtn += '-' + twoDigit(data.day);

        if (data.hour !== undefined) {
          // YYYY-MM-DDTHH:mm:SS
          rtn += `T${twoDigit(data.hour)}:${twoDigit(data.minute)}:00`;

          if (data.tzOffset === undefined) {
            // YYYY-MM-DDTHH:mm:SSZ
            rtn += 'Z';
          } else {
            // YYYY-MM-DDTHH:mm:SS+/-HH:mm
            rtn += (data.tzOffset > 0 ? '+' : '-') + twoDigit(Math.floor(Math.abs(data.tzOffset / 60))) + ':' + twoDigit(data.tzOffset % 60);
          }
        }
      }
    }
  } else if (data.hour !== undefined) {
    // HH:mm
    rtn = twoDigit(data.hour) + ':' + twoDigit(data.minute);
  }

  return rtn;
}
/**
 * Converts an 12 hour value to 24 hours.
 */


const convert12HourTo24Hour = (hour, ampm) => {
  if (ampm === undefined) {
    return hour;
  }
  /**
   * If AM and 12am
   * then return 00:00.
   * Otherwise just return
   * the hour since it is
   * already in 24 hour format.
   */


  if (ampm === 'am') {
    if (hour === 12) {
      return 0;
    }

    return hour;
  }
  /**
   * If PM and 12pm
   * just return 12:00
   * since it is already
   * in 24 hour format.
   * Otherwise add 12 hours
   * to the time.
   */


  if (hour === 12) {
    return 12;
  }

  return hour + 12;
};

const getStartOfWeek = refParts => {
  const {
    dayOfWeek
  } = refParts;

  if (dayOfWeek === null || dayOfWeek === undefined) {
    throw new Error('No day of week provided');
  }

  return subtractDays(refParts, dayOfWeek);
};

const getEndOfWeek = refParts => {
  const {
    dayOfWeek
  } = refParts;

  if (dayOfWeek === null || dayOfWeek === undefined) {
    throw new Error('No day of week provided');
  }

  return addDays(refParts, 6 - dayOfWeek);
};

const getNextDay = refParts => {
  return addDays(refParts, 1);
};

const getPreviousDay = refParts => {
  return subtractDays(refParts, 1);
};

const getPreviousWeek = refParts => {
  return subtractDays(refParts, 7);
};

const getNextWeek = refParts => {
  return addDays(refParts, 7);
};
/**
 * Given datetime parts, subtract
 * numDays from the date.
 * Returns a new DatetimeParts object
 * Currently can only go backward at most 1 month.
 */


const subtractDays = (refParts, numDays) => {
  const {
    month,
    day,
    year
  } = refParts;

  if (day === null) {
    throw new Error('No day provided');
  }

  const workingParts = {
    month,
    day,
    year
  };
  workingParts.day = day - numDays;
  /**
   * If wrapping to previous month
   * update days and decrement month
   */

  if (workingParts.day < 1) {
    workingParts.month -= 1;
  }
  /**
   * If moving to previous year, reset
   * month to December and decrement year
   */


  if (workingParts.month < 1) {
    workingParts.month = 12;
    workingParts.year -= 1;
  }
  /**
   * Determine how many days are in the current
   * month
   */


  if (workingParts.day < 1) {
    const daysInMonth = getNumDaysInMonth(workingParts.month, workingParts.year);
    /**
     * Take num days in month and add the
     * number of underflow days. This number will
     * be negative.
     * Example: 1 week before Jan 2, 2021 is
     * December 26, 2021 so:
     * 2 - 7 = -5
     * 31 + (-5) = 26
     */

    workingParts.day = daysInMonth + workingParts.day;
  }

  return workingParts;
};
/**
 * Given datetime parts, add
 * numDays to the date.
 * Returns a new DatetimeParts object
 * Currently can only go forward at most 1 month.
 */


const addDays = (refParts, numDays) => {
  const {
    month,
    day,
    year
  } = refParts;

  if (day === null) {
    throw new Error('No day provided');
  }

  const workingParts = {
    month,
    day,
    year
  };
  const daysInMonth = getNumDaysInMonth(month, year);
  workingParts.day = day + numDays;
  /**
   * If wrapping to next month
   * update days and increment month
   */

  if (workingParts.day > daysInMonth) {
    workingParts.day -= daysInMonth;
    workingParts.month += 1;
  }
  /**
   * If moving to next year, reset
   * month to January and increment year
   */


  if (workingParts.month > 12) {
    workingParts.month = 1;
    workingParts.year += 1;
  }

  return workingParts;
};
/**
 * Given DatetimeParts, generate the previous month.
 */


const getPreviousMonth = refParts => {
  /**
   * If current month is January, wrap backwards
   *  to December of the previous year.
   */
  const month = refParts.month === 1 ? 12 : refParts.month - 1;
  const year = refParts.month === 1 ? refParts.year - 1 : refParts.year;
  const numDaysInMonth = getNumDaysInMonth(month, year);
  const day = numDaysInMonth < refParts.day ? numDaysInMonth : refParts.day;
  return {
    month,
    year,
    day
  };
};
/**
 * Given DatetimeParts, generate the next month.
 */


const getNextMonth = refParts => {
  /**
   * If current month is December, wrap forwards
   *  to January of the next year.
   */
  const month = refParts.month === 12 ? 1 : refParts.month + 1;
  const year = refParts.month === 12 ? refParts.year + 1 : refParts.year;
  const numDaysInMonth = getNumDaysInMonth(month, year);
  const day = numDaysInMonth < refParts.day ? numDaysInMonth : refParts.day;
  return {
    month,
    year,
    day
  };
};

const changeYear = (refParts, yearDelta) => {
  const month = refParts.month;
  const year = refParts.year + yearDelta;
  const numDaysInMonth = getNumDaysInMonth(month, year);
  const day = numDaysInMonth < refParts.day ? numDaysInMonth : refParts.day;
  return {
    month,
    year,
    day
  };
};
/**
 * Given DatetimeParts, generate the previous year.
 */


const getPreviousYear = refParts => {
  return changeYear(refParts, -1);
};
/**
 * Given DatetimeParts, generate the next year.
 */


const getNextYear = refParts => {
  return changeYear(refParts, 1);
};
/**
 * If PM, then internal value should
 * be converted to 24-hr time.
 * Does not apply when public
 * values are already 24-hr time.
 */


const getInternalHourValue = (hour, use24Hour, ampm) => {
  if (use24Hour) {
    return hour;
  }

  return convert12HourTo24Hour(hour, ampm);
};
/**
 * Unless otherwise stated, all month values are
 * 1 indexed instead of the typical 0 index in JS Date.
 * Example:
 *   January = Month 0 when using JS Date
 *   January = Month 1 when using this datetime util
 */

/**
 * Given the current datetime parts and a new AM/PM value
 * calculate what the hour should be in 24-hour time format.
 * Used when toggling the AM/PM segment since we store our hours
 * in 24-hour time format internally.
 */


const calculateHourFromAMPM = (currentParts, newAMPM) => {
  const {
    ampm: currentAMPM,
    hour
  } = currentParts;
  let newHour = hour;
  /**
   * If going from AM --> PM, need to update the
   *
   */

  if (currentAMPM === 'am' && newAMPM === 'pm') {
    newHour = convert12HourTo24Hour(newHour, 'pm');
    /**
     * If going from PM --> AM
     */
  } else if (currentAMPM === 'pm' && newAMPM === 'am') {
    newHour = Math.abs(newHour - 12);
  }

  return newHour;
};
/**
 * Updates parts to ensure that month and day
 * values are valid. For days that do not exist,
 * the closest valid day is used.
 */


const validateParts = (parts, minParts, maxParts) => {
  const {
    month,
    day,
    year
  } = parts;
  const partsCopy = Object.assign({}, parts);
  const numDays = getNumDaysInMonth(month, year);
  /**
   * If the max number of days
   * is greater than the day we want
   * to set, update the DatetimeParts
   * day field to be the max days.
   */

  if (day !== null && numDays < day) {
    partsCopy.day = numDays;
  }
  /**
   * If value is same day as min day,
   * make sure the time value is in bounds.
   */


  if (minParts !== undefined && isSameDay(partsCopy, minParts)) {
    /**
     * If the hour is out of bounds,
     * update both the hour and minute.
     * This is done so that the new time
     * is closest to what the user selected.
     */
    if (partsCopy.hour !== undefined && minParts.hour !== undefined) {
      if (partsCopy.hour < minParts.hour) {
        partsCopy.hour = minParts.hour;
        partsCopy.minute = minParts.minute;
        /**
         * If only the minute is out of bounds,
         * set it to the min minute.
         */
      } else if (partsCopy.hour === minParts.hour && partsCopy.minute !== undefined && minParts.minute !== undefined && partsCopy.minute < minParts.minute) {
        partsCopy.minute = minParts.minute;
      }
    }
  }
  /**
   * If value is same day as max day,
   * make sure the time value is in bounds.
   */


  if (maxParts !== undefined && isSameDay(parts, maxParts)) {
    /**
     * If the hour is out of bounds,
     * update both the hour and minute.
     * This is done so that the new time
     * is closest to what the user selected.
     */
    if (partsCopy.hour !== undefined && maxParts.hour !== undefined) {
      if (partsCopy.hour > maxParts.hour) {
        partsCopy.hour = maxParts.hour;
        partsCopy.minute = maxParts.minute;
        /**
         * If only the minute is out of bounds,
         * set it to the max minute.
         */
      } else if (partsCopy.hour === maxParts.hour && partsCopy.minute !== undefined && maxParts.minute !== undefined && partsCopy.minute > maxParts.minute) {
        partsCopy.minute = maxParts.minute;
      }
    }
  }

  return partsCopy;
};
/**
 * Returns the closest date to refParts
 * that also meets the constraints of
 * the *Values params.
 * @param refParts The reference date
 * @param monthValues The allowed month values
 * @param dayValues The allowed day (of the month) values
 * @param yearValues The allowed year values
 * @param hourValues The allowed hour values
 * @param minuteValues The allowed minute values
 */


const getClosestValidDate = (refParts, monthValues, dayValues, yearValues, hourValues, minuteValues) => {
  const {
    hour,
    minute,
    day,
    month,
    year
  } = refParts;
  const copyParts = Object.assign(Object.assign({}, refParts), {
    dayOfWeek: undefined
  });

  if (monthValues !== undefined) {
    copyParts.month = findClosestValue(month, monthValues);
  } // Day is nullable but cannot be undefined


  if (day !== null && dayValues !== undefined) {
    copyParts.day = findClosestValue(day, dayValues);
  }

  if (yearValues !== undefined) {
    copyParts.year = findClosestValue(year, yearValues);
  }

  if (hour !== undefined && hourValues !== undefined) {
    copyParts.hour = findClosestValue(hour, hourValues);
    copyParts.ampm = parseAmPm(copyParts.hour);
  }

  if (minute !== undefined && minuteValues !== undefined) {
    copyParts.minute = findClosestValue(minute, minuteValues);
  }

  return copyParts;
};
/**
 * Finds the value in "values" that is
 * numerically closest to "reference".
 * This function assumes that "values" is
 * already sorted in ascending order.
 * @param reference The reference number to use
 * when finding the closest value
 * @param values The allowed values that will be
 * searched to find the closest value to "reference"
 */


const findClosestValue = (reference, values) => {
  let closestValue = values[0];
  let rank = Math.abs(closestValue - reference);

  for (let i = 1; i < values.length; i++) {
    const value = values[i];
    /**
     * This code prioritizes the first
     * closest result. Given two values
     * with the same distance from reference,
     * this code will prioritize the smaller of
     * the two values.
     */

    const valueRank = Math.abs(value - reference);

    if (valueRank < rank) {
      closestValue = value;
      rank = valueRank;
    }
  }

  return closestValue;
};

const getFormattedDayPeriod = dayPeriod => {
  if (dayPeriod === undefined) {
    return '';
  }

  return dayPeriod.toUpperCase();
};

const getLocalizedTime = (locale, refParts, use24Hour) => {
  if (refParts.hour === undefined || refParts.minute === undefined) {
    return 'Invalid Time';
  }

  return new Intl.DateTimeFormat(locale, {
    hour: 'numeric',
    minute: 'numeric',
    timeZone: 'UTC',

    /**
     * We use hourCycle here instead of hour12 due to:
     * https://bugs.chromium.org/p/chromium/issues/detail?id=1347316&q=hour12&can=2
     */
    hourCycle: use24Hour ? 'h23' : 'h12'
  }).format(new Date(convertDataToISO(Object.assign(Object.assign({}, refParts), {
    // TODO: FW-1831 will remove the need to manually set the tzOffset to undefined
    tzOffset: undefined
  }))));
};
/**
 * Adds padding to a time value so
 * that it is always 2 digits.
 */


const addTimePadding = value => {
  const valueToString = value.toString();

  if (valueToString.length > 1) {
    return valueToString;
  }

  return `0${valueToString}`;
};
/**
 * Formats 24 hour times so that
 * it always has 2 digits. For
 * 12 hour times it ensures that
 * hour 0 is formatted as '12'.
 */


const getFormattedHour = (hour, use24Hour) => {
  if (use24Hour) {
    return addTimePadding(hour);
  }
  /**
   * If using 12 hour
   * format, make sure hour
   * 0 is formatted as '12'.
   */


  if (hour === 0) {
    return '12';
  }

  return hour.toString();
};
/**
 * Generates an aria-label to be read by screen readers
 * given a local, a date, and whether or not that date is
 * today's date.
 */


const generateDayAriaLabel = (locale, today, refParts) => {
  if (refParts.day === null) {
    return null;
  }
  /**
   * MM/DD/YYYY will return midnight in the user's timezone.
   */


  const date = new Date(`${refParts.month}/${refParts.day}/${refParts.year} GMT+0000`);
  const labelString = new Intl.DateTimeFormat(locale, {
    weekday: 'long',
    month: 'long',
    day: 'numeric',
    timeZone: 'UTC'
  }).format(date);
  /**
   * If date is today, prepend "Today" so screen readers indicate
   * that the date is today.
   */

  return today ? `Today, ${labelString}` : labelString;
};
/**
 * Gets the day of the week, month, and day
 * Used for the header in MD mode.
 */


const getMonthAndDay = (locale, refParts) => {
  const date = new Date(`${refParts.month}/${refParts.day}/${refParts.year} GMT+0000`);
  return new Intl.DateTimeFormat(locale, {
    weekday: 'short',
    month: 'short',
    day: 'numeric',
    timeZone: 'UTC'
  }).format(date);
};
/**
 * Given a locale and a date object,
 * return a formatted string that includes
 * the month name and full year.
 * Example: May 2021
 */


const getMonthAndYear = (locale, refParts) => {
  const date = new Date(`${refParts.month}/${refParts.day}/${refParts.year} GMT+0000`);
  return new Intl.DateTimeFormat(locale, {
    month: 'long',
    year: 'numeric',
    timeZone: 'UTC'
  }).format(date);
};
/**
 * Given a locale and a date object,
 * return a formatted string that includes
 * the short month, numeric day, and full year.
 * Example: Apr 22, 2021
 */


const getMonthDayAndYear = (locale, refParts) => {
  return getLocalizedDateTime(locale, refParts, {
    month: 'short',
    day: 'numeric',
    year: 'numeric'
  });
};
/**
 * Given a locale and a date object,
 * return a formatted string that includes
 * the numeric day.
 * Note: Some languages will add literal characters
 * to the end. This function removes those literals.
 * Example: 29
 */


const getDay = (locale, refParts) => {
  return getLocalizedDateTimeParts(locale, refParts, {
    day: 'numeric'
  }).find(obj => obj.type === 'day').value;
};
/**
 * Given a locale and a date object,
 * return a formatted string that includes
 * the numeric year.
 * Example: 2022
 */


const getYear = (locale, refParts) => {
  return getLocalizedDateTime(locale, refParts, {
    year: 'numeric'
  });
};

const getNormalizedDate = refParts => {
  const timeString = refParts.hour !== undefined && refParts.minute !== undefined ? ` ${refParts.hour}:${refParts.minute}` : '';
  return new Date(`${refParts.month}/${refParts.day}/${refParts.year}${timeString} GMT+0000`);
};
/**
 * Given a locale, DatetimeParts, and options
 * format the DatetimeParts according to the options
 * and locale combination. This returns a string. If
 * you want an array of the individual pieces
 * that make up the localized date string, use
 * getLocalizedDateTimeParts.
 */


const getLocalizedDateTime = (locale, refParts, options) => {
  const date = getNormalizedDate(refParts);
  return getDateTimeFormat(locale, options).format(date);
};
/**
 * Given a locale, DatetimeParts, and options
 * format the DatetimeParts according to the options
 * and locale combination. This returns an array of
 * each piece of the date.
 */


const getLocalizedDateTimeParts = (locale, refParts, options) => {
  const date = getNormalizedDate(refParts);
  return getDateTimeFormat(locale, options).formatToParts(date);
};
/**
 * Wrapper function for Intl.DateTimeFormat.
 * Allows developers to apply an allowed format to DatetimeParts.
 * This function also has built in safeguards for older browser bugs
 * with Intl.DateTimeFormat.
 */


const getDateTimeFormat = (locale, options) => {
  return new Intl.DateTimeFormat(locale, Object.assign(Object.assign({}, options), {
    timeZone: 'UTC'
  }));
};
/**
 * Gets a localized version of "Today"
 * Falls back to "Today" in English for
 * browsers that do not support RelativeTimeFormat.
 */


const getTodayLabel = locale => {
  if ('RelativeTimeFormat' in Intl) {
    const label = new Intl.RelativeTimeFormat(locale, {
      numeric: 'auto'
    }).format(0, 'day');
    return label.charAt(0).toUpperCase() + label.slice(1);
  } else {
    return 'Today';
  }
};
/**
 * When calling toISOString(), the browser
 * will convert the date to UTC time by either adding
 * or subtracting the time zone offset.
 * To work around this, we need to either add
 * or subtract the time zone offset to the Date
 * object prior to calling toISOString().
 * This allows us to get an ISO string
 * that is in the user's time zone.
 *
 * Example:
 * Time zone offset is 240
 * Meaning: The browser needs to add 240 minutes
 * to the Date object to get UTC time.
 * What Ionic does: We subtract 240 minutes
 * from the Date object. The browser then adds
 * 240 minutes in toISOString(). The result
 * is a time that is in the user's time zone
 * and not UTC.
 *
 * Note: Some timezones include minute adjustments
 * such as 30 or 45 minutes. This is why we use setMinutes
 * instead of setHours.
 * Example: India Standard Time
 * Timezone offset: -330 = -5.5 hours.
 *
 * List of timezones with 30 and 45 minute timezones:
 * https://www.timeanddate.com/time/time-zones-interesting.html
 */


const removeDateTzOffset = date => {
  const tzOffset = date.getTimezoneOffset();
  date.setMinutes(date.getMinutes() - tzOffset);
  return date;
};

const DATE_AM = removeDateTzOffset(new Date('2022T01:00'));
const DATE_PM = removeDateTzOffset(new Date('2022T13:00'));
/**
 * Formats the locale's string representation of the day period (am/pm) for a given
 * ref parts day period.
 *
 * @param locale The locale to format the day period in.
 * @param value The date string, in ISO format.
 * @returns The localized day period (am/pm) representation of the given value.
 */

const getLocalizedDayPeriod = (locale, dayPeriod) => {
  const date = dayPeriod === 'am' ? DATE_AM : DATE_PM;
  const localizedDayPeriod = new Intl.DateTimeFormat(locale, {
    hour: 'numeric',
    timeZone: 'UTC'
  }).formatToParts(date).find(part => part.type === 'dayPeriod');

  if (localizedDayPeriod) {
    return localizedDayPeriod.value;
  }

  return getFormattedDayPeriod(dayPeriod);
};
/**
 * Formats the datetime's value to a string, for use in the native input.
 *
 * @param value The value to format, either an ISO string or an array thereof.
 */


const formatValue = value => {
  return Array.isArray(value) ? value.join(',') : value;
};
/**
 * Returns the current date as
 * an ISO string in the user's
 * time zone.
 */


const getToday = () => {
  /**
   * ion-datetime intentionally does not
   * parse time zones/do automatic time zone
   * conversion when accepting user input.
   * However when we get today's date string,
   * we want it formatted relative to the user's
   * time zone.
   *
   * When calling toISOString(), the browser
   * will convert the date to UTC time by either adding
   * or subtracting the time zone offset.
   * To work around this, we need to either add
   * or subtract the time zone offset to the Date
   * object prior to calling toISOString().
   * This allows us to get an ISO string
   * that is in the user's time zone.
   */
  return removeDateTzOffset(new Date()).toISOString();
};

const minutes = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59];
const hour12 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
const hour23 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23];
/**
 * Given a locale and a mode,
 * return an array with formatted days
 * of the week. iOS should display days
 * such as "Mon" or "Tue".
 * MD should display days such as "M"
 * or "T".
 */

const getDaysOfWeek = (locale, mode, firstDayOfWeek = 0) => {
  /**
   * Nov 1st, 2020 starts on a Sunday.
   * ion-datetime assumes weeks start on Sunday,
   * but is configurable via `firstDayOfWeek`.
   */
  const weekdayFormat = mode === 'ios' ? 'short' : 'narrow';
  const intl = new Intl.DateTimeFormat(locale, {
    weekday: weekdayFormat
  });
  const startDate = new Date('11/01/2020');
  const daysOfWeek = [];
  /**
   * For each day of the week,
   * get the day name.
   */

  for (let i = firstDayOfWeek; i < firstDayOfWeek + 7; i++) {
    const currentDate = new Date(startDate);
    currentDate.setDate(currentDate.getDate() + i);
    daysOfWeek.push(intl.format(currentDate));
  }

  return daysOfWeek;
};
/**
 * Returns an array containing all of the
 * days in a month for a given year. Values are
 * aligned with a week calendar starting on
 * the firstDayOfWeek value (Sunday by default)
 * using null values.
 */


const getDaysOfMonth = (month, year, firstDayOfWeek) => {
  const numDays = getNumDaysInMonth(month, year);
  const firstOfMonth = new Date(`${month}/1/${year}`).getDay();
  /**
   * To get the first day of the month aligned on the correct
   * day of the week, we need to determine how many "filler" days
   * to generate. These filler days as empty/disabled buttons
   * that fill the space of the days of the week before the first
   * of the month.
   *
   * There are two cases here:
   *
   * 1. If firstOfMonth = 4, firstDayOfWeek = 0 then the offset
   * is (4 - (0 + 1)) = 3. Since the offset loop goes from 0 to 3 inclusive,
   * this will generate 4 filler days (0, 1, 2, 3), and then day of week 4 will have
   * the first day of the month.
   *
   * 2. If firstOfMonth = 2, firstDayOfWeek = 4 then the offset
   * is (6 - (4 - 2)) = 4. Since the offset loop goes from 0 to 4 inclusive,
   * this will generate 5 filler days (0, 1, 2, 3, 4), and then day of week 5 will have
   * the first day of the month.
   */

  const offset = firstOfMonth >= firstDayOfWeek ? firstOfMonth - (firstDayOfWeek + 1) : 6 - (firstDayOfWeek - firstOfMonth);
  let days = [];

  for (let i = 1; i <= numDays; i++) {
    days.push({
      day: i,
      dayOfWeek: (offset + i) % 7
    });
  }

  for (let i = 0; i <= offset; i++) {
    days = [{
      day: null,
      dayOfWeek: null
    }, ...days];
  }

  return days;
};
/**
 * Given a local, reference datetime parts and option
 * max/min bound datetime parts, calculate the acceptable
 * hour and minute values according to the bounds and locale.
 */


const generateTime = (refParts, hourCycle = 'h12', minParts, maxParts, hourValues, minuteValues) => {
  const use24Hour = hourCycle === 'h23';
  let processedHours = use24Hour ? hour23 : hour12;
  let processedMinutes = minutes;
  let isAMAllowed = true;
  let isPMAllowed = true;

  if (hourValues) {
    processedHours = processedHours.filter(hour => hourValues.includes(hour));
  }

  if (minuteValues) {
    processedMinutes = processedMinutes.filter(minute => minuteValues.includes(minute));
  }

  if (minParts) {
    /**
     * If ref day is the same as the
     * minimum allowed day, filter hour/minute
     * values according to min hour and minute.
     */
    if (isSameDay(refParts, minParts)) {
      /**
       * Users may not always set the hour/minute for
       * min value (i.e. 2021-06-02) so we should allow
       * all hours/minutes in that case.
       */
      if (minParts.hour !== undefined) {
        processedHours = processedHours.filter(hour => {
          const convertedHour = refParts.ampm === 'pm' ? (hour + 12) % 24 : hour;
          return (use24Hour ? hour : convertedHour) >= minParts.hour;
        });
        isAMAllowed = minParts.hour < 13;
      }

      if (minParts.minute !== undefined) {
        /**
         * The minimum minute range should not be enforced when
         * the hour is greater than the min hour.
         *
         * For example with a minimum range of 09:30, users
         * should be able to select 10:00-10:29 and beyond.
         */
        let isPastMinHour = false;

        if (minParts.hour !== undefined && refParts.hour !== undefined) {
          if (refParts.hour > minParts.hour) {
            isPastMinHour = true;
          }
        }

        processedMinutes = processedMinutes.filter(minute => {
          if (isPastMinHour) {
            return true;
          }

          return minute >= minParts.minute;
        });
      }
      /**
       * If ref day is before minimum
       * day do not render any hours/minute values
       */

    } else if (isBefore(refParts, minParts)) {
      processedHours = [];
      processedMinutes = [];
      isAMAllowed = isPMAllowed = false;
    }
  }

  if (maxParts) {
    /**
     * If ref day is the same as the
     * maximum allowed day, filter hour/minute
     * values according to max hour and minute.
     */
    if (isSameDay(refParts, maxParts)) {
      /**
       * Users may not always set the hour/minute for
       * max value (i.e. 2021-06-02) so we should allow
       * all hours/minutes in that case.
       */
      if (maxParts.hour !== undefined) {
        processedHours = processedHours.filter(hour => {
          const convertedHour = refParts.ampm === 'pm' ? (hour + 12) % 24 : hour;
          return (use24Hour ? hour : convertedHour) <= maxParts.hour;
        });
        isPMAllowed = maxParts.hour >= 12;
      }

      if (maxParts.minute !== undefined && refParts.hour === maxParts.hour) {
        // The available minutes should only be filtered when the hour is the same as the max hour.
        // For example if the max hour is 10:30 and the current hour is 10:00,
        // users should be able to select 00-30 minutes.
        // If the current hour is 09:00, users should be able to select 00-60 minutes.
        processedMinutes = processedMinutes.filter(minute => minute <= maxParts.minute);
      }
      /**
       * If ref day is after minimum
       * day do not render any hours/minute values
       */

    } else if (isAfter(refParts, maxParts)) {
      processedHours = [];
      processedMinutes = [];
      isAMAllowed = isPMAllowed = false;
    }
  }

  return {
    hours: processedHours,
    minutes: processedMinutes,
    am: isAMAllowed,
    pm: isPMAllowed
  };
};
/**
 * Given DatetimeParts, generate the previous,
 * current, and and next months.
 */


const generateMonths = refParts => {
  return [getPreviousMonth(refParts), {
    month: refParts.month,
    year: refParts.year,
    day: refParts.day
  }, getNextMonth(refParts)];
};

const getMonthColumnData = (locale, refParts, minParts, maxParts, monthValues, formatOptions = {
  month: 'long'
}) => {
  const {
    year
  } = refParts;
  const months = [];

  if (monthValues !== undefined) {
    let processedMonths = monthValues;

    if ((maxParts === null || maxParts === void 0 ? void 0 : maxParts.month) !== undefined) {
      processedMonths = processedMonths.filter(month => month <= maxParts.month);
    }

    if ((minParts === null || minParts === void 0 ? void 0 : minParts.month) !== undefined) {
      processedMonths = processedMonths.filter(month => month >= minParts.month);
    }

    processedMonths.forEach(processedMonth => {
      const date = new Date(`${processedMonth}/1/${year} GMT+0000`);
      const monthString = new Intl.DateTimeFormat(locale, Object.assign(Object.assign({}, formatOptions), {
        timeZone: 'UTC'
      })).format(date);
      months.push({
        text: monthString,
        value: processedMonth
      });
    });
  } else {
    const maxMonth = maxParts && maxParts.year === year ? maxParts.month : 12;
    const minMonth = minParts && minParts.year === year ? minParts.month : 1;

    for (let i = minMonth; i <= maxMonth; i++) {
      /**
       *
       * There is a bug on iOS 14 where
       * Intl.DateTimeFormat takes into account
       * the local timezone offset when formatting dates.
       *
       * Forcing the timezone to 'UTC' fixes the issue. However,
       * we should keep this workaround as it is safer. In the event
       * this breaks in another browser, we will not be impacted
       * because all dates will be interpreted in UTC.
       *
       * Example:
       * new Intl.DateTimeFormat('en-US', { month: 'long' }).format(new Date('Sat Apr 01 2006 00:00:00 GMT-0400 (EDT)')) // "March"
       * new Intl.DateTimeFormat('en-US', { month: 'long', timeZone: 'UTC' }).format(new Date('Sat Apr 01 2006 00:00:00 GMT-0400 (EDT)')) // "April"
       *
       * In certain timezones, iOS 14 shows the wrong
       * date for .toUTCString(). To combat this, we
       * force all of the timezones to GMT+0000 (UTC).
       *
       * Example:
       * Time Zone: Central European Standard Time
       * new Date('1/1/1992').toUTCString() // "Tue, 31 Dec 1991 23:00:00 GMT"
       * new Date('1/1/1992 GMT+0000').toUTCString() // "Wed, 01 Jan 1992 00:00:00 GMT"
       */
      const date = new Date(`${i}/1/${year} GMT+0000`);
      const monthString = new Intl.DateTimeFormat(locale, Object.assign(Object.assign({}, formatOptions), {
        timeZone: 'UTC'
      })).format(date);
      months.push({
        text: monthString,
        value: i
      });
    }
  }

  return months;
};
/**
 * Returns information regarding
 * selectable dates (i.e 1st, 2nd, 3rd, etc)
 * within a reference month.
 * @param locale The locale to format the date with
 * @param refParts The reference month/year to generate dates for
 * @param minParts The minimum bound on the date that can be returned
 * @param maxParts The maximum bound on the date that can be returned
 * @param dayValues The allowed date values
 * @returns Date data to be used in ion-picker-column-internal
 */


const getDayColumnData = (locale, refParts, minParts, maxParts, dayValues, formatOptions = {
  day: 'numeric'
}) => {
  const {
    month,
    year
  } = refParts;
  const days = [];
  /**
   * If we have max/min bounds that in the same
   * month/year as the refParts, we should
   * use the define day as the max/min day.
   * Otherwise, fallback to the max/min days in a month.
   */

  const numDaysInMonth = getNumDaysInMonth(month, year);
  const maxDay = (maxParts === null || maxParts === void 0 ? void 0 : maxParts.day) !== null && (maxParts === null || maxParts === void 0 ? void 0 : maxParts.day) !== undefined && maxParts.year === year && maxParts.month === month ? maxParts.day : numDaysInMonth;
  const minDay = (minParts === null || minParts === void 0 ? void 0 : minParts.day) !== null && (minParts === null || minParts === void 0 ? void 0 : minParts.day) !== undefined && minParts.year === year && minParts.month === month ? minParts.day : 1;

  if (dayValues !== undefined) {
    let processedDays = dayValues;
    processedDays = processedDays.filter(day => day >= minDay && day <= maxDay);
    processedDays.forEach(processedDay => {
      const date = new Date(`${month}/${processedDay}/${year} GMT+0000`);
      const dayString = new Intl.DateTimeFormat(locale, Object.assign(Object.assign({}, formatOptions), {
        timeZone: 'UTC'
      })).format(date);
      days.push({
        text: dayString,
        value: processedDay
      });
    });
  } else {
    for (let i = minDay; i <= maxDay; i++) {
      const date = new Date(`${month}/${i}/${year} GMT+0000`);
      const dayString = new Intl.DateTimeFormat(locale, Object.assign(Object.assign({}, formatOptions), {
        timeZone: 'UTC'
      })).format(date);
      days.push({
        text: dayString,
        value: i
      });
    }
  }

  return days;
};

const getYearColumnData = (locale, refParts, minParts, maxParts, yearValues) => {
  var _a, _b;

  let processedYears = [];

  if (yearValues !== undefined) {
    processedYears = yearValues;

    if ((maxParts === null || maxParts === void 0 ? void 0 : maxParts.year) !== undefined) {
      processedYears = processedYears.filter(year => year <= maxParts.year);
    }

    if ((minParts === null || minParts === void 0 ? void 0 : minParts.year) !== undefined) {
      processedYears = processedYears.filter(year => year >= minParts.year);
    }
  } else {
    const {
      year
    } = refParts;
    const maxYear = (_a = maxParts === null || maxParts === void 0 ? void 0 : maxParts.year) !== null && _a !== void 0 ? _a : year;
    const minYear = (_b = minParts === null || minParts === void 0 ? void 0 : minParts.year) !== null && _b !== void 0 ? _b : year - 100;

    for (let i = maxYear; i >= minYear; i--) {
      processedYears.push(i);
    }
  }

  return processedYears.map(year => ({
    text: getYear(locale, {
      year,
      month: refParts.month,
      day: refParts.day
    }),
    value: year
  }));
};
/**
 * Given a starting date and an upper bound,
 * this functions returns an array of all
 * month objects in that range.
 */


const getAllMonthsInRange = (currentParts, maxParts) => {
  if (currentParts.month === maxParts.month && currentParts.year === maxParts.year) {
    return [currentParts];
  }

  return [currentParts, ...getAllMonthsInRange(getNextMonth(currentParts), maxParts)];
};
/**
 * Creates and returns picker items
 * that represent the days in a month.
 * Example: "Thu, Jun 2"
 */


const getCombinedDateColumnData = (locale, todayParts, minParts, maxParts, dayValues, monthValues) => {
  let items = [];
  let parts = [];
  /**
   * Get all month objects from the min date
   * to the max date. Note: Do not use getMonthColumnData
   * as that function only generates dates within a
   * single year.
   */

  let months = getAllMonthsInRange(minParts, maxParts);
  /**
   * Filter out any disallowed month values.
   */

  if (monthValues) {
    months = months.filter(({
      month
    }) => monthValues.includes(month));
  }
  /**
   * Get all of the days in the month.
   * From there, generate an array where
   * each item has the month, date, and day
   * of work as the text.
   */


  months.forEach(monthObject => {
    const referenceMonth = {
      month: monthObject.month,
      day: null,
      year: monthObject.year
    };
    const monthDays = getDayColumnData(locale, referenceMonth, minParts, maxParts, dayValues, {
      month: 'short',
      day: 'numeric',
      weekday: 'short'
    });
    const dateParts = [];
    const dateColumnItems = [];
    monthDays.forEach(dayObject => {
      const isToday = isSameDay(Object.assign(Object.assign({}, referenceMonth), {
        day: dayObject.value
      }), todayParts);
      /**
       * Today's date should read as "Today" (localized)
       * not the actual date string
       */

      dateColumnItems.push({
        text: isToday ? getTodayLabel(locale) : dayObject.text,
        value: `${referenceMonth.year}-${referenceMonth.month}-${dayObject.value}`
      });
      /**
       * When selecting a date in the wheel picker
       * we need access to the raw datetime parts data.
       * The picker column only accepts values of
       * type string or number, so we need to return
       * two sets of data: A data set to be passed
       * to the picker column, and a data set to
       * be used to reference the raw data when
       * updating the picker column value.
       */

      dateParts.push({
        month: referenceMonth.month,
        year: referenceMonth.year,
        day: dayObject.value
      });
    });
    parts = [...parts, ...dateParts];
    items = [...items, ...dateColumnItems];
  });
  return {
    parts,
    items
  };
};

const getTimeColumnsData = (locale, refParts, hourCycle, minParts, maxParts, allowedHourValues, allowedMinuteValues) => {
  const use24Hour = is24Hour(locale, hourCycle);
  const {
    hours,
    minutes,
    am,
    pm
  } = generateTime(refParts, use24Hour ? 'h23' : 'h12', minParts, maxParts, allowedHourValues, allowedMinuteValues);
  const hoursItems = hours.map(hour => {
    return {
      text: getFormattedHour(hour, use24Hour),
      value: getInternalHourValue(hour, use24Hour, refParts.ampm)
    };
  });
  const minutesItems = minutes.map(minute => {
    return {
      text: addTimePadding(minute),
      value: minute
    };
  });
  const dayPeriodItems = [];

  if (am && !use24Hour) {
    dayPeriodItems.push({
      text: getLocalizedDayPeriod(locale, 'am'),
      value: 'am'
    });
  }

  if (pm && !use24Hour) {
    dayPeriodItems.push({
      text: getLocalizedDayPeriod(locale, 'pm'),
      value: 'pm'
    });
  }

  return {
    minutesData: minutesItems,
    hoursData: hoursItems,
    dayPeriodData: dayPeriodItems
  };
};



/***/ }),

/***/ 9273:
/*!*************************************************************!*\
  !*** ./node_modules/@ionic/core/dist/esm/index-c4b11676.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "a": () => (/* binding */ printRequiredElementError),
/* harmony export */   "b": () => (/* binding */ printIonError),
/* harmony export */   "p": () => (/* binding */ printIonWarning)
/* harmony export */ });
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */

/**
 * Logs a warning to the console with an Ionic prefix
 * to indicate the library that is warning the developer.
 *
 * @param message - The string message to be logged to the console.
 */
const printIonWarning = (message, ...params) => {
  return console.warn(`[Ionic Warning]: ${message}`, ...params);
};
/*
 * Logs an error to the console with an Ionic prefix
 * to indicate the library that is warning the developer.
 *
 * @param message - The string message to be logged to the console.
 * @param params - Additional arguments to supply to the console.error.
 */


const printIonError = (message, ...params) => {
  return console.error(`[Ionic Error]: ${message}`, ...params);
};
/**
 * Prints an error informing developers that an implementation requires an element to be used
 * within a specific selector.
 *
 * @param el The web component element this is requiring the element.
 * @param targetSelectors The selector or selectors that were not found.
 */


const printRequiredElementError = (el, ...targetSelectors) => {
  return console.error(`<${el.tagName.toLowerCase()}> must be used inside ${targetSelectors.join(' or ')}.`);
};



/***/ }),

/***/ 320:
/*!*************************************************************!*\
  !*** ./node_modules/@ionic/core/dist/esm/theme-7670341c.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "c": () => (/* binding */ createColorClasses),
/* harmony export */   "g": () => (/* binding */ getClassMap),
/* harmony export */   "h": () => (/* binding */ hostContext),
/* harmony export */   "o": () => (/* binding */ openURL)
/* harmony export */ });
/* harmony import */ var _Users_damian_Sample_Code_iv_test_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ 1670);


/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const hostContext = (selector, el) => {
  return el.closest(selector) !== null;
};
/**
 * Create the mode and color classes for the component based on the classes passed in
 */


const createColorClasses = (color, cssClassMap) => {
  return typeof color === 'string' && color.length > 0 ? Object.assign({
    'ion-color': true,
    [`ion-color-${color}`]: true
  }, cssClassMap) : cssClassMap;
};

const getClassList = classes => {
  if (classes !== undefined) {
    const array = Array.isArray(classes) ? classes : classes.split(' ');
    return array.filter(c => c != null).map(c => c.trim()).filter(c => c !== '');
  }

  return [];
};

const getClassMap = classes => {
  const map = {};
  getClassList(classes).forEach(c => map[c] = true);
  return map;
};

const SCHEME = /^[a-z][a-z0-9+\-.]*:/;

const openURL = /*#__PURE__*/function () {
  var _ref = (0,_Users_damian_Sample_Code_iv_test_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (url, ev, direction, animation) {
    if (url != null && url[0] !== '#' && !SCHEME.test(url)) {
      const router = document.querySelector('ion-router');

      if (router) {
        if (ev != null) {
          ev.preventDefault();
        }

        return router.push(url, direction, animation);
      }
    }

    return false;
  });

  return function openURL(_x, _x2, _x3, _x4) {
    return _ref.apply(this, arguments);
  };
}();



/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVmYXVsdC1ub2RlX21vZHVsZXNfaW9uaWNfY29yZV9kaXN0X2VzbV9kYXRhLWNiNzI0NDhjX2pzLW5vZGVfbW9kdWxlc19pb25pY19jb3JlX2Rpc3RfZXNtX3RoLTI5ZTI4ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUNBLE1BQU1FLFNBQVMsR0FBRyxDQUFDQyxTQUFELEVBQVlDLFlBQVosS0FBNkI7RUFDN0MsT0FBUUQsU0FBUyxDQUFDRSxLQUFWLEtBQW9CRCxZQUFZLENBQUNDLEtBQWpDLElBQTBDRixTQUFTLENBQUNHLEdBQVYsS0FBa0JGLFlBQVksQ0FBQ0UsR0FBekUsSUFBZ0ZILFNBQVMsQ0FBQ0ksSUFBVixLQUFtQkgsWUFBWSxDQUFDRyxJQUF4SDtBQUNELENBRkQ7QUFHQTtBQUNBO0FBQ0E7OztBQUNBLE1BQU1DLFFBQVEsR0FBRyxDQUFDTCxTQUFELEVBQVlDLFlBQVosS0FBNkI7RUFDNUMsT0FBTyxDQUFDLEVBQUVELFNBQVMsQ0FBQ0ksSUFBVixHQUFpQkgsWUFBWSxDQUFDRyxJQUE5QixJQUNQSixTQUFTLENBQUNJLElBQVYsS0FBbUJILFlBQVksQ0FBQ0csSUFBaEMsSUFBd0NKLFNBQVMsQ0FBQ0UsS0FBVixHQUFrQkQsWUFBWSxDQUFDQyxLQURoRSxJQUVQRixTQUFTLENBQUNJLElBQVYsS0FBbUJILFlBQVksQ0FBQ0csSUFBaEMsSUFDQ0osU0FBUyxDQUFDRSxLQUFWLEtBQW9CRCxZQUFZLENBQUNDLEtBRGxDLElBRUNGLFNBQVMsQ0FBQ0csR0FBVixLQUFrQixJQUZuQixJQUdDSCxTQUFTLENBQUNHLEdBQVYsR0FBZ0JGLFlBQVksQ0FBQ0UsR0FMekIsQ0FBUjtBQU1ELENBUEQ7QUFRQTtBQUNBO0FBQ0E7OztBQUNBLE1BQU1HLE9BQU8sR0FBRyxDQUFDTixTQUFELEVBQVlDLFlBQVosS0FBNkI7RUFDM0MsT0FBTyxDQUFDLEVBQUVELFNBQVMsQ0FBQ0ksSUFBVixHQUFpQkgsWUFBWSxDQUFDRyxJQUE5QixJQUNQSixTQUFTLENBQUNJLElBQVYsS0FBbUJILFlBQVksQ0FBQ0csSUFBaEMsSUFBd0NKLFNBQVMsQ0FBQ0UsS0FBVixHQUFrQkQsWUFBWSxDQUFDQyxLQURoRSxJQUVQRixTQUFTLENBQUNJLElBQVYsS0FBbUJILFlBQVksQ0FBQ0csSUFBaEMsSUFDQ0osU0FBUyxDQUFDRSxLQUFWLEtBQW9CRCxZQUFZLENBQUNDLEtBRGxDLElBRUNGLFNBQVMsQ0FBQ0csR0FBVixLQUFrQixJQUZuQixJQUdDSCxTQUFTLENBQUNHLEdBQVYsR0FBZ0JGLFlBQVksQ0FBQ0UsR0FMekIsQ0FBUjtBQU1ELENBUEQ7O0FBUUEsTUFBTUksc0JBQXNCLEdBQUcsQ0FBQ0MsS0FBRCxFQUFRQyxHQUFSLEVBQWFDLEdBQWIsS0FBcUI7RUFDbEQsTUFBTUMsVUFBVSxHQUFHQyxLQUFLLENBQUNDLE9BQU4sQ0FBY0wsS0FBZCxJQUF1QkEsS0FBdkIsR0FBK0IsQ0FBQ0EsS0FBRCxDQUFsRDs7RUFDQSxLQUFLLE1BQU1NLEdBQVgsSUFBa0JILFVBQWxCLEVBQThCO0lBQzVCLElBQUtGLEdBQUcsS0FBS00sU0FBUixJQUFxQlYsUUFBUSxDQUFDUyxHQUFELEVBQU1MLEdBQU4sQ0FBOUIsSUFBOENDLEdBQUcsS0FBS0ssU0FBUixJQUFxQlQsT0FBTyxDQUFDUSxHQUFELEVBQU1KLEdBQU4sQ0FBOUUsRUFBMkY7TUFDekZaLHFEQUFlLENBQUMsNkRBQ2IsUUFBT2tCLElBQUksQ0FBQ0MsU0FBTCxDQUFlUixHQUFmLENBQW9CLElBRGQsR0FFYixRQUFPTyxJQUFJLENBQUNDLFNBQUwsQ0FBZVAsR0FBZixDQUFvQixJQUZkLEdBR2IsVUFBU00sSUFBSSxDQUFDQyxTQUFMLENBQWVULEtBQWYsQ0FBc0IsRUFIbkIsQ0FBZjtNQUlBO0lBQ0Q7RUFDRjtBQUNGLENBWEQ7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLE1BQU1VLFVBQVUsR0FBSWQsSUFBRCxJQUFVO0VBQzNCLE9BQVFBLElBQUksR0FBRyxDQUFQLEtBQWEsQ0FBYixJQUFrQkEsSUFBSSxHQUFHLEdBQVAsS0FBZSxDQUFsQyxJQUF3Q0EsSUFBSSxHQUFHLEdBQVAsS0FBZSxDQUE5RDtBQUNELENBRkQ7O0FBR0EsTUFBTWUsUUFBUSxHQUFHLENBQUNDLE1BQUQsRUFBU0MsU0FBVCxLQUF1QjtFQUN0QztBQUNGO0FBQ0E7QUFDQTtFQUNFLElBQUlBLFNBQVMsS0FBS04sU0FBbEIsRUFBNkI7SUFDM0IsT0FBT00sU0FBUyxLQUFLLEtBQXJCO0VBQ0Q7RUFDRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztFQUNFLE1BQU1DLFNBQVMsR0FBRyxJQUFJQyxJQUFJLENBQUNDLGNBQVQsQ0FBd0JKLE1BQXhCLEVBQWdDO0lBQUVLLElBQUksRUFBRTtFQUFSLENBQWhDLENBQWxCO0VBQ0EsTUFBTUMsT0FBTyxHQUFHSixTQUFTLENBQUNLLGVBQVYsRUFBaEI7O0VBQ0EsSUFBSUQsT0FBTyxDQUFDTCxTQUFSLEtBQXNCTixTQUExQixFQUFxQztJQUNuQyxPQUFPVyxPQUFPLENBQUNMLFNBQVIsS0FBc0IsS0FBN0I7RUFDRDtFQUNEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7OztFQUNFLE1BQU1PLElBQUksR0FBRyxJQUFJQyxJQUFKLENBQVMsaUJBQVQsQ0FBYjtFQUNBLE1BQU1DLEtBQUssR0FBR1IsU0FBUyxDQUFDUyxhQUFWLENBQXdCSCxJQUF4QixDQUFkO0VBQ0EsTUFBTUgsSUFBSSxHQUFHSyxLQUFLLENBQUNFLElBQU4sQ0FBWW5DLENBQUQsSUFBT0EsQ0FBQyxDQUFDb0MsSUFBRixLQUFXLE1BQTdCLENBQWI7O0VBQ0EsSUFBSSxDQUFDUixJQUFMLEVBQVc7SUFDVCxNQUFNLElBQUlTLEtBQUosQ0FBVSwwQ0FBVixDQUFOO0VBQ0Q7O0VBQ0QsT0FBT1QsSUFBSSxDQUFDakIsS0FBTCxLQUFlLElBQXRCO0FBQ0QsQ0EvQkQ7QUFnQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxNQUFNMkIsaUJBQWlCLEdBQUcsQ0FBQ2pDLEtBQUQsRUFBUUUsSUFBUixLQUFpQjtFQUN6QyxPQUFPRixLQUFLLEtBQUssQ0FBVixJQUFlQSxLQUFLLEtBQUssQ0FBekIsSUFBOEJBLEtBQUssS0FBSyxDQUF4QyxJQUE2Q0EsS0FBSyxLQUFLLEVBQXZELEdBQ0gsRUFERyxHQUVIQSxLQUFLLEtBQUssQ0FBVixHQUNFZ0IsVUFBVSxDQUFDZCxJQUFELENBQVYsR0FDRSxFQURGLEdBRUUsRUFISixHQUlFLEVBTk47QUFPRCxDQVJEO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsTUFBTWdDLGtCQUFrQixHQUFHLENBQUNoQixNQUFELEVBQVNpQixhQUFhLEdBQUc7RUFDbERuQyxLQUFLLEVBQUUsU0FEMkM7RUFFbERFLElBQUksRUFBRTtBQUY0QyxDQUF6QixLQUdyQjtFQUNKO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNFLE1BQU0wQixLQUFLLEdBQUcsSUFBSVAsSUFBSSxDQUFDQyxjQUFULENBQXdCSixNQUF4QixFQUFnQ2lCLGFBQWhDLEVBQStDTixhQUEvQyxDQUE2RCxJQUFJRixJQUFKLEVBQTdELENBQWQ7RUFDQSxPQUFPQyxLQUFLLENBQUMsQ0FBRCxDQUFMLENBQVNHLElBQVQsS0FBa0IsT0FBekI7QUFDRCxDQWxCRDtBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLE1BQU1LLG9CQUFvQixHQUFJbEIsTUFBRCxJQUFZO0VBQ3ZDLE1BQU1VLEtBQUssR0FBRyxJQUFJUCxJQUFJLENBQUNDLGNBQVQsQ0FBd0JKLE1BQXhCLEVBQWdDO0lBQUVLLElBQUksRUFBRTtFQUFSLENBQWhDLEVBQXFETSxhQUFyRCxDQUFtRSxJQUFJRixJQUFKLEVBQW5FLENBQWQ7RUFDQSxPQUFPQyxLQUFLLENBQUMsQ0FBRCxDQUFMLENBQVNHLElBQVQsS0FBa0IsV0FBekI7QUFDRCxDQUhEOztBQUtBLE1BQU1NLGVBQWUsR0FDckI7QUFDQSxvSUFGQSxFQUdBOztBQUNBLE1BQU1DLFdBQVcsR0FBRyxxRkFBcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxNQUFNQyx1QkFBdUIsR0FBSUMsS0FBRCxJQUFXO0VBQ3pDLElBQUlBLEtBQUssS0FBSzNCLFNBQWQsRUFBeUI7SUFDdkI7RUFDRDs7RUFDRCxJQUFJNEIsY0FBYyxHQUFHRCxLQUFyQjs7RUFDQSxJQUFJLE9BQU9BLEtBQVAsS0FBaUIsUUFBckIsRUFBK0I7SUFDN0I7SUFDQTtJQUNBQyxjQUFjLEdBQUdELEtBQUssQ0FBQ0UsT0FBTixDQUFjLFdBQWQsRUFBMkIsRUFBM0IsRUFBK0JDLEtBQS9CLENBQXFDLEdBQXJDLENBQWpCO0VBQ0Q7O0VBQ0QsSUFBSUMsTUFBSjs7RUFDQSxJQUFJbEMsS0FBSyxDQUFDQyxPQUFOLENBQWM4QixjQUFkLENBQUosRUFBbUM7SUFDakM7SUFDQUcsTUFBTSxHQUFHSCxjQUFjLENBQUNJLEdBQWYsQ0FBb0JDLEdBQUQsSUFBU0MsUUFBUSxDQUFDRCxHQUFELEVBQU0sRUFBTixDQUFwQyxFQUErQ0UsTUFBL0MsQ0FBc0RDLFFBQXRELENBQVQ7RUFDRCxDQUhELE1BSUs7SUFDSEwsTUFBTSxHQUFHLENBQUNILGNBQUQsQ0FBVDtFQUNEOztFQUNELE9BQU9HLE1BQVA7QUFDRCxDQW5CRDtBQW9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxNQUFNTSx1QkFBdUIsR0FBSUMsRUFBRCxJQUFRO0VBQ3RDLE9BQU87SUFDTG5ELEtBQUssRUFBRStDLFFBQVEsQ0FBQ0ksRUFBRSxDQUFDQyxZQUFILENBQWdCLFlBQWhCLENBQUQsRUFBZ0MsRUFBaEMsQ0FEVjtJQUVMbkQsR0FBRyxFQUFFOEMsUUFBUSxDQUFDSSxFQUFFLENBQUNDLFlBQUgsQ0FBZ0IsVUFBaEIsQ0FBRCxFQUE4QixFQUE5QixDQUZSO0lBR0xsRCxJQUFJLEVBQUU2QyxRQUFRLENBQUNJLEVBQUUsQ0FBQ0MsWUFBSCxDQUFnQixXQUFoQixDQUFELEVBQStCLEVBQS9CLENBSFQ7SUFJTEMsU0FBUyxFQUFFTixRQUFRLENBQUNJLEVBQUUsQ0FBQ0MsWUFBSCxDQUFnQixrQkFBaEIsQ0FBRCxFQUFzQyxFQUF0QztFQUpkLENBQVA7QUFNRCxDQVBEOztBQVFBLFNBQVNFLFNBQVQsQ0FBbUIxQyxHQUFuQixFQUF3QjtFQUN0QixJQUFJRixLQUFLLENBQUNDLE9BQU4sQ0FBY0MsR0FBZCxDQUFKLEVBQXdCO0lBQ3RCLE9BQU9BLEdBQUcsQ0FBQ2lDLEdBQUosQ0FBU1UsTUFBRCxJQUFZRCxTQUFTLENBQUNDLE1BQUQsQ0FBN0IsQ0FBUDtFQUNELENBSHFCLENBSXRCO0VBQ0E7OztFQUNBLElBQUlDLEtBQUssR0FBRyxJQUFaOztFQUNBLElBQUk1QyxHQUFHLElBQUksSUFBUCxJQUFlQSxHQUFHLEtBQUssRUFBM0IsRUFBK0I7SUFDN0I7SUFDQTRDLEtBQUssR0FBR2xCLFdBQVcsQ0FBQ21CLElBQVosQ0FBaUI3QyxHQUFqQixDQUFSOztJQUNBLElBQUk0QyxLQUFKLEVBQVc7TUFDVDtNQUNBQSxLQUFLLENBQUNFLE9BQU4sQ0FBYzdDLFNBQWQsRUFBeUJBLFNBQXpCO01BQ0EyQyxLQUFLLENBQUMsQ0FBRCxDQUFMLEdBQVdBLEtBQUssQ0FBQyxDQUFELENBQUwsR0FBVzNDLFNBQXRCO0lBQ0QsQ0FKRCxNQUtLO01BQ0g7TUFDQTJDLEtBQUssR0FBR25CLGVBQWUsQ0FBQ29CLElBQWhCLENBQXFCN0MsR0FBckIsQ0FBUjtJQUNEO0VBQ0Y7O0VBQ0QsSUFBSTRDLEtBQUssS0FBSyxJQUFkLEVBQW9CO0lBQ2xCO0lBQ0EsT0FBTzNDLFNBQVA7RUFDRCxDQXZCcUIsQ0F3QnRCOzs7RUFDQSxLQUFLLElBQUk4QyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHLENBQXBCLEVBQXVCQSxDQUFDLEVBQXhCLEVBQTRCO0lBQzFCSCxLQUFLLENBQUNHLENBQUQsQ0FBTCxHQUFXSCxLQUFLLENBQUNHLENBQUQsQ0FBTCxLQUFhOUMsU0FBYixHQUF5QmtDLFFBQVEsQ0FBQ1MsS0FBSyxDQUFDRyxDQUFELENBQU4sRUFBVyxFQUFYLENBQWpDLEdBQWtEOUMsU0FBN0Q7RUFDRDs7RUFDRCxJQUFJK0MsUUFBUSxHQUFHLENBQWY7O0VBQ0EsSUFBSUosS0FBSyxDQUFDLENBQUQsQ0FBTCxJQUFZQSxLQUFLLENBQUMsRUFBRCxDQUFyQixFQUEyQjtJQUN6QjtJQUNBSSxRQUFRLEdBQUdiLFFBQVEsQ0FBQ1MsS0FBSyxDQUFDLEVBQUQsQ0FBTixFQUFZLEVBQVosQ0FBUixHQUEwQixFQUFyQzs7SUFDQSxJQUFJQSxLQUFLLENBQUMsRUFBRCxDQUFULEVBQWU7TUFDYjtNQUNBSSxRQUFRLElBQUliLFFBQVEsQ0FBQ1MsS0FBSyxDQUFDLEVBQUQsQ0FBTixFQUFZLEVBQVosQ0FBcEI7SUFDRDs7SUFDRCxJQUFJQSxLQUFLLENBQUMsQ0FBRCxDQUFMLEtBQWEsR0FBakIsRUFBc0I7TUFDcEI7TUFDQUksUUFBUSxJQUFJLENBQUMsQ0FBYjtJQUNEO0VBQ0YsQ0F4Q3FCLENBeUN0Qjs7O0VBQ0EsT0FBTztJQUNMMUQsSUFBSSxFQUFFc0QsS0FBSyxDQUFDLENBQUQsQ0FETjtJQUVMeEQsS0FBSyxFQUFFd0QsS0FBSyxDQUFDLENBQUQsQ0FGUDtJQUdMdkQsR0FBRyxFQUFFdUQsS0FBSyxDQUFDLENBQUQsQ0FITDtJQUlMakMsSUFBSSxFQUFFaUMsS0FBSyxDQUFDLENBQUQsQ0FKTjtJQUtMSyxNQUFNLEVBQUVMLEtBQUssQ0FBQyxDQUFELENBTFI7SUFNTEksUUFOSztJQU9MRSxJQUFJLEVBQUVOLEtBQUssQ0FBQyxDQUFELENBQUwsR0FBVyxFQUFYLEdBQWdCLElBQWhCLEdBQXVCO0VBUHhCLENBQVA7QUFTRDs7QUFDRCxNQUFNTyxTQUFTLEdBQUcsQ0FBQ0MsU0FBRCxFQUFZQyxRQUFaLEVBQXNCQyxRQUF0QixLQUFtQztFQUNuRCxJQUFJRCxRQUFRLElBQUk5RCxRQUFRLENBQUM2RCxTQUFELEVBQVlDLFFBQVosQ0FBeEIsRUFBK0M7SUFDN0MsT0FBT0EsUUFBUDtFQUNELENBRkQsTUFHSyxJQUFJQyxRQUFRLElBQUk5RCxPQUFPLENBQUM0RCxTQUFELEVBQVlFLFFBQVosQ0FBdkIsRUFBOEM7SUFDakQsT0FBT0EsUUFBUDtFQUNEOztFQUNELE9BQU9GLFNBQVA7QUFDRCxDQVJEO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsTUFBTUcsU0FBUyxHQUFJNUMsSUFBRCxJQUFVO0VBQzFCLE9BQU9BLElBQUksSUFBSSxFQUFSLEdBQWEsSUFBYixHQUFvQixJQUEzQjtBQUNELENBRkQ7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLE1BQU02QyxhQUFhLEdBQUcsQ0FBQzVELEdBQUQsRUFBTTZELFVBQU4sS0FBcUI7RUFDekMsTUFBTTtJQUFFckUsS0FBRjtJQUFTQyxHQUFUO0lBQWNDLElBQWQ7SUFBb0JxQixJQUFwQjtJQUEwQnNDO0VBQTFCLElBQXFDUCxTQUFTLENBQUM5QyxHQUFELENBQXBEO0VBQ0E7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0VBQ0UsTUFBTThELFNBQVMsR0FBR3BFLElBQUksS0FBSyxJQUFULElBQWlCQSxJQUFJLEtBQUssS0FBSyxDQUEvQixHQUFtQ0EsSUFBbkMsR0FBMENtRSxVQUFVLENBQUNuRSxJQUF2RTtFQUNBLE1BQU1xRSxVQUFVLEdBQUd2RSxLQUFLLEtBQUssSUFBVixJQUFrQkEsS0FBSyxLQUFLLEtBQUssQ0FBakMsR0FBcUNBLEtBQXJDLEdBQTZDLEVBQWhFO0VBQ0EsT0FBTztJQUNMQSxLQUFLLEVBQUV1RSxVQURGO0lBRUx0RSxHQUFHLEVBQUVBLEdBQUcsS0FBSyxJQUFSLElBQWdCQSxHQUFHLEtBQUssS0FBSyxDQUE3QixHQUFpQ0EsR0FBakMsR0FBdUNnQyxpQkFBaUIsQ0FBQ3NDLFVBQUQsRUFBYUQsU0FBYixDQUZ4RDs7SUFHTDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0lBQ0lwRSxJQUFJLEVBQUVvRSxTQVJEO0lBU0wvQyxJQUFJLEVBQUVBLElBQUksS0FBSyxJQUFULElBQWlCQSxJQUFJLEtBQUssS0FBSyxDQUEvQixHQUFtQ0EsSUFBbkMsR0FBMEMsRUFUM0M7SUFVTHNDLE1BQU0sRUFBRUEsTUFBTSxLQUFLLElBQVgsSUFBbUJBLE1BQU0sS0FBSyxLQUFLLENBQW5DLEdBQXVDQSxNQUF2QyxHQUFnRDtFQVZuRCxDQUFQO0FBWUQsQ0ExQkQ7QUEyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxNQUFNVyxhQUFhLEdBQUcsQ0FBQ2pFLEdBQUQsRUFBTThELFVBQU4sS0FBcUI7RUFDekMsTUFBTTtJQUFFckUsS0FBRjtJQUFTQyxHQUFUO0lBQWNDLElBQWQ7SUFBb0JxQixJQUFwQjtJQUEwQnNDO0VBQTFCLElBQXFDUCxTQUFTLENBQUMvQyxHQUFELENBQXBEO0VBQ0E7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0VBQ0UsT0FBTztJQUNMUCxLQUFLLEVBQUVBLEtBQUssS0FBSyxJQUFWLElBQWtCQSxLQUFLLEtBQUssS0FBSyxDQUFqQyxHQUFxQ0EsS0FBckMsR0FBNkMsQ0FEL0M7SUFFTEMsR0FBRyxFQUFFQSxHQUFHLEtBQUssSUFBUixJQUFnQkEsR0FBRyxLQUFLLEtBQUssQ0FBN0IsR0FBaUNBLEdBQWpDLEdBQXVDLENBRnZDOztJQUdMO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7SUFDSUMsSUFBSSxFQUFFQSxJQUFJLEtBQUssSUFBVCxJQUFpQkEsSUFBSSxLQUFLLEtBQUssQ0FBL0IsR0FBbUNBLElBQW5DLEdBQTBDbUUsVUFBVSxDQUFDbkUsSUFSdEQ7SUFTTHFCLElBQUksRUFBRUEsSUFBSSxLQUFLLElBQVQsSUFBaUJBLElBQUksS0FBSyxLQUFLLENBQS9CLEdBQW1DQSxJQUFuQyxHQUEwQyxDQVQzQztJQVVMc0MsTUFBTSxFQUFFQSxNQUFNLEtBQUssSUFBWCxJQUFtQkEsTUFBTSxLQUFLLEtBQUssQ0FBbkMsR0FBdUNBLE1BQXZDLEdBQWdEO0VBVm5ELENBQVA7QUFZRCxDQXhCRDs7QUEwQkEsTUFBTVksUUFBUSxHQUFJN0QsR0FBRCxJQUFTO0VBQ3hCLE9BQU8sQ0FBQyxPQUFPQSxHQUFHLEtBQUtDLFNBQVIsR0FBb0I2RCxJQUFJLENBQUNDLEdBQUwsQ0FBUy9ELEdBQVQsQ0FBcEIsR0FBb0MsR0FBM0MsQ0FBRCxFQUFrRGdFLEtBQWxELENBQXdELENBQUMsQ0FBekQsQ0FBUDtBQUNELENBRkQ7O0FBR0EsTUFBTUMsU0FBUyxHQUFJakUsR0FBRCxJQUFTO0VBQ3pCLE9BQU8sQ0FBQyxTQUFTQSxHQUFHLEtBQUtDLFNBQVIsR0FBb0I2RCxJQUFJLENBQUNDLEdBQUwsQ0FBUy9ELEdBQVQsQ0FBcEIsR0FBb0MsR0FBN0MsQ0FBRCxFQUFvRGdFLEtBQXBELENBQTBELENBQUMsQ0FBM0QsQ0FBUDtBQUNELENBRkQ7O0FBR0EsU0FBU0UsZ0JBQVQsQ0FBMEJDLElBQTFCLEVBQWdDO0VBQzlCLElBQUlyRSxLQUFLLENBQUNDLE9BQU4sQ0FBY29FLElBQWQsQ0FBSixFQUF5QjtJQUN2QixPQUFPQSxJQUFJLENBQUNsQyxHQUFMLENBQVVqQixLQUFELElBQVdrRCxnQkFBZ0IsQ0FBQ2xELEtBQUQsQ0FBcEMsQ0FBUDtFQUNELENBSDZCLENBSTlCOzs7RUFDQSxJQUFJb0QsR0FBRyxHQUFHLEVBQVY7O0VBQ0EsSUFBSUQsSUFBSSxDQUFDN0UsSUFBTCxLQUFjVyxTQUFsQixFQUE2QjtJQUMzQjtJQUNBbUUsR0FBRyxHQUFHSCxTQUFTLENBQUNFLElBQUksQ0FBQzdFLElBQU4sQ0FBZjs7SUFDQSxJQUFJNkUsSUFBSSxDQUFDL0UsS0FBTCxLQUFlYSxTQUFuQixFQUE4QjtNQUM1QjtNQUNBbUUsR0FBRyxJQUFJLE1BQU1QLFFBQVEsQ0FBQ00sSUFBSSxDQUFDL0UsS0FBTixDQUFyQjs7TUFDQSxJQUFJK0UsSUFBSSxDQUFDOUUsR0FBTCxLQUFhWSxTQUFqQixFQUE0QjtRQUMxQjtRQUNBbUUsR0FBRyxJQUFJLE1BQU1QLFFBQVEsQ0FBQ00sSUFBSSxDQUFDOUUsR0FBTixDQUFyQjs7UUFDQSxJQUFJOEUsSUFBSSxDQUFDeEQsSUFBTCxLQUFjVixTQUFsQixFQUE2QjtVQUMzQjtVQUNBbUUsR0FBRyxJQUFLLElBQUdQLFFBQVEsQ0FBQ00sSUFBSSxDQUFDeEQsSUFBTixDQUFZLElBQUdrRCxRQUFRLENBQUNNLElBQUksQ0FBQ2xCLE1BQU4sQ0FBYyxLQUF4RDs7VUFDQSxJQUFJa0IsSUFBSSxDQUFDbkIsUUFBTCxLQUFrQi9DLFNBQXRCLEVBQWlDO1lBQy9CO1lBQ0FtRSxHQUFHLElBQUksR0FBUDtVQUNELENBSEQsTUFJSztZQUNIO1lBQ0FBLEdBQUcsSUFDRCxDQUFDRCxJQUFJLENBQUNuQixRQUFMLEdBQWdCLENBQWhCLEdBQW9CLEdBQXBCLEdBQTBCLEdBQTNCLElBQ0VhLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDTyxLQUFMLENBQVdQLElBQUksQ0FBQ0MsR0FBTCxDQUFTSSxJQUFJLENBQUNuQixRQUFMLEdBQWdCLEVBQXpCLENBQVgsQ0FBRCxDQURWLEdBRUUsR0FGRixHQUdFYSxRQUFRLENBQUNNLElBQUksQ0FBQ25CLFFBQUwsR0FBZ0IsRUFBakIsQ0FKWjtVQUtEO1FBQ0Y7TUFDRjtJQUNGO0VBQ0YsQ0EzQkQsTUE0QkssSUFBSW1CLElBQUksQ0FBQ3hELElBQUwsS0FBY1YsU0FBbEIsRUFBNkI7SUFDaEM7SUFDQW1FLEdBQUcsR0FBR1AsUUFBUSxDQUFDTSxJQUFJLENBQUN4RCxJQUFOLENBQVIsR0FBc0IsR0FBdEIsR0FBNEJrRCxRQUFRLENBQUNNLElBQUksQ0FBQ2xCLE1BQU4sQ0FBMUM7RUFDRDs7RUFDRCxPQUFPbUIsR0FBUDtBQUNEO0FBQ0Q7QUFDQTtBQUNBOzs7QUFDQSxNQUFNRSxxQkFBcUIsR0FBRyxDQUFDM0QsSUFBRCxFQUFPdUMsSUFBUCxLQUFnQjtFQUM1QyxJQUFJQSxJQUFJLEtBQUtqRCxTQUFiLEVBQXdCO0lBQ3RCLE9BQU9VLElBQVA7RUFDRDtFQUNEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7RUFDRSxJQUFJdUMsSUFBSSxLQUFLLElBQWIsRUFBbUI7SUFDakIsSUFBSXZDLElBQUksS0FBSyxFQUFiLEVBQWlCO01BQ2YsT0FBTyxDQUFQO0lBQ0Q7O0lBQ0QsT0FBT0EsSUFBUDtFQUNEO0VBQ0Q7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0VBQ0UsSUFBSUEsSUFBSSxLQUFLLEVBQWIsRUFBaUI7SUFDZixPQUFPLEVBQVA7RUFDRDs7RUFDRCxPQUFPQSxJQUFJLEdBQUcsRUFBZDtBQUNELENBN0JEOztBQThCQSxNQUFNNEQsY0FBYyxHQUFJQyxRQUFELElBQWM7RUFDbkMsTUFBTTtJQUFFL0I7RUFBRixJQUFnQitCLFFBQXRCOztFQUNBLElBQUkvQixTQUFTLEtBQUssSUFBZCxJQUFzQkEsU0FBUyxLQUFLeEMsU0FBeEMsRUFBbUQ7SUFDakQsTUFBTSxJQUFJbUIsS0FBSixDQUFVLHlCQUFWLENBQU47RUFDRDs7RUFDRCxPQUFPcUQsWUFBWSxDQUFDRCxRQUFELEVBQVcvQixTQUFYLENBQW5CO0FBQ0QsQ0FORDs7QUFPQSxNQUFNaUMsWUFBWSxHQUFJRixRQUFELElBQWM7RUFDakMsTUFBTTtJQUFFL0I7RUFBRixJQUFnQitCLFFBQXRCOztFQUNBLElBQUkvQixTQUFTLEtBQUssSUFBZCxJQUFzQkEsU0FBUyxLQUFLeEMsU0FBeEMsRUFBbUQ7SUFDakQsTUFBTSxJQUFJbUIsS0FBSixDQUFVLHlCQUFWLENBQU47RUFDRDs7RUFDRCxPQUFPdUQsT0FBTyxDQUFDSCxRQUFELEVBQVcsSUFBSS9CLFNBQWYsQ0FBZDtBQUNELENBTkQ7O0FBT0EsTUFBTW1DLFVBQVUsR0FBSUosUUFBRCxJQUFjO0VBQy9CLE9BQU9HLE9BQU8sQ0FBQ0gsUUFBRCxFQUFXLENBQVgsQ0FBZDtBQUNELENBRkQ7O0FBR0EsTUFBTUssY0FBYyxHQUFJTCxRQUFELElBQWM7RUFDbkMsT0FBT0MsWUFBWSxDQUFDRCxRQUFELEVBQVcsQ0FBWCxDQUFuQjtBQUNELENBRkQ7O0FBR0EsTUFBTU0sZUFBZSxHQUFJTixRQUFELElBQWM7RUFDcEMsT0FBT0MsWUFBWSxDQUFDRCxRQUFELEVBQVcsQ0FBWCxDQUFuQjtBQUNELENBRkQ7O0FBR0EsTUFBTU8sV0FBVyxHQUFJUCxRQUFELElBQWM7RUFDaEMsT0FBT0csT0FBTyxDQUFDSCxRQUFELEVBQVcsQ0FBWCxDQUFkO0FBQ0QsQ0FGRDtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsTUFBTUMsWUFBWSxHQUFHLENBQUNELFFBQUQsRUFBV1EsT0FBWCxLQUF1QjtFQUMxQyxNQUFNO0lBQUU1RixLQUFGO0lBQVNDLEdBQVQ7SUFBY0M7RUFBZCxJQUF1QmtGLFFBQTdCOztFQUNBLElBQUluRixHQUFHLEtBQUssSUFBWixFQUFrQjtJQUNoQixNQUFNLElBQUkrQixLQUFKLENBQVUsaUJBQVYsQ0FBTjtFQUNEOztFQUNELE1BQU02RCxZQUFZLEdBQUc7SUFDbkI3RixLQURtQjtJQUVuQkMsR0FGbUI7SUFHbkJDO0VBSG1CLENBQXJCO0VBS0EyRixZQUFZLENBQUM1RixHQUFiLEdBQW1CQSxHQUFHLEdBQUcyRixPQUF6QjtFQUNBO0FBQ0Y7QUFDQTtBQUNBOztFQUNFLElBQUlDLFlBQVksQ0FBQzVGLEdBQWIsR0FBbUIsQ0FBdkIsRUFBMEI7SUFDeEI0RixZQUFZLENBQUM3RixLQUFiLElBQXNCLENBQXRCO0VBQ0Q7RUFDRDtBQUNGO0FBQ0E7QUFDQTs7O0VBQ0UsSUFBSTZGLFlBQVksQ0FBQzdGLEtBQWIsR0FBcUIsQ0FBekIsRUFBNEI7SUFDMUI2RixZQUFZLENBQUM3RixLQUFiLEdBQXFCLEVBQXJCO0lBQ0E2RixZQUFZLENBQUMzRixJQUFiLElBQXFCLENBQXJCO0VBQ0Q7RUFDRDtBQUNGO0FBQ0E7QUFDQTs7O0VBQ0UsSUFBSTJGLFlBQVksQ0FBQzVGLEdBQWIsR0FBbUIsQ0FBdkIsRUFBMEI7SUFDeEIsTUFBTTZGLFdBQVcsR0FBRzdELGlCQUFpQixDQUFDNEQsWUFBWSxDQUFDN0YsS0FBZCxFQUFxQjZGLFlBQVksQ0FBQzNGLElBQWxDLENBQXJDO0lBQ0E7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztJQUNJMkYsWUFBWSxDQUFDNUYsR0FBYixHQUFtQjZGLFdBQVcsR0FBR0QsWUFBWSxDQUFDNUYsR0FBOUM7RUFDRDs7RUFDRCxPQUFPNEYsWUFBUDtBQUNELENBNUNEO0FBNkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsTUFBTU4sT0FBTyxHQUFHLENBQUNILFFBQUQsRUFBV1EsT0FBWCxLQUF1QjtFQUNyQyxNQUFNO0lBQUU1RixLQUFGO0lBQVNDLEdBQVQ7SUFBY0M7RUFBZCxJQUF1QmtGLFFBQTdCOztFQUNBLElBQUluRixHQUFHLEtBQUssSUFBWixFQUFrQjtJQUNoQixNQUFNLElBQUkrQixLQUFKLENBQVUsaUJBQVYsQ0FBTjtFQUNEOztFQUNELE1BQU02RCxZQUFZLEdBQUc7SUFDbkI3RixLQURtQjtJQUVuQkMsR0FGbUI7SUFHbkJDO0VBSG1CLENBQXJCO0VBS0EsTUFBTTRGLFdBQVcsR0FBRzdELGlCQUFpQixDQUFDakMsS0FBRCxFQUFRRSxJQUFSLENBQXJDO0VBQ0EyRixZQUFZLENBQUM1RixHQUFiLEdBQW1CQSxHQUFHLEdBQUcyRixPQUF6QjtFQUNBO0FBQ0Y7QUFDQTtBQUNBOztFQUNFLElBQUlDLFlBQVksQ0FBQzVGLEdBQWIsR0FBbUI2RixXQUF2QixFQUFvQztJQUNsQ0QsWUFBWSxDQUFDNUYsR0FBYixJQUFvQjZGLFdBQXBCO0lBQ0FELFlBQVksQ0FBQzdGLEtBQWIsSUFBc0IsQ0FBdEI7RUFDRDtFQUNEO0FBQ0Y7QUFDQTtBQUNBOzs7RUFDRSxJQUFJNkYsWUFBWSxDQUFDN0YsS0FBYixHQUFxQixFQUF6QixFQUE2QjtJQUMzQjZGLFlBQVksQ0FBQzdGLEtBQWIsR0FBcUIsQ0FBckI7SUFDQTZGLFlBQVksQ0FBQzNGLElBQWIsSUFBcUIsQ0FBckI7RUFDRDs7RUFDRCxPQUFPMkYsWUFBUDtBQUNELENBN0JEO0FBOEJBO0FBQ0E7QUFDQTs7O0FBQ0EsTUFBTUUsZ0JBQWdCLEdBQUlYLFFBQUQsSUFBYztFQUNyQztBQUNGO0FBQ0E7QUFDQTtFQUNFLE1BQU1wRixLQUFLLEdBQUdvRixRQUFRLENBQUNwRixLQUFULEtBQW1CLENBQW5CLEdBQXVCLEVBQXZCLEdBQTRCb0YsUUFBUSxDQUFDcEYsS0FBVCxHQUFpQixDQUEzRDtFQUNBLE1BQU1FLElBQUksR0FBR2tGLFFBQVEsQ0FBQ3BGLEtBQVQsS0FBbUIsQ0FBbkIsR0FBdUJvRixRQUFRLENBQUNsRixJQUFULEdBQWdCLENBQXZDLEdBQTJDa0YsUUFBUSxDQUFDbEYsSUFBakU7RUFDQSxNQUFNOEYsY0FBYyxHQUFHL0QsaUJBQWlCLENBQUNqQyxLQUFELEVBQVFFLElBQVIsQ0FBeEM7RUFDQSxNQUFNRCxHQUFHLEdBQUcrRixjQUFjLEdBQUdaLFFBQVEsQ0FBQ25GLEdBQTFCLEdBQWdDK0YsY0FBaEMsR0FBaURaLFFBQVEsQ0FBQ25GLEdBQXRFO0VBQ0EsT0FBTztJQUFFRCxLQUFGO0lBQVNFLElBQVQ7SUFBZUQ7RUFBZixDQUFQO0FBQ0QsQ0FWRDtBQVdBO0FBQ0E7QUFDQTs7O0FBQ0EsTUFBTWdHLFlBQVksR0FBSWIsUUFBRCxJQUFjO0VBQ2pDO0FBQ0Y7QUFDQTtBQUNBO0VBQ0UsTUFBTXBGLEtBQUssR0FBR29GLFFBQVEsQ0FBQ3BGLEtBQVQsS0FBbUIsRUFBbkIsR0FBd0IsQ0FBeEIsR0FBNEJvRixRQUFRLENBQUNwRixLQUFULEdBQWlCLENBQTNEO0VBQ0EsTUFBTUUsSUFBSSxHQUFHa0YsUUFBUSxDQUFDcEYsS0FBVCxLQUFtQixFQUFuQixHQUF3Qm9GLFFBQVEsQ0FBQ2xGLElBQVQsR0FBZ0IsQ0FBeEMsR0FBNENrRixRQUFRLENBQUNsRixJQUFsRTtFQUNBLE1BQU04RixjQUFjLEdBQUcvRCxpQkFBaUIsQ0FBQ2pDLEtBQUQsRUFBUUUsSUFBUixDQUF4QztFQUNBLE1BQU1ELEdBQUcsR0FBRytGLGNBQWMsR0FBR1osUUFBUSxDQUFDbkYsR0FBMUIsR0FBZ0MrRixjQUFoQyxHQUFpRFosUUFBUSxDQUFDbkYsR0FBdEU7RUFDQSxPQUFPO0lBQUVELEtBQUY7SUFBU0UsSUFBVDtJQUFlRDtFQUFmLENBQVA7QUFDRCxDQVZEOztBQVdBLE1BQU1pRyxVQUFVLEdBQUcsQ0FBQ2QsUUFBRCxFQUFXZSxTQUFYLEtBQXlCO0VBQzFDLE1BQU1uRyxLQUFLLEdBQUdvRixRQUFRLENBQUNwRixLQUF2QjtFQUNBLE1BQU1FLElBQUksR0FBR2tGLFFBQVEsQ0FBQ2xGLElBQVQsR0FBZ0JpRyxTQUE3QjtFQUNBLE1BQU1ILGNBQWMsR0FBRy9ELGlCQUFpQixDQUFDakMsS0FBRCxFQUFRRSxJQUFSLENBQXhDO0VBQ0EsTUFBTUQsR0FBRyxHQUFHK0YsY0FBYyxHQUFHWixRQUFRLENBQUNuRixHQUExQixHQUFnQytGLGNBQWhDLEdBQWlEWixRQUFRLENBQUNuRixHQUF0RTtFQUNBLE9BQU87SUFBRUQsS0FBRjtJQUFTRSxJQUFUO0lBQWVEO0VBQWYsQ0FBUDtBQUNELENBTkQ7QUFPQTtBQUNBO0FBQ0E7OztBQUNBLE1BQU1tRyxlQUFlLEdBQUloQixRQUFELElBQWM7RUFDcEMsT0FBT2MsVUFBVSxDQUFDZCxRQUFELEVBQVcsQ0FBQyxDQUFaLENBQWpCO0FBQ0QsQ0FGRDtBQUdBO0FBQ0E7QUFDQTs7O0FBQ0EsTUFBTWlCLFdBQVcsR0FBSWpCLFFBQUQsSUFBYztFQUNoQyxPQUFPYyxVQUFVLENBQUNkLFFBQUQsRUFBVyxDQUFYLENBQWpCO0FBQ0QsQ0FGRDtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsTUFBTWtCLG9CQUFvQixHQUFHLENBQUMvRSxJQUFELEVBQU9nRixTQUFQLEVBQWtCekMsSUFBbEIsS0FBMkI7RUFDdEQsSUFBSXlDLFNBQUosRUFBZTtJQUNiLE9BQU9oRixJQUFQO0VBQ0Q7O0VBQ0QsT0FBTzJELHFCQUFxQixDQUFDM0QsSUFBRCxFQUFPdUMsSUFBUCxDQUE1QjtBQUNELENBTEQ7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLE1BQU0wQyxxQkFBcUIsR0FBRyxDQUFDQyxZQUFELEVBQWVDLE9BQWYsS0FBMkI7RUFDdkQsTUFBTTtJQUFFNUMsSUFBSSxFQUFFNkMsV0FBUjtJQUFxQnBGO0VBQXJCLElBQThCa0YsWUFBcEM7RUFDQSxJQUFJRyxPQUFPLEdBQUdyRixJQUFkO0VBQ0E7QUFDRjtBQUNBO0FBQ0E7O0VBQ0UsSUFBSW9GLFdBQVcsS0FBSyxJQUFoQixJQUF3QkQsT0FBTyxLQUFLLElBQXhDLEVBQThDO0lBQzVDRSxPQUFPLEdBQUcxQixxQkFBcUIsQ0FBQzBCLE9BQUQsRUFBVSxJQUFWLENBQS9CO0lBQ0E7QUFDSjtBQUNBO0VBQ0csQ0FMRCxNQU1LLElBQUlELFdBQVcsS0FBSyxJQUFoQixJQUF3QkQsT0FBTyxLQUFLLElBQXhDLEVBQThDO0lBQ2pERSxPQUFPLEdBQUdsQyxJQUFJLENBQUNDLEdBQUwsQ0FBU2lDLE9BQU8sR0FBRyxFQUFuQixDQUFWO0VBQ0Q7O0VBQ0QsT0FBT0EsT0FBUDtBQUNELENBakJEO0FBa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLE1BQU1DLGFBQWEsR0FBRyxDQUFDakYsS0FBRCxFQUFRcUMsUUFBUixFQUFrQkMsUUFBbEIsS0FBK0I7RUFDbkQsTUFBTTtJQUFFbEUsS0FBRjtJQUFTQyxHQUFUO0lBQWNDO0VBQWQsSUFBdUIwQixLQUE3QjtFQUNBLE1BQU1rRixTQUFTLEdBQUdDLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjLEVBQWQsRUFBa0JwRixLQUFsQixDQUFsQjtFQUNBLE1BQU1nRSxPQUFPLEdBQUczRCxpQkFBaUIsQ0FBQ2pDLEtBQUQsRUFBUUUsSUFBUixDQUFqQztFQUNBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7RUFDRSxJQUFJRCxHQUFHLEtBQUssSUFBUixJQUFnQjJGLE9BQU8sR0FBRzNGLEdBQTlCLEVBQW1DO0lBQ2pDNkcsU0FBUyxDQUFDN0csR0FBVixHQUFnQjJGLE9BQWhCO0VBQ0Q7RUFDRDtBQUNGO0FBQ0E7QUFDQTs7O0VBQ0UsSUFBSTNCLFFBQVEsS0FBS3BELFNBQWIsSUFBMEJoQixTQUFTLENBQUNpSCxTQUFELEVBQVk3QyxRQUFaLENBQXZDLEVBQThEO0lBQzVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtJQUNJLElBQUk2QyxTQUFTLENBQUN2RixJQUFWLEtBQW1CVixTQUFuQixJQUFnQ29ELFFBQVEsQ0FBQzFDLElBQVQsS0FBa0JWLFNBQXRELEVBQWlFO01BQy9ELElBQUlpRyxTQUFTLENBQUN2RixJQUFWLEdBQWlCMEMsUUFBUSxDQUFDMUMsSUFBOUIsRUFBb0M7UUFDbEN1RixTQUFTLENBQUN2RixJQUFWLEdBQWlCMEMsUUFBUSxDQUFDMUMsSUFBMUI7UUFDQXVGLFNBQVMsQ0FBQ2pELE1BQVYsR0FBbUJJLFFBQVEsQ0FBQ0osTUFBNUI7UUFDQTtBQUNSO0FBQ0E7QUFDQTtNQUNPLENBUEQsTUFRSyxJQUFJaUQsU0FBUyxDQUFDdkYsSUFBVixLQUFtQjBDLFFBQVEsQ0FBQzFDLElBQTVCLElBQ1B1RixTQUFTLENBQUNqRCxNQUFWLEtBQXFCaEQsU0FEZCxJQUVQb0QsUUFBUSxDQUFDSixNQUFULEtBQW9CaEQsU0FGYixJQUdQaUcsU0FBUyxDQUFDakQsTUFBVixHQUFtQkksUUFBUSxDQUFDSixNQUh6QixFQUdpQztRQUNwQ2lELFNBQVMsQ0FBQ2pELE1BQVYsR0FBbUJJLFFBQVEsQ0FBQ0osTUFBNUI7TUFDRDtJQUNGO0VBQ0Y7RUFDRDtBQUNGO0FBQ0E7QUFDQTs7O0VBQ0UsSUFBSUssUUFBUSxLQUFLckQsU0FBYixJQUEwQmhCLFNBQVMsQ0FBQytCLEtBQUQsRUFBUXNDLFFBQVIsQ0FBdkMsRUFBMEQ7SUFDeEQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0lBQ0ksSUFBSTRDLFNBQVMsQ0FBQ3ZGLElBQVYsS0FBbUJWLFNBQW5CLElBQWdDcUQsUUFBUSxDQUFDM0MsSUFBVCxLQUFrQlYsU0FBdEQsRUFBaUU7TUFDL0QsSUFBSWlHLFNBQVMsQ0FBQ3ZGLElBQVYsR0FBaUIyQyxRQUFRLENBQUMzQyxJQUE5QixFQUFvQztRQUNsQ3VGLFNBQVMsQ0FBQ3ZGLElBQVYsR0FBaUIyQyxRQUFRLENBQUMzQyxJQUExQjtRQUNBdUYsU0FBUyxDQUFDakQsTUFBVixHQUFtQkssUUFBUSxDQUFDTCxNQUE1QjtRQUNBO0FBQ1I7QUFDQTtBQUNBO01BQ08sQ0FQRCxNQVFLLElBQUlpRCxTQUFTLENBQUN2RixJQUFWLEtBQW1CMkMsUUFBUSxDQUFDM0MsSUFBNUIsSUFDUHVGLFNBQVMsQ0FBQ2pELE1BQVYsS0FBcUJoRCxTQURkLElBRVBxRCxRQUFRLENBQUNMLE1BQVQsS0FBb0JoRCxTQUZiLElBR1BpRyxTQUFTLENBQUNqRCxNQUFWLEdBQW1CSyxRQUFRLENBQUNMLE1BSHpCLEVBR2lDO1FBQ3BDaUQsU0FBUyxDQUFDakQsTUFBVixHQUFtQkssUUFBUSxDQUFDTCxNQUE1QjtNQUNEO0lBQ0Y7RUFDRjs7RUFDRCxPQUFPaUQsU0FBUDtBQUNELENBdEVEO0FBdUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLE1BQU1HLG1CQUFtQixHQUFHLENBQUM3QixRQUFELEVBQVc4QixXQUFYLEVBQXdCQyxTQUF4QixFQUFtQ0MsVUFBbkMsRUFBK0NDLFVBQS9DLEVBQTJEQyxZQUEzRCxLQUE0RTtFQUN0RyxNQUFNO0lBQUUvRixJQUFGO0lBQVFzQyxNQUFSO0lBQWdCNUQsR0FBaEI7SUFBcUJELEtBQXJCO0lBQTRCRTtFQUE1QixJQUFxQ2tGLFFBQTNDO0VBQ0EsTUFBTW1DLFNBQVMsR0FBR1IsTUFBTSxDQUFDQyxNQUFQLENBQWNELE1BQU0sQ0FBQ0MsTUFBUCxDQUFjLEVBQWQsRUFBa0I1QixRQUFsQixDQUFkLEVBQTJDO0lBQUUvQixTQUFTLEVBQUV4QztFQUFiLENBQTNDLENBQWxCOztFQUNBLElBQUlxRyxXQUFXLEtBQUtyRyxTQUFwQixFQUErQjtJQUM3QjBHLFNBQVMsQ0FBQ3ZILEtBQVYsR0FBa0J3SCxnQkFBZ0IsQ0FBQ3hILEtBQUQsRUFBUWtILFdBQVIsQ0FBbEM7RUFDRCxDQUxxRyxDQU10Rzs7O0VBQ0EsSUFBSWpILEdBQUcsS0FBSyxJQUFSLElBQWdCa0gsU0FBUyxLQUFLdEcsU0FBbEMsRUFBNkM7SUFDM0MwRyxTQUFTLENBQUN0SCxHQUFWLEdBQWdCdUgsZ0JBQWdCLENBQUN2SCxHQUFELEVBQU1rSCxTQUFOLENBQWhDO0VBQ0Q7O0VBQ0QsSUFBSUMsVUFBVSxLQUFLdkcsU0FBbkIsRUFBOEI7SUFDNUIwRyxTQUFTLENBQUNySCxJQUFWLEdBQWlCc0gsZ0JBQWdCLENBQUN0SCxJQUFELEVBQU9rSCxVQUFQLENBQWpDO0VBQ0Q7O0VBQ0QsSUFBSTdGLElBQUksS0FBS1YsU0FBVCxJQUFzQndHLFVBQVUsS0FBS3hHLFNBQXpDLEVBQW9EO0lBQ2xEMEcsU0FBUyxDQUFDaEcsSUFBVixHQUFpQmlHLGdCQUFnQixDQUFDakcsSUFBRCxFQUFPOEYsVUFBUCxDQUFqQztJQUNBRSxTQUFTLENBQUN6RCxJQUFWLEdBQWlCSyxTQUFTLENBQUNvRCxTQUFTLENBQUNoRyxJQUFYLENBQTFCO0VBQ0Q7O0VBQ0QsSUFBSXNDLE1BQU0sS0FBS2hELFNBQVgsSUFBd0J5RyxZQUFZLEtBQUt6RyxTQUE3QyxFQUF3RDtJQUN0RDBHLFNBQVMsQ0FBQzFELE1BQVYsR0FBbUIyRCxnQkFBZ0IsQ0FBQzNELE1BQUQsRUFBU3lELFlBQVQsQ0FBbkM7RUFDRDs7RUFDRCxPQUFPQyxTQUFQO0FBQ0QsQ0FyQkQ7QUFzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLE1BQU1DLGdCQUFnQixHQUFHLENBQUNDLFNBQUQsRUFBWTdFLE1BQVosS0FBdUI7RUFDOUMsSUFBSThFLFlBQVksR0FBRzlFLE1BQU0sQ0FBQyxDQUFELENBQXpCO0VBQ0EsSUFBSStFLElBQUksR0FBR2pELElBQUksQ0FBQ0MsR0FBTCxDQUFTK0MsWUFBWSxHQUFHRCxTQUF4QixDQUFYOztFQUNBLEtBQUssSUFBSTlELENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdmLE1BQU0sQ0FBQ2dGLE1BQTNCLEVBQW1DakUsQ0FBQyxFQUFwQyxFQUF3QztJQUN0QyxNQUFNckQsS0FBSyxHQUFHc0MsTUFBTSxDQUFDZSxDQUFELENBQXBCO0lBQ0E7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0lBQ0ksTUFBTWtFLFNBQVMsR0FBR25ELElBQUksQ0FBQ0MsR0FBTCxDQUFTckUsS0FBSyxHQUFHbUgsU0FBakIsQ0FBbEI7O0lBQ0EsSUFBSUksU0FBUyxHQUFHRixJQUFoQixFQUFzQjtNQUNwQkQsWUFBWSxHQUFHcEgsS0FBZjtNQUNBcUgsSUFBSSxHQUFHRSxTQUFQO0lBQ0Q7RUFDRjs7RUFDRCxPQUFPSCxZQUFQO0FBQ0QsQ0FuQkQ7O0FBcUJBLE1BQU1JLHFCQUFxQixHQUFJQyxTQUFELElBQWU7RUFDM0MsSUFBSUEsU0FBUyxLQUFLbEgsU0FBbEIsRUFBNkI7SUFDM0IsT0FBTyxFQUFQO0VBQ0Q7O0VBQ0QsT0FBT2tILFNBQVMsQ0FBQ0MsV0FBVixFQUFQO0FBQ0QsQ0FMRDs7QUFNQSxNQUFNQyxnQkFBZ0IsR0FBRyxDQUFDL0csTUFBRCxFQUFTa0UsUUFBVCxFQUFtQm1CLFNBQW5CLEtBQWlDO0VBQ3hELElBQUluQixRQUFRLENBQUM3RCxJQUFULEtBQWtCVixTQUFsQixJQUErQnVFLFFBQVEsQ0FBQ3ZCLE1BQVQsS0FBb0JoRCxTQUF2RCxFQUFrRTtJQUNoRSxPQUFPLGNBQVA7RUFDRDs7RUFDRCxPQUFPLElBQUlRLElBQUksQ0FBQ0MsY0FBVCxDQUF3QkosTUFBeEIsRUFBZ0M7SUFDckNLLElBQUksRUFBRSxTQUQrQjtJQUVyQ3NDLE1BQU0sRUFBRSxTQUY2QjtJQUdyQ3FFLFFBQVEsRUFBRSxLQUgyQjs7SUFJckM7QUFDSjtBQUNBO0FBQ0E7SUFDSS9HLFNBQVMsRUFBRW9GLFNBQVMsR0FBRyxLQUFILEdBQVc7RUFSTSxDQUFoQyxFQVNKNEIsTUFUSSxDQVNHLElBQUl4RyxJQUFKLENBQVNtRCxnQkFBZ0IsQ0FBQ2lDLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjRCxNQUFNLENBQUNDLE1BQVAsQ0FBYyxFQUFkLEVBQWtCNUIsUUFBbEIsQ0FBZCxFQUEyQztJQUM3RTtJQUNBeEIsUUFBUSxFQUFFL0M7RUFGbUUsQ0FBM0MsQ0FBRCxDQUF6QixDQVRILENBQVA7QUFZRCxDQWhCRDtBQWlCQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsTUFBTXVILGNBQWMsR0FBSTlILEtBQUQsSUFBVztFQUNoQyxNQUFNK0gsYUFBYSxHQUFHL0gsS0FBSyxDQUFDZ0ksUUFBTixFQUF0Qjs7RUFDQSxJQUFJRCxhQUFhLENBQUNULE1BQWQsR0FBdUIsQ0FBM0IsRUFBOEI7SUFDNUIsT0FBT1MsYUFBUDtFQUNEOztFQUNELE9BQVEsSUFBR0EsYUFBYyxFQUF6QjtBQUNELENBTkQ7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLE1BQU1FLGdCQUFnQixHQUFHLENBQUNoSCxJQUFELEVBQU9nRixTQUFQLEtBQXFCO0VBQzVDLElBQUlBLFNBQUosRUFBZTtJQUNiLE9BQU82QixjQUFjLENBQUM3RyxJQUFELENBQXJCO0VBQ0Q7RUFDRDtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7RUFDRSxJQUFJQSxJQUFJLEtBQUssQ0FBYixFQUFnQjtJQUNkLE9BQU8sSUFBUDtFQUNEOztFQUNELE9BQU9BLElBQUksQ0FBQytHLFFBQUwsRUFBUDtBQUNELENBYkQ7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxNQUFNRSxvQkFBb0IsR0FBRyxDQUFDdEgsTUFBRCxFQUFTdUgsS0FBVCxFQUFnQnJELFFBQWhCLEtBQTZCO0VBQ3hELElBQUlBLFFBQVEsQ0FBQ25GLEdBQVQsS0FBaUIsSUFBckIsRUFBMkI7SUFDekIsT0FBTyxJQUFQO0VBQ0Q7RUFDRDtBQUNGO0FBQ0E7OztFQUNFLE1BQU15QixJQUFJLEdBQUcsSUFBSUMsSUFBSixDQUFVLEdBQUV5RCxRQUFRLENBQUNwRixLQUFNLElBQUdvRixRQUFRLENBQUNuRixHQUFJLElBQUdtRixRQUFRLENBQUNsRixJQUFLLFdBQTVELENBQWI7RUFDQSxNQUFNd0ksV0FBVyxHQUFHLElBQUlySCxJQUFJLENBQUNDLGNBQVQsQ0FBd0JKLE1BQXhCLEVBQWdDO0lBQ2xEeUgsT0FBTyxFQUFFLE1BRHlDO0lBRWxEM0ksS0FBSyxFQUFFLE1BRjJDO0lBR2xEQyxHQUFHLEVBQUUsU0FINkM7SUFJbERpSSxRQUFRLEVBQUU7RUFKd0MsQ0FBaEMsRUFLakJDLE1BTGlCLENBS1Z6RyxJQUxVLENBQXBCO0VBTUE7QUFDRjtBQUNBO0FBQ0E7O0VBQ0UsT0FBTytHLEtBQUssR0FBSSxVQUFTQyxXQUFZLEVBQXpCLEdBQTZCQSxXQUF6QztBQUNELENBbkJEO0FBb0JBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxNQUFNRSxjQUFjLEdBQUcsQ0FBQzFILE1BQUQsRUFBU2tFLFFBQVQsS0FBc0I7RUFDM0MsTUFBTTFELElBQUksR0FBRyxJQUFJQyxJQUFKLENBQVUsR0FBRXlELFFBQVEsQ0FBQ3BGLEtBQU0sSUFBR29GLFFBQVEsQ0FBQ25GLEdBQUksSUFBR21GLFFBQVEsQ0FBQ2xGLElBQUssV0FBNUQsQ0FBYjtFQUNBLE9BQU8sSUFBSW1CLElBQUksQ0FBQ0MsY0FBVCxDQUF3QkosTUFBeEIsRUFBZ0M7SUFBRXlILE9BQU8sRUFBRSxPQUFYO0lBQW9CM0ksS0FBSyxFQUFFLE9BQTNCO0lBQW9DQyxHQUFHLEVBQUUsU0FBekM7SUFBb0RpSSxRQUFRLEVBQUU7RUFBOUQsQ0FBaEMsRUFBdUdDLE1BQXZHLENBQThHekcsSUFBOUcsQ0FBUDtBQUNELENBSEQ7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLE1BQU1tSCxlQUFlLEdBQUcsQ0FBQzNILE1BQUQsRUFBU2tFLFFBQVQsS0FBc0I7RUFDNUMsTUFBTTFELElBQUksR0FBRyxJQUFJQyxJQUFKLENBQVUsR0FBRXlELFFBQVEsQ0FBQ3BGLEtBQU0sSUFBR29GLFFBQVEsQ0FBQ25GLEdBQUksSUFBR21GLFFBQVEsQ0FBQ2xGLElBQUssV0FBNUQsQ0FBYjtFQUNBLE9BQU8sSUFBSW1CLElBQUksQ0FBQ0MsY0FBVCxDQUF3QkosTUFBeEIsRUFBZ0M7SUFBRWxCLEtBQUssRUFBRSxNQUFUO0lBQWlCRSxJQUFJLEVBQUUsU0FBdkI7SUFBa0NnSSxRQUFRLEVBQUU7RUFBNUMsQ0FBaEMsRUFBcUZDLE1BQXJGLENBQTRGekcsSUFBNUYsQ0FBUDtBQUNELENBSEQ7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLE1BQU1vSCxrQkFBa0IsR0FBRyxDQUFDNUgsTUFBRCxFQUFTa0UsUUFBVCxLQUFzQjtFQUMvQyxPQUFPMkQsb0JBQW9CLENBQUM3SCxNQUFELEVBQVNrRSxRQUFULEVBQW1CO0lBQUVwRixLQUFLLEVBQUUsT0FBVDtJQUFrQkMsR0FBRyxFQUFFLFNBQXZCO0lBQWtDQyxJQUFJLEVBQUU7RUFBeEMsQ0FBbkIsQ0FBM0I7QUFDRCxDQUZEO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsTUFBTThJLE1BQU0sR0FBRyxDQUFDOUgsTUFBRCxFQUFTa0UsUUFBVCxLQUFzQjtFQUNuQyxPQUFPNkQseUJBQXlCLENBQUMvSCxNQUFELEVBQVNrRSxRQUFULEVBQW1CO0lBQUVuRixHQUFHLEVBQUU7RUFBUCxDQUFuQixDQUF6QixDQUFnRTZCLElBQWhFLENBQXNFb0gsR0FBRCxJQUFTQSxHQUFHLENBQUNuSCxJQUFKLEtBQWEsS0FBM0YsRUFBa0d6QixLQUF6RztBQUNELENBRkQ7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLE1BQU02SSxPQUFPLEdBQUcsQ0FBQ2pJLE1BQUQsRUFBU2tFLFFBQVQsS0FBc0I7RUFDcEMsT0FBTzJELG9CQUFvQixDQUFDN0gsTUFBRCxFQUFTa0UsUUFBVCxFQUFtQjtJQUFFbEYsSUFBSSxFQUFFO0VBQVIsQ0FBbkIsQ0FBM0I7QUFDRCxDQUZEOztBQUdBLE1BQU1rSixpQkFBaUIsR0FBSWhFLFFBQUQsSUFBYztFQUN0QyxNQUFNaUUsVUFBVSxHQUFHakUsUUFBUSxDQUFDN0QsSUFBVCxLQUFrQlYsU0FBbEIsSUFBK0J1RSxRQUFRLENBQUN2QixNQUFULEtBQW9CaEQsU0FBbkQsR0FBZ0UsSUFBR3VFLFFBQVEsQ0FBQzdELElBQUssSUFBRzZELFFBQVEsQ0FBQ3ZCLE1BQU8sRUFBcEcsR0FBd0csRUFBM0g7RUFDQSxPQUFPLElBQUlsQyxJQUFKLENBQVUsR0FBRXlELFFBQVEsQ0FBQ3BGLEtBQU0sSUFBR29GLFFBQVEsQ0FBQ25GLEdBQUksSUFBR21GLFFBQVEsQ0FBQ2xGLElBQUssR0FBRW1KLFVBQVcsV0FBekUsQ0FBUDtBQUNELENBSEQ7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxNQUFNTixvQkFBb0IsR0FBRyxDQUFDN0gsTUFBRCxFQUFTa0UsUUFBVCxFQUFtQjVELE9BQW5CLEtBQStCO0VBQzFELE1BQU1FLElBQUksR0FBRzBILGlCQUFpQixDQUFDaEUsUUFBRCxDQUE5QjtFQUNBLE9BQU9rRSxpQkFBaUIsQ0FBQ3BJLE1BQUQsRUFBU00sT0FBVCxDQUFqQixDQUFtQzJHLE1BQW5DLENBQTBDekcsSUFBMUMsQ0FBUDtBQUNELENBSEQ7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLE1BQU11SCx5QkFBeUIsR0FBRyxDQUFDL0gsTUFBRCxFQUFTa0UsUUFBVCxFQUFtQjVELE9BQW5CLEtBQStCO0VBQy9ELE1BQU1FLElBQUksR0FBRzBILGlCQUFpQixDQUFDaEUsUUFBRCxDQUE5QjtFQUNBLE9BQU9rRSxpQkFBaUIsQ0FBQ3BJLE1BQUQsRUFBU00sT0FBVCxDQUFqQixDQUFtQ0ssYUFBbkMsQ0FBaURILElBQWpELENBQVA7QUFDRCxDQUhEO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxNQUFNNEgsaUJBQWlCLEdBQUcsQ0FBQ3BJLE1BQUQsRUFBU00sT0FBVCxLQUFxQjtFQUM3QyxPQUFPLElBQUlILElBQUksQ0FBQ0MsY0FBVCxDQUF3QkosTUFBeEIsRUFBZ0M2RixNQUFNLENBQUNDLE1BQVAsQ0FBY0QsTUFBTSxDQUFDQyxNQUFQLENBQWMsRUFBZCxFQUFrQnhGLE9BQWxCLENBQWQsRUFBMEM7SUFBRTBHLFFBQVEsRUFBRTtFQUFaLENBQTFDLENBQWhDLENBQVA7QUFDRCxDQUZEO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsTUFBTXFCLGFBQWEsR0FBSXJJLE1BQUQsSUFBWTtFQUNoQyxJQUFJLHdCQUF3QkcsSUFBNUIsRUFBa0M7SUFDaEMsTUFBTW1JLEtBQUssR0FBRyxJQUFJbkksSUFBSSxDQUFDb0ksa0JBQVQsQ0FBNEJ2SSxNQUE1QixFQUFvQztNQUFFd0ksT0FBTyxFQUFFO0lBQVgsQ0FBcEMsRUFBeUR2QixNQUF6RCxDQUFnRSxDQUFoRSxFQUFtRSxLQUFuRSxDQUFkO0lBQ0EsT0FBT3FCLEtBQUssQ0FBQ0csTUFBTixDQUFhLENBQWIsRUFBZ0IzQixXQUFoQixLQUFnQ3dCLEtBQUssQ0FBQzVFLEtBQU4sQ0FBWSxDQUFaLENBQXZDO0VBQ0QsQ0FIRCxNQUlLO0lBQ0gsT0FBTyxPQUFQO0VBQ0Q7QUFDRixDQVJEO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsTUFBTWdGLGtCQUFrQixHQUFJbEksSUFBRCxJQUFVO0VBQ25DLE1BQU1rQyxRQUFRLEdBQUdsQyxJQUFJLENBQUNtSSxpQkFBTCxFQUFqQjtFQUNBbkksSUFBSSxDQUFDb0ksVUFBTCxDQUFnQnBJLElBQUksQ0FBQ3FJLFVBQUwsS0FBb0JuRyxRQUFwQztFQUNBLE9BQU9sQyxJQUFQO0FBQ0QsQ0FKRDs7QUFLQSxNQUFNc0ksT0FBTyxHQUFHSixrQkFBa0IsQ0FBQyxJQUFJakksSUFBSixDQUFTLFlBQVQsQ0FBRCxDQUFsQztBQUNBLE1BQU1zSSxPQUFPLEdBQUdMLGtCQUFrQixDQUFDLElBQUlqSSxJQUFKLENBQVMsWUFBVCxDQUFELENBQWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxNQUFNdUkscUJBQXFCLEdBQUcsQ0FBQ2hKLE1BQUQsRUFBUzZHLFNBQVQsS0FBdUI7RUFDbkQsTUFBTXJHLElBQUksR0FBR3FHLFNBQVMsS0FBSyxJQUFkLEdBQXFCaUMsT0FBckIsR0FBK0JDLE9BQTVDO0VBQ0EsTUFBTUUsa0JBQWtCLEdBQUcsSUFBSTlJLElBQUksQ0FBQ0MsY0FBVCxDQUF3QkosTUFBeEIsRUFBZ0M7SUFDekRLLElBQUksRUFBRSxTQURtRDtJQUV6RDJHLFFBQVEsRUFBRTtFQUYrQyxDQUFoQyxFQUl4QnJHLGFBSndCLENBSVZILElBSlUsRUFLeEJJLElBTHdCLENBS2xCc0ksSUFBRCxJQUFVQSxJQUFJLENBQUNySSxJQUFMLEtBQWMsV0FMTCxDQUEzQjs7RUFNQSxJQUFJb0ksa0JBQUosRUFBd0I7SUFDdEIsT0FBT0Esa0JBQWtCLENBQUM3SixLQUExQjtFQUNEOztFQUNELE9BQU93SCxxQkFBcUIsQ0FBQ0MsU0FBRCxDQUE1QjtBQUNELENBWkQ7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxNQUFNc0MsV0FBVyxHQUFJL0osS0FBRCxJQUFXO0VBQzdCLE9BQU9JLEtBQUssQ0FBQ0MsT0FBTixDQUFjTCxLQUFkLElBQXVCQSxLQUFLLENBQUNnSyxJQUFOLENBQVcsR0FBWCxDQUF2QixHQUF5Q2hLLEtBQWhEO0FBQ0QsQ0FGRDtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLE1BQU1pSyxRQUFRLEdBQUcsTUFBTTtFQUNyQjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0UsT0FBT1gsa0JBQWtCLENBQUMsSUFBSWpJLElBQUosRUFBRCxDQUFsQixDQUErQjZJLFdBQS9CLEVBQVA7QUFDRCxDQW5CRDs7QUFvQkEsTUFBTUMsT0FBTyxHQUFHLENBQ2QsQ0FEYyxFQUNYLENBRFcsRUFDUixDQURRLEVBQ0wsQ0FESyxFQUNGLENBREUsRUFDQyxDQURELEVBQ0ksQ0FESixFQUNPLENBRFAsRUFDVSxDQURWLEVBQ2EsQ0FEYixFQUNnQixFQURoQixFQUNvQixFQURwQixFQUN3QixFQUR4QixFQUM0QixFQUQ1QixFQUNnQyxFQURoQyxFQUNvQyxFQURwQyxFQUN3QyxFQUR4QyxFQUM0QyxFQUQ1QyxFQUNnRCxFQURoRCxFQUNvRCxFQURwRCxFQUN3RCxFQUR4RCxFQUM0RCxFQUQ1RCxFQUNnRSxFQURoRSxFQUNvRSxFQURwRSxFQUN3RSxFQUR4RSxFQUM0RSxFQUQ1RSxFQUNnRixFQURoRixFQUNvRixFQURwRixFQUN3RixFQUR4RixFQUM0RixFQUQ1RixFQUNnRyxFQURoRyxFQUNvRyxFQURwRyxFQUVkLEVBRmMsRUFFVixFQUZVLEVBRU4sRUFGTSxFQUVGLEVBRkUsRUFFRSxFQUZGLEVBRU0sRUFGTixFQUVVLEVBRlYsRUFFYyxFQUZkLEVBRWtCLEVBRmxCLEVBRXNCLEVBRnRCLEVBRTBCLEVBRjFCLEVBRThCLEVBRjlCLEVBRWtDLEVBRmxDLEVBRXNDLEVBRnRDLEVBRTBDLEVBRjFDLEVBRThDLEVBRjlDLEVBRWtELEVBRmxELEVBRXNELEVBRnRELEVBRTBELEVBRjFELEVBRThELEVBRjlELEVBRWtFLEVBRmxFLEVBRXNFLEVBRnRFLEVBRTBFLEVBRjFFLEVBRThFLEVBRjlFLEVBRWtGLEVBRmxGLEVBRXNGLEVBRnRGLEVBRTBGLEVBRjFGLEVBRThGLEVBRjlGLENBQWhCO0FBSUEsTUFBTUMsTUFBTSxHQUFHLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsRUFBbUIsQ0FBbkIsRUFBc0IsQ0FBdEIsRUFBeUIsQ0FBekIsRUFBNEIsQ0FBNUIsRUFBK0IsRUFBL0IsRUFBbUMsRUFBbkMsQ0FBZjtBQUNBLE1BQU1DLE1BQU0sR0FBRyxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLEVBQW1CLENBQW5CLEVBQXNCLENBQXRCLEVBQXlCLENBQXpCLEVBQTRCLENBQTVCLEVBQStCLEVBQS9CLEVBQW1DLEVBQW5DLEVBQXVDLEVBQXZDLEVBQTJDLEVBQTNDLEVBQStDLEVBQS9DLEVBQW1ELEVBQW5ELEVBQXVELEVBQXZELEVBQTJELEVBQTNELEVBQStELEVBQS9ELEVBQW1FLEVBQW5FLEVBQXVFLEVBQXZFLEVBQTJFLEVBQTNFLEVBQStFLEVBQS9FLEVBQW1GLEVBQW5GLENBQWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLE1BQU1DLGFBQWEsR0FBRyxDQUFDMUosTUFBRCxFQUFTMkosSUFBVCxFQUFlQyxjQUFjLEdBQUcsQ0FBaEMsS0FBc0M7RUFDMUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUNFLE1BQU1DLGFBQWEsR0FBR0YsSUFBSSxLQUFLLEtBQVQsR0FBaUIsT0FBakIsR0FBMkIsUUFBakQ7RUFDQSxNQUFNRyxJQUFJLEdBQUcsSUFBSTNKLElBQUksQ0FBQ0MsY0FBVCxDQUF3QkosTUFBeEIsRUFBZ0M7SUFBRXlILE9BQU8sRUFBRW9DO0VBQVgsQ0FBaEMsQ0FBYjtFQUNBLE1BQU1FLFNBQVMsR0FBRyxJQUFJdEosSUFBSixDQUFTLFlBQVQsQ0FBbEI7RUFDQSxNQUFNdUosVUFBVSxHQUFHLEVBQW5CO0VBQ0E7QUFDRjtBQUNBO0FBQ0E7O0VBQ0UsS0FBSyxJQUFJdkgsQ0FBQyxHQUFHbUgsY0FBYixFQUE2Qm5ILENBQUMsR0FBR21ILGNBQWMsR0FBRyxDQUFsRCxFQUFxRG5ILENBQUMsRUFBdEQsRUFBMEQ7SUFDeEQsTUFBTXdILFdBQVcsR0FBRyxJQUFJeEosSUFBSixDQUFTc0osU0FBVCxDQUFwQjtJQUNBRSxXQUFXLENBQUNDLE9BQVosQ0FBb0JELFdBQVcsQ0FBQ0UsT0FBWixLQUF3QjFILENBQTVDO0lBQ0F1SCxVQUFVLENBQUNJLElBQVgsQ0FBZ0JOLElBQUksQ0FBQzdDLE1BQUwsQ0FBWWdELFdBQVosQ0FBaEI7RUFDRDs7RUFDRCxPQUFPRCxVQUFQO0FBQ0QsQ0FwQkQ7QUFxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLE1BQU1LLGNBQWMsR0FBRyxDQUFDdkwsS0FBRCxFQUFRRSxJQUFSLEVBQWM0SyxjQUFkLEtBQWlDO0VBQ3RELE1BQU1sRixPQUFPLEdBQUczRCxpQkFBaUIsQ0FBQ2pDLEtBQUQsRUFBUUUsSUFBUixDQUFqQztFQUNBLE1BQU1zTCxZQUFZLEdBQUcsSUFBSTdKLElBQUosQ0FBVSxHQUFFM0IsS0FBTSxNQUFLRSxJQUFLLEVBQTVCLEVBQStCOEksTUFBL0IsRUFBckI7RUFDQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7RUFDRSxNQUFNeUMsTUFBTSxHQUFHRCxZQUFZLElBQUlWLGNBQWhCLEdBQWlDVSxZQUFZLElBQUlWLGNBQWMsR0FBRyxDQUFyQixDQUE3QyxHQUF1RSxLQUFLQSxjQUFjLEdBQUdVLFlBQXRCLENBQXRGO0VBQ0EsSUFBSUUsSUFBSSxHQUFHLEVBQVg7O0VBQ0EsS0FBSyxJQUFJL0gsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsSUFBSWlDLE9BQXJCLEVBQThCakMsQ0FBQyxFQUEvQixFQUFtQztJQUNqQytILElBQUksQ0FBQ0osSUFBTCxDQUFVO01BQUVyTCxHQUFHLEVBQUUwRCxDQUFQO01BQVVOLFNBQVMsRUFBRSxDQUFDb0ksTUFBTSxHQUFHOUgsQ0FBVixJQUFlO0lBQXBDLENBQVY7RUFDRDs7RUFDRCxLQUFLLElBQUlBLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLElBQUk4SCxNQUFyQixFQUE2QjlILENBQUMsRUFBOUIsRUFBa0M7SUFDaEMrSCxJQUFJLEdBQUcsQ0FBQztNQUFFekwsR0FBRyxFQUFFLElBQVA7TUFBYW9ELFNBQVMsRUFBRTtJQUF4QixDQUFELEVBQWlDLEdBQUdxSSxJQUFwQyxDQUFQO0VBQ0Q7O0VBQ0QsT0FBT0EsSUFBUDtBQUNELENBL0JEO0FBZ0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLE1BQU1DLFlBQVksR0FBRyxDQUFDdkcsUUFBRCxFQUFXakUsU0FBUyxHQUFHLEtBQXZCLEVBQThCOEMsUUFBOUIsRUFBd0NDLFFBQXhDLEVBQWtEbUQsVUFBbEQsRUFBOERDLFlBQTlELEtBQStFO0VBQ2xHLE1BQU1mLFNBQVMsR0FBR3BGLFNBQVMsS0FBSyxLQUFoQztFQUNBLElBQUl5SyxjQUFjLEdBQUdyRixTQUFTLEdBQUdvRSxNQUFILEdBQVlELE1BQTFDO0VBQ0EsSUFBSW1CLGdCQUFnQixHQUFHcEIsT0FBdkI7RUFDQSxJQUFJcUIsV0FBVyxHQUFHLElBQWxCO0VBQ0EsSUFBSUMsV0FBVyxHQUFHLElBQWxCOztFQUNBLElBQUkxRSxVQUFKLEVBQWdCO0lBQ2R1RSxjQUFjLEdBQUdBLGNBQWMsQ0FBQzVJLE1BQWYsQ0FBdUJ6QixJQUFELElBQVU4RixVQUFVLENBQUMyRSxRQUFYLENBQW9CekssSUFBcEIsQ0FBaEMsQ0FBakI7RUFDRDs7RUFDRCxJQUFJK0YsWUFBSixFQUFrQjtJQUNoQnVFLGdCQUFnQixHQUFHQSxnQkFBZ0IsQ0FBQzdJLE1BQWpCLENBQXlCYSxNQUFELElBQVl5RCxZQUFZLENBQUMwRSxRQUFiLENBQXNCbkksTUFBdEIsQ0FBcEMsQ0FBbkI7RUFDRDs7RUFDRCxJQUFJSSxRQUFKLEVBQWM7SUFDWjtBQUNKO0FBQ0E7QUFDQTtBQUNBO0lBQ0ksSUFBSXBFLFNBQVMsQ0FBQ3VGLFFBQUQsRUFBV25CLFFBQVgsQ0FBYixFQUFtQztNQUNqQztBQUNOO0FBQ0E7QUFDQTtBQUNBO01BQ00sSUFBSUEsUUFBUSxDQUFDMUMsSUFBVCxLQUFrQlYsU0FBdEIsRUFBaUM7UUFDL0IrSyxjQUFjLEdBQUdBLGNBQWMsQ0FBQzVJLE1BQWYsQ0FBdUJ6QixJQUFELElBQVU7VUFDL0MsTUFBTTBLLGFBQWEsR0FBRzdHLFFBQVEsQ0FBQ3RCLElBQVQsS0FBa0IsSUFBbEIsR0FBeUIsQ0FBQ3ZDLElBQUksR0FBRyxFQUFSLElBQWMsRUFBdkMsR0FBNENBLElBQWxFO1VBQ0EsT0FBTyxDQUFDZ0YsU0FBUyxHQUFHaEYsSUFBSCxHQUFVMEssYUFBcEIsS0FBc0NoSSxRQUFRLENBQUMxQyxJQUF0RDtRQUNELENBSGdCLENBQWpCO1FBSUF1SyxXQUFXLEdBQUc3SCxRQUFRLENBQUMxQyxJQUFULEdBQWdCLEVBQTlCO01BQ0Q7O01BQ0QsSUFBSTBDLFFBQVEsQ0FBQ0osTUFBVCxLQUFvQmhELFNBQXhCLEVBQW1DO1FBQ2pDO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO1FBQ1EsSUFBSXFMLGFBQWEsR0FBRyxLQUFwQjs7UUFDQSxJQUFJakksUUFBUSxDQUFDMUMsSUFBVCxLQUFrQlYsU0FBbEIsSUFBK0J1RSxRQUFRLENBQUM3RCxJQUFULEtBQWtCVixTQUFyRCxFQUFnRTtVQUM5RCxJQUFJdUUsUUFBUSxDQUFDN0QsSUFBVCxHQUFnQjBDLFFBQVEsQ0FBQzFDLElBQTdCLEVBQW1DO1lBQ2pDMkssYUFBYSxHQUFHLElBQWhCO1VBQ0Q7UUFDRjs7UUFDREwsZ0JBQWdCLEdBQUdBLGdCQUFnQixDQUFDN0ksTUFBakIsQ0FBeUJhLE1BQUQsSUFBWTtVQUNyRCxJQUFJcUksYUFBSixFQUFtQjtZQUNqQixPQUFPLElBQVA7VUFDRDs7VUFDRCxPQUFPckksTUFBTSxJQUFJSSxRQUFRLENBQUNKLE1BQTFCO1FBQ0QsQ0FMa0IsQ0FBbkI7TUFNRDtNQUNEO0FBQ047QUFDQTtBQUNBOztJQUNLLENBdENELE1BdUNLLElBQUkxRCxRQUFRLENBQUNpRixRQUFELEVBQVduQixRQUFYLENBQVosRUFBa0M7TUFDckMySCxjQUFjLEdBQUcsRUFBakI7TUFDQUMsZ0JBQWdCLEdBQUcsRUFBbkI7TUFDQUMsV0FBVyxHQUFHQyxXQUFXLEdBQUcsS0FBNUI7SUFDRDtFQUNGOztFQUNELElBQUk3SCxRQUFKLEVBQWM7SUFDWjtBQUNKO0FBQ0E7QUFDQTtBQUNBO0lBQ0ksSUFBSXJFLFNBQVMsQ0FBQ3VGLFFBQUQsRUFBV2xCLFFBQVgsQ0FBYixFQUFtQztNQUNqQztBQUNOO0FBQ0E7QUFDQTtBQUNBO01BQ00sSUFBSUEsUUFBUSxDQUFDM0MsSUFBVCxLQUFrQlYsU0FBdEIsRUFBaUM7UUFDL0IrSyxjQUFjLEdBQUdBLGNBQWMsQ0FBQzVJLE1BQWYsQ0FBdUJ6QixJQUFELElBQVU7VUFDL0MsTUFBTTBLLGFBQWEsR0FBRzdHLFFBQVEsQ0FBQ3RCLElBQVQsS0FBa0IsSUFBbEIsR0FBeUIsQ0FBQ3ZDLElBQUksR0FBRyxFQUFSLElBQWMsRUFBdkMsR0FBNENBLElBQWxFO1VBQ0EsT0FBTyxDQUFDZ0YsU0FBUyxHQUFHaEYsSUFBSCxHQUFVMEssYUFBcEIsS0FBc0MvSCxRQUFRLENBQUMzQyxJQUF0RDtRQUNELENBSGdCLENBQWpCO1FBSUF3SyxXQUFXLEdBQUc3SCxRQUFRLENBQUMzQyxJQUFULElBQWlCLEVBQS9CO01BQ0Q7O01BQ0QsSUFBSTJDLFFBQVEsQ0FBQ0wsTUFBVCxLQUFvQmhELFNBQXBCLElBQWlDdUUsUUFBUSxDQUFDN0QsSUFBVCxLQUFrQjJDLFFBQVEsQ0FBQzNDLElBQWhFLEVBQXNFO1FBQ3BFO1FBQ0E7UUFDQTtRQUNBO1FBQ0FzSyxnQkFBZ0IsR0FBR0EsZ0JBQWdCLENBQUM3SSxNQUFqQixDQUF5QmEsTUFBRCxJQUFZQSxNQUFNLElBQUlLLFFBQVEsQ0FBQ0wsTUFBdkQsQ0FBbkI7TUFDRDtNQUNEO0FBQ047QUFDQTtBQUNBOztJQUNLLENBeEJELE1BeUJLLElBQUl6RCxPQUFPLENBQUNnRixRQUFELEVBQVdsQixRQUFYLENBQVgsRUFBaUM7TUFDcEMwSCxjQUFjLEdBQUcsRUFBakI7TUFDQUMsZ0JBQWdCLEdBQUcsRUFBbkI7TUFDQUMsV0FBVyxHQUFHQyxXQUFXLEdBQUcsS0FBNUI7SUFDRDtFQUNGOztFQUNELE9BQU87SUFDTEksS0FBSyxFQUFFUCxjQURGO0lBRUxuQixPQUFPLEVBQUVvQixnQkFGSjtJQUdMTyxFQUFFLEVBQUVOLFdBSEM7SUFJTE8sRUFBRSxFQUFFTjtFQUpDLENBQVA7QUFNRCxDQTFHRDtBQTJHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsTUFBTU8sY0FBYyxHQUFJbEgsUUFBRCxJQUFjO0VBQ25DLE9BQU8sQ0FDTFcsZ0JBQWdCLENBQUNYLFFBQUQsQ0FEWCxFQUVMO0lBQUVwRixLQUFLLEVBQUVvRixRQUFRLENBQUNwRixLQUFsQjtJQUF5QkUsSUFBSSxFQUFFa0YsUUFBUSxDQUFDbEYsSUFBeEM7SUFBOENELEdBQUcsRUFBRW1GLFFBQVEsQ0FBQ25GO0VBQTVELENBRkssRUFHTGdHLFlBQVksQ0FBQ2IsUUFBRCxDQUhQLENBQVA7QUFLRCxDQU5EOztBQU9BLE1BQU1tSCxrQkFBa0IsR0FBRyxDQUFDckwsTUFBRCxFQUFTa0UsUUFBVCxFQUFtQm5CLFFBQW5CLEVBQTZCQyxRQUE3QixFQUF1Q2dELFdBQXZDLEVBQW9EL0UsYUFBYSxHQUFHO0VBQzdGbkMsS0FBSyxFQUFFO0FBRHNGLENBQXBFLEtBRXJCO0VBQ0osTUFBTTtJQUFFRTtFQUFGLElBQVdrRixRQUFqQjtFQUNBLE1BQU1vSCxNQUFNLEdBQUcsRUFBZjs7RUFDQSxJQUFJdEYsV0FBVyxLQUFLckcsU0FBcEIsRUFBK0I7SUFDN0IsSUFBSTRMLGVBQWUsR0FBR3ZGLFdBQXRCOztJQUNBLElBQUksQ0FBQ2hELFFBQVEsS0FBSyxJQUFiLElBQXFCQSxRQUFRLEtBQUssS0FBSyxDQUF2QyxHQUEyQyxLQUFLLENBQWhELEdBQW9EQSxRQUFRLENBQUNsRSxLQUE5RCxNQUF5RWEsU0FBN0UsRUFBd0Y7TUFDdEY0TCxlQUFlLEdBQUdBLGVBQWUsQ0FBQ3pKLE1BQWhCLENBQXdCaEQsS0FBRCxJQUFXQSxLQUFLLElBQUlrRSxRQUFRLENBQUNsRSxLQUFwRCxDQUFsQjtJQUNEOztJQUNELElBQUksQ0FBQ2lFLFFBQVEsS0FBSyxJQUFiLElBQXFCQSxRQUFRLEtBQUssS0FBSyxDQUF2QyxHQUEyQyxLQUFLLENBQWhELEdBQW9EQSxRQUFRLENBQUNqRSxLQUE5RCxNQUF5RWEsU0FBN0UsRUFBd0Y7TUFDdEY0TCxlQUFlLEdBQUdBLGVBQWUsQ0FBQ3pKLE1BQWhCLENBQXdCaEQsS0FBRCxJQUFXQSxLQUFLLElBQUlpRSxRQUFRLENBQUNqRSxLQUFwRCxDQUFsQjtJQUNEOztJQUNEeU0sZUFBZSxDQUFDQyxPQUFoQixDQUF5QkMsY0FBRCxJQUFvQjtNQUMxQyxNQUFNakwsSUFBSSxHQUFHLElBQUlDLElBQUosQ0FBVSxHQUFFZ0wsY0FBZSxNQUFLek0sSUFBSyxXQUFyQyxDQUFiO01BQ0EsTUFBTTBNLFdBQVcsR0FBRyxJQUFJdkwsSUFBSSxDQUFDQyxjQUFULENBQXdCSixNQUF4QixFQUFnQzZGLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjRCxNQUFNLENBQUNDLE1BQVAsQ0FBYyxFQUFkLEVBQWtCN0UsYUFBbEIsQ0FBZCxFQUFnRDtRQUFFK0YsUUFBUSxFQUFFO01BQVosQ0FBaEQsQ0FBaEMsRUFBc0dDLE1BQXRHLENBQTZHekcsSUFBN0csQ0FBcEI7TUFDQThLLE1BQU0sQ0FBQ2xCLElBQVAsQ0FBWTtRQUFFdUIsSUFBSSxFQUFFRCxXQUFSO1FBQXFCdE0sS0FBSyxFQUFFcU07TUFBNUIsQ0FBWjtJQUNELENBSkQ7RUFLRCxDQWJELE1BY0s7SUFDSCxNQUFNRyxRQUFRLEdBQUc1SSxRQUFRLElBQUlBLFFBQVEsQ0FBQ2hFLElBQVQsS0FBa0JBLElBQTlCLEdBQXFDZ0UsUUFBUSxDQUFDbEUsS0FBOUMsR0FBc0QsRUFBdkU7SUFDQSxNQUFNK00sUUFBUSxHQUFHOUksUUFBUSxJQUFJQSxRQUFRLENBQUMvRCxJQUFULEtBQWtCQSxJQUE5QixHQUFxQytELFFBQVEsQ0FBQ2pFLEtBQTlDLEdBQXNELENBQXZFOztJQUNBLEtBQUssSUFBSTJELENBQUMsR0FBR29KLFFBQWIsRUFBdUJwSixDQUFDLElBQUltSixRQUE1QixFQUFzQ25KLENBQUMsRUFBdkMsRUFBMkM7TUFDekM7QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO01BQ00sTUFBTWpDLElBQUksR0FBRyxJQUFJQyxJQUFKLENBQVUsR0FBRWdDLENBQUUsTUFBS3pELElBQUssV0FBeEIsQ0FBYjtNQUNBLE1BQU0wTSxXQUFXLEdBQUcsSUFBSXZMLElBQUksQ0FBQ0MsY0FBVCxDQUF3QkosTUFBeEIsRUFBZ0M2RixNQUFNLENBQUNDLE1BQVAsQ0FBY0QsTUFBTSxDQUFDQyxNQUFQLENBQWMsRUFBZCxFQUFrQjdFLGFBQWxCLENBQWQsRUFBZ0Q7UUFBRStGLFFBQVEsRUFBRTtNQUFaLENBQWhELENBQWhDLEVBQXNHQyxNQUF0RyxDQUE2R3pHLElBQTdHLENBQXBCO01BQ0E4SyxNQUFNLENBQUNsQixJQUFQLENBQVk7UUFBRXVCLElBQUksRUFBRUQsV0FBUjtRQUFxQnRNLEtBQUssRUFBRXFEO01BQTVCLENBQVo7SUFDRDtFQUNGOztFQUNELE9BQU82SSxNQUFQO0FBQ0QsQ0FyREQ7QUFzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsTUFBTVEsZ0JBQWdCLEdBQUcsQ0FBQzlMLE1BQUQsRUFBU2tFLFFBQVQsRUFBbUJuQixRQUFuQixFQUE2QkMsUUFBN0IsRUFBdUNpRCxTQUF2QyxFQUFrRGhGLGFBQWEsR0FBRztFQUN6RmxDLEdBQUcsRUFBRTtBQURvRixDQUFsRSxLQUVuQjtFQUNKLE1BQU07SUFBRUQsS0FBRjtJQUFTRTtFQUFULElBQWtCa0YsUUFBeEI7RUFDQSxNQUFNc0csSUFBSSxHQUFHLEVBQWI7RUFDQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0VBQ0UsTUFBTTFGLGNBQWMsR0FBRy9ELGlCQUFpQixDQUFDakMsS0FBRCxFQUFRRSxJQUFSLENBQXhDO0VBQ0EsTUFBTStNLE1BQU0sR0FBRyxDQUFDL0ksUUFBUSxLQUFLLElBQWIsSUFBcUJBLFFBQVEsS0FBSyxLQUFLLENBQXZDLEdBQTJDLEtBQUssQ0FBaEQsR0FBb0RBLFFBQVEsQ0FBQ2pFLEdBQTlELE1BQXVFLElBQXZFLElBQStFLENBQUNpRSxRQUFRLEtBQUssSUFBYixJQUFxQkEsUUFBUSxLQUFLLEtBQUssQ0FBdkMsR0FBMkMsS0FBSyxDQUFoRCxHQUFvREEsUUFBUSxDQUFDakUsR0FBOUQsTUFBdUVZLFNBQXRKLElBQW1LcUQsUUFBUSxDQUFDaEUsSUFBVCxLQUFrQkEsSUFBckwsSUFBNkxnRSxRQUFRLENBQUNsRSxLQUFULEtBQW1CQSxLQUFoTixHQUNYa0UsUUFBUSxDQUFDakUsR0FERSxHQUVYK0YsY0FGSjtFQUdBLE1BQU1rSCxNQUFNLEdBQUcsQ0FBQ2pKLFFBQVEsS0FBSyxJQUFiLElBQXFCQSxRQUFRLEtBQUssS0FBSyxDQUF2QyxHQUEyQyxLQUFLLENBQWhELEdBQW9EQSxRQUFRLENBQUNoRSxHQUE5RCxNQUF1RSxJQUF2RSxJQUErRSxDQUFDZ0UsUUFBUSxLQUFLLElBQWIsSUFBcUJBLFFBQVEsS0FBSyxLQUFLLENBQXZDLEdBQTJDLEtBQUssQ0FBaEQsR0FBb0RBLFFBQVEsQ0FBQ2hFLEdBQTlELE1BQXVFWSxTQUF0SixJQUFtS29ELFFBQVEsQ0FBQy9ELElBQVQsS0FBa0JBLElBQXJMLElBQTZMK0QsUUFBUSxDQUFDakUsS0FBVCxLQUFtQkEsS0FBaE4sR0FDWGlFLFFBQVEsQ0FBQ2hFLEdBREUsR0FFWCxDQUZKOztFQUdBLElBQUlrSCxTQUFTLEtBQUt0RyxTQUFsQixFQUE2QjtJQUMzQixJQUFJc00sYUFBYSxHQUFHaEcsU0FBcEI7SUFDQWdHLGFBQWEsR0FBR0EsYUFBYSxDQUFDbkssTUFBZCxDQUFzQi9DLEdBQUQsSUFBU0EsR0FBRyxJQUFJaU4sTUFBUCxJQUFpQmpOLEdBQUcsSUFBSWdOLE1BQXRELENBQWhCO0lBQ0FFLGFBQWEsQ0FBQ1QsT0FBZCxDQUF1QlUsWUFBRCxJQUFrQjtNQUN0QyxNQUFNMUwsSUFBSSxHQUFHLElBQUlDLElBQUosQ0FBVSxHQUFFM0IsS0FBTSxJQUFHb04sWUFBYSxJQUFHbE4sSUFBSyxXQUExQyxDQUFiO01BQ0EsTUFBTW1OLFNBQVMsR0FBRyxJQUFJaE0sSUFBSSxDQUFDQyxjQUFULENBQXdCSixNQUF4QixFQUFnQzZGLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjRCxNQUFNLENBQUNDLE1BQVAsQ0FBYyxFQUFkLEVBQWtCN0UsYUFBbEIsQ0FBZCxFQUFnRDtRQUFFK0YsUUFBUSxFQUFFO01BQVosQ0FBaEQsQ0FBaEMsRUFBc0dDLE1BQXRHLENBQTZHekcsSUFBN0csQ0FBbEI7TUFDQWdLLElBQUksQ0FBQ0osSUFBTCxDQUFVO1FBQUV1QixJQUFJLEVBQUVRLFNBQVI7UUFBbUIvTSxLQUFLLEVBQUU4TTtNQUExQixDQUFWO0lBQ0QsQ0FKRDtFQUtELENBUkQsTUFTSztJQUNILEtBQUssSUFBSXpKLENBQUMsR0FBR3VKLE1BQWIsRUFBcUJ2SixDQUFDLElBQUlzSixNQUExQixFQUFrQ3RKLENBQUMsRUFBbkMsRUFBdUM7TUFDckMsTUFBTWpDLElBQUksR0FBRyxJQUFJQyxJQUFKLENBQVUsR0FBRTNCLEtBQU0sSUFBRzJELENBQUUsSUFBR3pELElBQUssV0FBL0IsQ0FBYjtNQUNBLE1BQU1tTixTQUFTLEdBQUcsSUFBSWhNLElBQUksQ0FBQ0MsY0FBVCxDQUF3QkosTUFBeEIsRUFBZ0M2RixNQUFNLENBQUNDLE1BQVAsQ0FBY0QsTUFBTSxDQUFDQyxNQUFQLENBQWMsRUFBZCxFQUFrQjdFLGFBQWxCLENBQWQsRUFBZ0Q7UUFBRStGLFFBQVEsRUFBRTtNQUFaLENBQWhELENBQWhDLEVBQXNHQyxNQUF0RyxDQUE2R3pHLElBQTdHLENBQWxCO01BQ0FnSyxJQUFJLENBQUNKLElBQUwsQ0FBVTtRQUFFdUIsSUFBSSxFQUFFUSxTQUFSO1FBQW1CL00sS0FBSyxFQUFFcUQ7TUFBMUIsQ0FBVjtJQUNEO0VBQ0Y7O0VBQ0QsT0FBTytILElBQVA7QUFDRCxDQW5DRDs7QUFvQ0EsTUFBTTRCLGlCQUFpQixHQUFHLENBQUNwTSxNQUFELEVBQVNrRSxRQUFULEVBQW1CbkIsUUFBbkIsRUFBNkJDLFFBQTdCLEVBQXVDa0QsVUFBdkMsS0FBc0Q7RUFDOUUsSUFBSW1HLEVBQUosRUFBUUMsRUFBUjs7RUFDQSxJQUFJQyxjQUFjLEdBQUcsRUFBckI7O0VBQ0EsSUFBSXJHLFVBQVUsS0FBS3ZHLFNBQW5CLEVBQThCO0lBQzVCNE0sY0FBYyxHQUFHckcsVUFBakI7O0lBQ0EsSUFBSSxDQUFDbEQsUUFBUSxLQUFLLElBQWIsSUFBcUJBLFFBQVEsS0FBSyxLQUFLLENBQXZDLEdBQTJDLEtBQUssQ0FBaEQsR0FBb0RBLFFBQVEsQ0FBQ2hFLElBQTlELE1BQXdFVyxTQUE1RSxFQUF1RjtNQUNyRjRNLGNBQWMsR0FBR0EsY0FBYyxDQUFDekssTUFBZixDQUF1QjlDLElBQUQsSUFBVUEsSUFBSSxJQUFJZ0UsUUFBUSxDQUFDaEUsSUFBakQsQ0FBakI7SUFDRDs7SUFDRCxJQUFJLENBQUMrRCxRQUFRLEtBQUssSUFBYixJQUFxQkEsUUFBUSxLQUFLLEtBQUssQ0FBdkMsR0FBMkMsS0FBSyxDQUFoRCxHQUFvREEsUUFBUSxDQUFDL0QsSUFBOUQsTUFBd0VXLFNBQTVFLEVBQXVGO01BQ3JGNE0sY0FBYyxHQUFHQSxjQUFjLENBQUN6SyxNQUFmLENBQXVCOUMsSUFBRCxJQUFVQSxJQUFJLElBQUkrRCxRQUFRLENBQUMvRCxJQUFqRCxDQUFqQjtJQUNEO0VBQ0YsQ0FSRCxNQVNLO0lBQ0gsTUFBTTtNQUFFQTtJQUFGLElBQVdrRixRQUFqQjtJQUNBLE1BQU1zSSxPQUFPLEdBQUcsQ0FBQ0gsRUFBRSxHQUFHckosUUFBUSxLQUFLLElBQWIsSUFBcUJBLFFBQVEsS0FBSyxLQUFLLENBQXZDLEdBQTJDLEtBQUssQ0FBaEQsR0FBb0RBLFFBQVEsQ0FBQ2hFLElBQW5FLE1BQTZFLElBQTdFLElBQXFGcU4sRUFBRSxLQUFLLEtBQUssQ0FBakcsR0FBcUdBLEVBQXJHLEdBQTBHck4sSUFBMUg7SUFDQSxNQUFNeU4sT0FBTyxHQUFHLENBQUNILEVBQUUsR0FBR3ZKLFFBQVEsS0FBSyxJQUFiLElBQXFCQSxRQUFRLEtBQUssS0FBSyxDQUF2QyxHQUEyQyxLQUFLLENBQWhELEdBQW9EQSxRQUFRLENBQUMvRCxJQUFuRSxNQUE2RSxJQUE3RSxJQUFxRnNOLEVBQUUsS0FBSyxLQUFLLENBQWpHLEdBQXFHQSxFQUFyRyxHQUEwR3ROLElBQUksR0FBRyxHQUFqSTs7SUFDQSxLQUFLLElBQUl5RCxDQUFDLEdBQUcrSixPQUFiLEVBQXNCL0osQ0FBQyxJQUFJZ0ssT0FBM0IsRUFBb0NoSyxDQUFDLEVBQXJDLEVBQXlDO01BQ3ZDOEosY0FBYyxDQUFDbkMsSUFBZixDQUFvQjNILENBQXBCO0lBQ0Q7RUFDRjs7RUFDRCxPQUFPOEosY0FBYyxDQUFDNUssR0FBZixDQUFvQjNDLElBQUQsS0FBVztJQUNuQzJNLElBQUksRUFBRTFELE9BQU8sQ0FBQ2pJLE1BQUQsRUFBUztNQUFFaEIsSUFBRjtNQUFRRixLQUFLLEVBQUVvRixRQUFRLENBQUNwRixLQUF4QjtNQUErQkMsR0FBRyxFQUFFbUYsUUFBUSxDQUFDbkY7SUFBN0MsQ0FBVCxDQURzQjtJQUVuQ0ssS0FBSyxFQUFFSjtFQUY0QixDQUFYLENBQW5CLENBQVA7QUFJRCxDQXhCRDtBQXlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxNQUFNME4sbUJBQW1CLEdBQUcsQ0FBQ25ILFlBQUQsRUFBZXZDLFFBQWYsS0FBNEI7RUFDdEQsSUFBSXVDLFlBQVksQ0FBQ3pHLEtBQWIsS0FBdUJrRSxRQUFRLENBQUNsRSxLQUFoQyxJQUF5Q3lHLFlBQVksQ0FBQ3ZHLElBQWIsS0FBc0JnRSxRQUFRLENBQUNoRSxJQUE1RSxFQUFrRjtJQUNoRixPQUFPLENBQUN1RyxZQUFELENBQVA7RUFDRDs7RUFDRCxPQUFPLENBQUNBLFlBQUQsRUFBZSxHQUFHbUgsbUJBQW1CLENBQUMzSCxZQUFZLENBQUNRLFlBQUQsQ0FBYixFQUE2QnZDLFFBQTdCLENBQXJDLENBQVA7QUFDRCxDQUxEO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsTUFBTTJKLHlCQUF5QixHQUFHLENBQUMzTSxNQUFELEVBQVNtRCxVQUFULEVBQXFCSixRQUFyQixFQUErQkMsUUFBL0IsRUFBeUNpRCxTQUF6QyxFQUFvREQsV0FBcEQsS0FBb0U7RUFDcEcsSUFBSTRHLEtBQUssR0FBRyxFQUFaO0VBQ0EsSUFBSWxNLEtBQUssR0FBRyxFQUFaO0VBQ0E7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztFQUNFLElBQUk0SyxNQUFNLEdBQUdvQixtQkFBbUIsQ0FBQzNKLFFBQUQsRUFBV0MsUUFBWCxDQUFoQztFQUNBO0FBQ0Y7QUFDQTs7RUFDRSxJQUFJZ0QsV0FBSixFQUFpQjtJQUNmc0YsTUFBTSxHQUFHQSxNQUFNLENBQUN4SixNQUFQLENBQWMsQ0FBQztNQUFFaEQ7SUFBRixDQUFELEtBQWVrSCxXQUFXLENBQUM4RSxRQUFaLENBQXFCaE0sS0FBckIsQ0FBN0IsQ0FBVDtFQUNEO0VBQ0Q7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7RUFDRXdNLE1BQU0sQ0FBQ0UsT0FBUCxDQUFnQnFCLFdBQUQsSUFBaUI7SUFDOUIsTUFBTUMsY0FBYyxHQUFHO01BQUVoTyxLQUFLLEVBQUUrTixXQUFXLENBQUMvTixLQUFyQjtNQUE0QkMsR0FBRyxFQUFFLElBQWpDO01BQXVDQyxJQUFJLEVBQUU2TixXQUFXLENBQUM3TjtJQUF6RCxDQUF2QjtJQUNBLE1BQU0rTixTQUFTLEdBQUdqQixnQkFBZ0IsQ0FBQzlMLE1BQUQsRUFBUzhNLGNBQVQsRUFBeUIvSixRQUF6QixFQUFtQ0MsUUFBbkMsRUFBNkNpRCxTQUE3QyxFQUF3RDtNQUN4Rm5ILEtBQUssRUFBRSxPQURpRjtNQUV4RkMsR0FBRyxFQUFFLFNBRm1GO01BR3hGMEksT0FBTyxFQUFFO0lBSCtFLENBQXhELENBQWxDO0lBS0EsTUFBTTNFLFNBQVMsR0FBRyxFQUFsQjtJQUNBLE1BQU1rSyxlQUFlLEdBQUcsRUFBeEI7SUFDQUQsU0FBUyxDQUFDdkIsT0FBVixDQUFtQnlCLFNBQUQsSUFBZTtNQUMvQixNQUFNQyxPQUFPLEdBQUd2TyxTQUFTLENBQUNrSCxNQUFNLENBQUNDLE1BQVAsQ0FBY0QsTUFBTSxDQUFDQyxNQUFQLENBQWMsRUFBZCxFQUFrQmdILGNBQWxCLENBQWQsRUFBaUQ7UUFBRS9OLEdBQUcsRUFBRWtPLFNBQVMsQ0FBQzdOO01BQWpCLENBQWpELENBQUQsRUFBNkUrRCxVQUE3RSxDQUF6QjtNQUNBO0FBQ047QUFDQTtBQUNBOztNQUNNNkosZUFBZSxDQUFDNUMsSUFBaEIsQ0FBcUI7UUFDbkJ1QixJQUFJLEVBQUV1QixPQUFPLEdBQUc3RSxhQUFhLENBQUNySSxNQUFELENBQWhCLEdBQTJCaU4sU0FBUyxDQUFDdEIsSUFEL0I7UUFFbkJ2TSxLQUFLLEVBQUcsR0FBRTBOLGNBQWMsQ0FBQzlOLElBQUssSUFBRzhOLGNBQWMsQ0FBQ2hPLEtBQU0sSUFBR21PLFNBQVMsQ0FBQzdOLEtBQU07TUFGdEQsQ0FBckI7TUFJQTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7TUFDTTBELFNBQVMsQ0FBQ3NILElBQVYsQ0FBZTtRQUNidEwsS0FBSyxFQUFFZ08sY0FBYyxDQUFDaE8sS0FEVDtRQUViRSxJQUFJLEVBQUU4TixjQUFjLENBQUM5TixJQUZSO1FBR2JELEdBQUcsRUFBRWtPLFNBQVMsQ0FBQzdOO01BSEYsQ0FBZjtJQUtELENBekJEO0lBMEJBc0IsS0FBSyxHQUFHLENBQUMsR0FBR0EsS0FBSixFQUFXLEdBQUdvQyxTQUFkLENBQVI7SUFDQThKLEtBQUssR0FBRyxDQUFDLEdBQUdBLEtBQUosRUFBVyxHQUFHSSxlQUFkLENBQVI7RUFDRCxDQXJDRDtFQXNDQSxPQUFPO0lBQ0x0TSxLQURLO0lBRUxrTTtFQUZLLENBQVA7QUFJRCxDQWhFRDs7QUFpRUEsTUFBTU8sa0JBQWtCLEdBQUcsQ0FBQ25OLE1BQUQsRUFBU2tFLFFBQVQsRUFBbUJqRSxTQUFuQixFQUE4QjhDLFFBQTlCLEVBQXdDQyxRQUF4QyxFQUFrRG9LLGlCQUFsRCxFQUFxRUMsbUJBQXJFLEtBQTZGO0VBQ3RILE1BQU1oSSxTQUFTLEdBQUd0RixRQUFRLENBQUNDLE1BQUQsRUFBU0MsU0FBVCxDQUExQjtFQUNBLE1BQU07SUFBRWdMLEtBQUY7SUFBUzFCLE9BQVQ7SUFBa0IyQixFQUFsQjtJQUFzQkM7RUFBdEIsSUFBNkJWLFlBQVksQ0FBQ3ZHLFFBQUQsRUFBV21CLFNBQVMsR0FBRyxLQUFILEdBQVcsS0FBL0IsRUFBc0N0QyxRQUF0QyxFQUFnREMsUUFBaEQsRUFBMERvSyxpQkFBMUQsRUFBNkVDLG1CQUE3RSxDQUEvQztFQUNBLE1BQU1DLFVBQVUsR0FBR3JDLEtBQUssQ0FBQ3RKLEdBQU4sQ0FBV3RCLElBQUQsSUFBVTtJQUNyQyxPQUFPO01BQ0xzTCxJQUFJLEVBQUV0RSxnQkFBZ0IsQ0FBQ2hILElBQUQsRUFBT2dGLFNBQVAsQ0FEakI7TUFFTGpHLEtBQUssRUFBRWdHLG9CQUFvQixDQUFDL0UsSUFBRCxFQUFPZ0YsU0FBUCxFQUFrQm5CLFFBQVEsQ0FBQ3RCLElBQTNCO0lBRnRCLENBQVA7RUFJRCxDQUxrQixDQUFuQjtFQU1BLE1BQU0ySyxZQUFZLEdBQUdoRSxPQUFPLENBQUM1SCxHQUFSLENBQWFnQixNQUFELElBQVk7SUFDM0MsT0FBTztNQUNMZ0osSUFBSSxFQUFFekUsY0FBYyxDQUFDdkUsTUFBRCxDQURmO01BRUx2RCxLQUFLLEVBQUV1RDtJQUZGLENBQVA7RUFJRCxDQUxvQixDQUFyQjtFQU1BLE1BQU02SyxjQUFjLEdBQUcsRUFBdkI7O0VBQ0EsSUFBSXRDLEVBQUUsSUFBSSxDQUFDN0YsU0FBWCxFQUFzQjtJQUNwQm1JLGNBQWMsQ0FBQ3BELElBQWYsQ0FBb0I7TUFDbEJ1QixJQUFJLEVBQUUzQyxxQkFBcUIsQ0FBQ2hKLE1BQUQsRUFBUyxJQUFULENBRFQ7TUFFbEJaLEtBQUssRUFBRTtJQUZXLENBQXBCO0VBSUQ7O0VBQ0QsSUFBSStMLEVBQUUsSUFBSSxDQUFDOUYsU0FBWCxFQUFzQjtJQUNwQm1JLGNBQWMsQ0FBQ3BELElBQWYsQ0FBb0I7TUFDbEJ1QixJQUFJLEVBQUUzQyxxQkFBcUIsQ0FBQ2hKLE1BQUQsRUFBUyxJQUFULENBRFQ7TUFFbEJaLEtBQUssRUFBRTtJQUZXLENBQXBCO0VBSUQ7O0VBQ0QsT0FBTztJQUNMcU8sV0FBVyxFQUFFRixZQURSO0lBRUxHLFNBQVMsRUFBRUosVUFGTjtJQUdMSyxhQUFhLEVBQUVIO0VBSFYsQ0FBUDtBQUtELENBakNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuNENBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOU8sZUFBZSxHQUFHLENBQUM4UixPQUFELEVBQVUsR0FBR0MsTUFBYixLQUF3QjtFQUM5QyxPQUFPQyxPQUFPLENBQUNDLElBQVIsQ0FBYyxvQkFBbUJILE9BQVEsRUFBekMsRUFBNEMsR0FBR0MsTUFBL0MsQ0FBUDtBQUNELENBRkQ7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsTUFBTUcsYUFBYSxHQUFHLENBQUNKLE9BQUQsRUFBVSxHQUFHQyxNQUFiLEtBQXdCO0VBQzVDLE9BQU9DLE9BQU8sQ0FBQ0csS0FBUixDQUFlLGtCQUFpQkwsT0FBUSxFQUF4QyxFQUEyQyxHQUFHQyxNQUE5QyxDQUFQO0FBQ0QsQ0FGRDtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxNQUFNSyx5QkFBeUIsR0FBRyxDQUFDN08sRUFBRCxFQUFLLEdBQUc4TyxlQUFSLEtBQTRCO0VBQzVELE9BQU9MLE9BQU8sQ0FBQ0csS0FBUixDQUFlLElBQUc1TyxFQUFFLENBQUMrTyxPQUFILENBQVdDLFdBQVgsRUFBeUIseUJBQXdCRixlQUFlLENBQUMzSCxJQUFoQixDQUFxQixNQUFyQixDQUE2QixHQUFoRyxDQUFQO0FBQ0QsQ0FGRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOEgsV0FBVyxHQUFHLENBQUNDLFFBQUQsRUFBV2xQLEVBQVgsS0FBa0I7RUFDcEMsT0FBT0EsRUFBRSxDQUFDbVAsT0FBSCxDQUFXRCxRQUFYLE1BQXlCLElBQWhDO0FBQ0QsQ0FGRDtBQUdBO0FBQ0E7QUFDQTs7O0FBQ0EsTUFBTUUsa0JBQWtCLEdBQUcsQ0FBQ0MsS0FBRCxFQUFRQyxXQUFSLEtBQXdCO0VBQ2pELE9BQU8sT0FBT0QsS0FBUCxLQUFpQixRQUFqQixJQUE2QkEsS0FBSyxDQUFDNUssTUFBTixHQUFlLENBQTVDLEdBQ0hiLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjO0lBQUUsYUFBYSxJQUFmO0lBQXFCLENBQUUsYUFBWXdMLEtBQU0sRUFBcEIsR0FBd0I7RUFBN0MsQ0FBZCxFQUFtRUMsV0FBbkUsQ0FERyxHQUMrRUEsV0FEdEY7QUFFRCxDQUhEOztBQUlBLE1BQU1DLFlBQVksR0FBSUMsT0FBRCxJQUFhO0VBQ2hDLElBQUlBLE9BQU8sS0FBSzlSLFNBQWhCLEVBQTJCO0lBQ3pCLE1BQU0rUixLQUFLLEdBQUdsUyxLQUFLLENBQUNDLE9BQU4sQ0FBY2dTLE9BQWQsSUFBeUJBLE9BQXpCLEdBQW1DQSxPQUFPLENBQUNoUSxLQUFSLENBQWMsR0FBZCxDQUFqRDtJQUNBLE9BQU9pUSxLQUFLLENBQ1Q1UCxNQURJLENBQ0lvTixDQUFELElBQU9BLENBQUMsSUFBSSxJQURmLEVBRUp2TixHQUZJLENBRUN1TixDQUFELElBQU9BLENBQUMsQ0FBQ3lDLElBQUYsRUFGUCxFQUdKN1AsTUFISSxDQUdJb04sQ0FBRCxJQUFPQSxDQUFDLEtBQUssRUFIaEIsQ0FBUDtFQUlEOztFQUNELE9BQU8sRUFBUDtBQUNELENBVEQ7O0FBVUEsTUFBTTBDLFdBQVcsR0FBSUgsT0FBRCxJQUFhO0VBQy9CLE1BQU05UCxHQUFHLEdBQUcsRUFBWjtFQUNBNlAsWUFBWSxDQUFDQyxPQUFELENBQVosQ0FBc0JqRyxPQUF0QixDQUErQjBELENBQUQsSUFBUXZOLEdBQUcsQ0FBQ3VOLENBQUQsQ0FBSCxHQUFTLElBQS9DO0VBQ0EsT0FBT3ZOLEdBQVA7QUFDRCxDQUpEOztBQUtBLE1BQU1rUSxNQUFNLEdBQUcsc0JBQWY7O0FBQ0EsTUFBTUMsT0FBTztFQUFBLG9KQUFHLFdBQU9DLEdBQVAsRUFBWUMsRUFBWixFQUFnQkMsU0FBaEIsRUFBMkJDLFNBQTNCLEVBQXlDO0lBQ3ZELElBQUlILEdBQUcsSUFBSSxJQUFQLElBQWVBLEdBQUcsQ0FBQyxDQUFELENBQUgsS0FBVyxHQUExQixJQUFpQyxDQUFDRixNQUFNLENBQUNNLElBQVAsQ0FBWUosR0FBWixDQUF0QyxFQUF3RDtNQUN0RCxNQUFNSyxNQUFNLEdBQUdDLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixZQUF2QixDQUFmOztNQUNBLElBQUlGLE1BQUosRUFBWTtRQUNWLElBQUlKLEVBQUUsSUFBSSxJQUFWLEVBQWdCO1VBQ2RBLEVBQUUsQ0FBQ08sY0FBSDtRQUNEOztRQUNELE9BQU9ILE1BQU0sQ0FBQ2hJLElBQVAsQ0FBWTJILEdBQVosRUFBaUJFLFNBQWpCLEVBQTRCQyxTQUE1QixDQUFQO01BQ0Q7SUFDRjs7SUFDRCxPQUFPLEtBQVA7RUFDRCxDQVhZOztFQUFBLGdCQUFQSixPQUFPO0lBQUE7RUFBQTtBQUFBLEdBQWIiLCJzb3VyY2VzIjpbIi4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2Rpc3QvZXNtL2RhdGEtY2I3MjQ0OGMuanMiLCIuL25vZGVfbW9kdWxlcy9AaW9uaWMvY29yZS9kaXN0L2VzbS9pbmRleC1jNGIxMTY3Ni5qcyIsIi4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2Rpc3QvZXNtL3RoZW1lLTc2NzAzNDFjLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogKEMpIElvbmljIGh0dHA6Ly9pb25pY2ZyYW1ld29yay5jb20gLSBNSVQgTGljZW5zZVxuICovXG5pbXBvcnQgeyBwIGFzIHByaW50SW9uV2FybmluZyB9IGZyb20gJy4vaW5kZXgtYzRiMTE2NzYuanMnO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc2VsZWN0ZWQgZGF5IGlzIGVxdWFsIHRvIHRoZSByZWZlcmVuY2UgZGF5XG4gKi9cbmNvbnN0IGlzU2FtZURheSA9IChiYXNlUGFydHMsIGNvbXBhcmVQYXJ0cykgPT4ge1xuICByZXR1cm4gKGJhc2VQYXJ0cy5tb250aCA9PT0gY29tcGFyZVBhcnRzLm1vbnRoICYmIGJhc2VQYXJ0cy5kYXkgPT09IGNvbXBhcmVQYXJ0cy5kYXkgJiYgYmFzZVBhcnRzLnllYXIgPT09IGNvbXBhcmVQYXJ0cy55ZWFyKTtcbn07XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpcyB0aGUgc2VsZWN0ZWQgZGF5IGlzIGJlZm9yZSB0aGUgcmVmZXJlbmNlIGRheS5cbiAqL1xuY29uc3QgaXNCZWZvcmUgPSAoYmFzZVBhcnRzLCBjb21wYXJlUGFydHMpID0+IHtcbiAgcmV0dXJuICEhKGJhc2VQYXJ0cy55ZWFyIDwgY29tcGFyZVBhcnRzLnllYXIgfHxcbiAgICAoYmFzZVBhcnRzLnllYXIgPT09IGNvbXBhcmVQYXJ0cy55ZWFyICYmIGJhc2VQYXJ0cy5tb250aCA8IGNvbXBhcmVQYXJ0cy5tb250aCkgfHxcbiAgICAoYmFzZVBhcnRzLnllYXIgPT09IGNvbXBhcmVQYXJ0cy55ZWFyICYmXG4gICAgICBiYXNlUGFydHMubW9udGggPT09IGNvbXBhcmVQYXJ0cy5tb250aCAmJlxuICAgICAgYmFzZVBhcnRzLmRheSAhPT0gbnVsbCAmJlxuICAgICAgYmFzZVBhcnRzLmRheSA8IGNvbXBhcmVQYXJ0cy5kYXkpKTtcbn07XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpcyB0aGUgc2VsZWN0ZWQgZGF5IGlzIGFmdGVyIHRoZSByZWZlcmVuY2UgZGF5LlxuICovXG5jb25zdCBpc0FmdGVyID0gKGJhc2VQYXJ0cywgY29tcGFyZVBhcnRzKSA9PiB7XG4gIHJldHVybiAhIShiYXNlUGFydHMueWVhciA+IGNvbXBhcmVQYXJ0cy55ZWFyIHx8XG4gICAgKGJhc2VQYXJ0cy55ZWFyID09PSBjb21wYXJlUGFydHMueWVhciAmJiBiYXNlUGFydHMubW9udGggPiBjb21wYXJlUGFydHMubW9udGgpIHx8XG4gICAgKGJhc2VQYXJ0cy55ZWFyID09PSBjb21wYXJlUGFydHMueWVhciAmJlxuICAgICAgYmFzZVBhcnRzLm1vbnRoID09PSBjb21wYXJlUGFydHMubW9udGggJiZcbiAgICAgIGJhc2VQYXJ0cy5kYXkgIT09IG51bGwgJiZcbiAgICAgIGJhc2VQYXJ0cy5kYXkgPiBjb21wYXJlUGFydHMuZGF5KSk7XG59O1xuY29uc3Qgd2FybklmVmFsdWVPdXRPZkJvdW5kcyA9ICh2YWx1ZSwgbWluLCBtYXgpID0+IHtcbiAgY29uc3QgdmFsdWVBcnJheSA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xuICBmb3IgKGNvbnN0IHZhbCBvZiB2YWx1ZUFycmF5KSB7XG4gICAgaWYgKChtaW4gIT09IHVuZGVmaW5lZCAmJiBpc0JlZm9yZSh2YWwsIG1pbikpIHx8IChtYXggIT09IHVuZGVmaW5lZCAmJiBpc0FmdGVyKHZhbCwgbWF4KSkpIHtcbiAgICAgIHByaW50SW9uV2FybmluZygnVGhlIHZhbHVlIHByb3ZpZGVkIHRvIGlvbi1kYXRldGltZSBpcyBvdXQgb2YgYm91bmRzLlxcblxcbicgK1xuICAgICAgICBgTWluOiAke0pTT04uc3RyaW5naWZ5KG1pbil9XFxuYCArXG4gICAgICAgIGBNYXg6ICR7SlNPTi5zdHJpbmdpZnkobWF4KX1cXG5gICtcbiAgICAgICAgYFZhbHVlOiAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGdpdmVuIHllYXIgaXMgYVxuICogbGVhcCB5ZWFyLiBSZXR1cm5zIGB0cnVlYCBpZiB5ZWFyXG4gKiBpcyBhIGxlYXAgeWVhci4gUmV0dXJucyBgZmFsc2VgXG4gKiBvdGhlcndpc2UuXG4gKi9cbmNvbnN0IGlzTGVhcFllYXIgPSAoeWVhcikgPT4ge1xuICByZXR1cm4gKHllYXIgJSA0ID09PSAwICYmIHllYXIgJSAxMDAgIT09IDApIHx8IHllYXIgJSA0MDAgPT09IDA7XG59O1xuY29uc3QgaXMyNEhvdXIgPSAobG9jYWxlLCBob3VyQ3ljbGUpID0+IHtcbiAgLyoqXG4gICAqIElmIGRldmVsb3BlciBoYXMgZXhwbGljaXRseSBlbmFibGVkIGgyMyB0aW1lXG4gICAqIHRoZW4gcmV0dXJuIGVhcmx5IGFuZCBkbyBub3QgbG9vayBhdCB0aGUgc3lzdGVtIGRlZmF1bHQuXG4gICAqL1xuICBpZiAoaG91ckN5Y2xlICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gaG91ckN5Y2xlID09PSAnaDIzJztcbiAgfVxuICAvKipcbiAgICogSWYgaG91ckN5Y2xlIHdhcyBub3Qgc3BlY2lmaWVkLCBjaGVjayB0aGUgbG9jYWxlXG4gICAqIHRoYXQgaXMgc2V0IG9uIHRoZSB1c2VyJ3MgZGV2aWNlLiBXZSBmaXJzdCBjaGVjayB0aGVcbiAgICogSW50bC5EYXRlVGltZUZvcm1hdCBob3VyQ3ljbGUgb3B0aW9uIGFzIGRldmVsb3BlcnMgY2FuIGVuY29kZSB0aGlzXG4gICAqIG9wdGlvbiBpbnRvIHRoZSBsb2NhbGUgc3RyaW5nLiBFeGFtcGxlOiBgZW4tVVMtdS1oYy1oMjNgXG4gICAqL1xuICBjb25zdCBmb3JtYXR0ZWQgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGUsIHsgaG91cjogJ251bWVyaWMnIH0pO1xuICBjb25zdCBvcHRpb25zID0gZm9ybWF0dGVkLnJlc29sdmVkT3B0aW9ucygpO1xuICBpZiAob3B0aW9ucy5ob3VyQ3ljbGUgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBvcHRpb25zLmhvdXJDeWNsZSA9PT0gJ2gyMyc7XG4gIH1cbiAgLyoqXG4gICAqIElmIGhvdXJDeWNsZSBpcyBub3Qgc3BlY2lmaWVkIChlaXRoZXIgdGhyb3VnaCBsYWNrXG4gICAqIG9mIGJyb3dzZXIgc3VwcG9ydCBvciBsb2NhbGUgaW5mb3JtYXRpb24pIHRoZW4gZmFsbFxuICAgKiBiYWNrIHRvIHRoaXMgc2xvd2VyIGhvdXJDeWNsZSBjaGVjay5cbiAgICovXG4gIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSgnNS8xOC8yMDIxIDAwOjAwJyk7XG4gIGNvbnN0IHBhcnRzID0gZm9ybWF0dGVkLmZvcm1hdFRvUGFydHMoZGF0ZSk7XG4gIGNvbnN0IGhvdXIgPSBwYXJ0cy5maW5kKChwKSA9PiBwLnR5cGUgPT09ICdob3VyJyk7XG4gIGlmICghaG91cikge1xuICAgIHRocm93IG5ldyBFcnJvcignSG91ciB2YWx1ZSBub3QgZm91bmQgZnJvbSBEYXRlVGltZUZvcm1hdCcpO1xuICB9XG4gIHJldHVybiBob3VyLnZhbHVlID09PSAnMDAnO1xufTtcbi8qKlxuICogR2l2ZW4gYSBkYXRlIG9iamVjdCwgcmV0dXJucyB0aGUgbnVtYmVyXG4gKiBvZiBkYXlzIGluIHRoYXQgbW9udGguXG4gKiBNb250aCB2YWx1ZSBiZWdpbiBhdCAxLCBub3QgMC5cbiAqIGkuZS4gSmFudWFyeSA9IG1vbnRoIDEuXG4gKi9cbmNvbnN0IGdldE51bURheXNJbk1vbnRoID0gKG1vbnRoLCB5ZWFyKSA9PiB7XG4gIHJldHVybiBtb250aCA9PT0gNCB8fCBtb250aCA9PT0gNiB8fCBtb250aCA9PT0gOSB8fCBtb250aCA9PT0gMTFcbiAgICA/IDMwXG4gICAgOiBtb250aCA9PT0gMlxuICAgICAgPyBpc0xlYXBZZWFyKHllYXIpXG4gICAgICAgID8gMjlcbiAgICAgICAgOiAyOFxuICAgICAgOiAzMTtcbn07XG4vKipcbiAqIENlcnRhaW4gbG9jYWxlcyBkaXNwbGF5IG1vbnRoIHRoZW4geWVhciB3aGlsZVxuICogb3RoZXJzIGRpc3BsYXkgeWVhciB0aGVuIG1vbnRoLlxuICogV2UgY2FuIHVzZSBJbnRsLkRhdGVUaW1lRm9ybWF0IHRvIGRldGVybWluZVxuICogdGhlIG9yZGVyaW5nIGZvciBlYWNoIGxvY2FsZS5cbiAqIFRoZSBmb3JtYXRPcHRpb25zIHBhcmFtIGNhbiBiZSB1c2VkIHRvIGN1c3RvbWl6ZVxuICogd2hpY2ggcGllY2VzIG9mIGEgZGF0ZSB0byBjb21wYXJlIGFnYWluc3QgdGhlIG1vbnRoXG4gKiB3aXRoLiBGb3IgZXhhbXBsZSwgc29tZSBsb2NhbGVzIHJlbmRlciBkZC9tbS95eXl5XG4gKiB3aGlsZSBvdGhlcnMgcmVuZGVyIG1tL2RkL3l5eXkuIFRoaXMgZnVuY3Rpb24gY2FuIGJlXG4gKiB1c2VkIGZvciB2YXJpYXRpb25zIG9mIHRoZSBzYW1lIFwibW9udGggZmlyc3RcIiBjaGVjay5cbiAqL1xuY29uc3QgaXNNb250aEZpcnN0TG9jYWxlID0gKGxvY2FsZSwgZm9ybWF0T3B0aW9ucyA9IHtcbiAgbW9udGg6ICdudW1lcmljJyxcbiAgeWVhcjogJ251bWVyaWMnLFxufSkgPT4ge1xuICAvKipcbiAgICogQnkgc2V0dGluZyBtb250aCBhbmQgeWVhciB3ZSBndWFyYW50ZWUgdGhhdCBvbmx5XG4gICAqIG1vbnRoLCB5ZWFyLCBhbmQgbGl0ZXJhbCAoc2xhc2hlcyAnLycsIGZvciBleGFtcGxlKVxuICAgKiB2YWx1ZXMgYXJlIGluY2x1ZGVkIGluIHRoZSBmb3JtYXRUb1BhcnRzIHJlc3VsdHMuXG4gICAqXG4gICAqIFRoZSBvcmRlcmluZyBvZiB0aGUgcGFydHMgd2lsbCBiZSBkZXRlcm1pbmVkIGJ5XG4gICAqIHRoZSBsb2NhbGUuIFNvIGlmIHRoZSBtb250aCBpcyB0aGUgZmlyc3QgdmFsdWUsXG4gICAqIHRoZW4gd2Uga25vdyBtb250aCBzaG91bGQgYmUgc2hvd24gZmlyc3QuIElmIHRoZVxuICAgKiB5ZWFyIGlzIHRoZSBmaXJzdCB2YWx1ZSwgdGhlbiB3ZSBrbm93IHllYXIgc2hvdWxkIGJlIHNob3duIGZpcnN0LlxuICAgKlxuICAgKiBUaGlzIG9yZGVyaW5nIGNhbiBiZSBjb250cm9sbGVkIGJ5IGN1c3RvbWl6aW5nIHRoZSBsb2NhbGUgcHJvcGVydHkuXG4gICAqL1xuICBjb25zdCBwYXJ0cyA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZSwgZm9ybWF0T3B0aW9ucykuZm9ybWF0VG9QYXJ0cyhuZXcgRGF0ZSgpKTtcbiAgcmV0dXJuIHBhcnRzWzBdLnR5cGUgPT09ICdtb250aCc7XG59O1xuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBnaXZlbiBsb2NhbGUgZm9ybWF0cyB0aGUgZGF5IHBlcmlvZCAoYW0vcG0pIHRvIHRoZVxuICogbGVmdCBvciByaWdodCBvZiB0aGUgaG91ci5cbiAqIEBwYXJhbSBsb2NhbGUgVGhlIGxvY2FsZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgbG9jYWxlIGZvcm1hdHMgdGhlIGRheSBwZXJpb2QgdG8gdGhlIGxlZnQgb2YgdGhlIGhvdXIuXG4gKi9cbmNvbnN0IGlzTG9jYWxlRGF5UGVyaW9kUlRMID0gKGxvY2FsZSkgPT4ge1xuICBjb25zdCBwYXJ0cyA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZSwgeyBob3VyOiAnbnVtZXJpYycgfSkuZm9ybWF0VG9QYXJ0cyhuZXcgRGF0ZSgpKTtcbiAgcmV0dXJuIHBhcnRzWzBdLnR5cGUgPT09ICdkYXlQZXJpb2QnO1xufTtcblxuY29uc3QgSVNPXzg2MDFfUkVHRVhQID0gXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcbi9eKFxcZHs0fXxbK1xcLV1cXGR7Nn0pKD86LShcXGR7Mn0pKD86LShcXGR7Mn0pKT8pPyg/OlQoXFxkezJ9KTooXFxkezJ9KSg/OjooXFxkezJ9KSg/OlxcLihcXGR7M30pKT8pPyg/OihaKXwoWytcXC1dKShcXGR7Mn0pKD86OihcXGR7Mn0pKT8pPyk/JC87XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcbmNvbnN0IFRJTUVfUkVHRVhQID0gL14oKFxcZHsyfSk6KFxcZHsyfSkoPzo6KFxcZHsyfSkoPzpcXC4oXFxkezN9KSk/KT8oPzooWil8KFsrXFwtXSkoXFxkezJ9KSg/OjooXFxkezJ9KSk/KT8pPyQvO1xuLyoqXG4gKiBVc2UgdG8gY29udmVydCBhIHN0cmluZyBvZiBjb21tYSBzZXBhcmF0ZWQgbnVtYmVycyBvclxuICogYW4gYXJyYXkgb2YgbnVtYmVycywgYW5kIGNsZWFuIHVwIGFueSB1c2VyIGlucHV0XG4gKi9cbmNvbnN0IGNvbnZlcnRUb0FycmF5T2ZOdW1iZXJzID0gKGlucHV0KSA9PiB7XG4gIGlmIChpbnB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBwcm9jZXNzZWRJbnB1dCA9IGlucHV0O1xuICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgIC8vIGNvbnZlcnQgdGhlIHN0cmluZyB0byBhbiBhcnJheSBvZiBzdHJpbmdzXG4gICAgLy8gYXV0byByZW1vdmUgYW55IHdoaXRlc3BhY2UgYW5kIFtdIGNoYXJhY3RlcnNcbiAgICBwcm9jZXNzZWRJbnB1dCA9IGlucHV0LnJlcGxhY2UoL1xcW3xcXF18XFxzL2csICcnKS5zcGxpdCgnLCcpO1xuICB9XG4gIGxldCB2YWx1ZXM7XG4gIGlmIChBcnJheS5pc0FycmF5KHByb2Nlc3NlZElucHV0KSkge1xuICAgIC8vIGVuc3VyZSBlYWNoIHZhbHVlIGlzIGFuIGFjdHVhbCBudW1iZXIgaW4gdGhlIHJldHVybmVkIGFycmF5XG4gICAgdmFsdWVzID0gcHJvY2Vzc2VkSW5wdXQubWFwKChudW0pID0+IHBhcnNlSW50KG51bSwgMTApKS5maWx0ZXIoaXNGaW5pdGUpO1xuICB9XG4gIGVsc2Uge1xuICAgIHZhbHVlcyA9IFtwcm9jZXNzZWRJbnB1dF07XG4gIH1cbiAgcmV0dXJuIHZhbHVlcztcbn07XG4vKipcbiAqIEV4dHJhY3RzIGRhdGUgaW5mb3JtYXRpb25cbiAqIGZyb20gYSAuY2FsZW5kYXItZGF5IGVsZW1lbnRcbiAqIGludG8gRGF0ZXRpbWVQYXJ0cy5cbiAqL1xuY29uc3QgZ2V0UGFydHNGcm9tQ2FsZW5kYXJEYXkgPSAoZWwpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBtb250aDogcGFyc2VJbnQoZWwuZ2V0QXR0cmlidXRlKCdkYXRhLW1vbnRoJyksIDEwKSxcbiAgICBkYXk6IHBhcnNlSW50KGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1kYXknKSwgMTApLFxuICAgIHllYXI6IHBhcnNlSW50KGVsLmdldEF0dHJpYnV0ZSgnZGF0YS15ZWFyJyksIDEwKSxcbiAgICBkYXlPZldlZWs6IHBhcnNlSW50KGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1kYXktb2Ytd2VlaycpLCAxMCksXG4gIH07XG59O1xuZnVuY3Rpb24gcGFyc2VEYXRlKHZhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgcmV0dXJuIHZhbC5tYXAoKHZhbFN0cikgPT4gcGFyc2VEYXRlKHZhbFN0cikpO1xuICB9XG4gIC8vIG1hbnVhbGx5IHBhcnNlIElTMCBjdXogRGF0ZS5wYXJzZSBjYW5ub3QgYmUgdHJ1c3RlZFxuICAvLyBJU08gODYwMSBmb3JtYXQ6IDE5OTQtMTItMTVUMTM6NDc6MjBaXG4gIGxldCBwYXJzZSA9IG51bGw7XG4gIGlmICh2YWwgIT0gbnVsbCAmJiB2YWwgIT09ICcnKSB7XG4gICAgLy8gdHJ5IHBhcnNpbmcgZm9yIGp1c3QgdGltZSBmaXJzdCwgSEg6TU1cbiAgICBwYXJzZSA9IFRJTUVfUkVHRVhQLmV4ZWModmFsKTtcbiAgICBpZiAocGFyc2UpIHtcbiAgICAgIC8vIGFkanVzdCB0aGUgYXJyYXkgc28gaXQgZml0cyBuaWNlbHkgd2l0aCB0aGUgZGF0ZXRpbWUgcGFyc2VcbiAgICAgIHBhcnNlLnVuc2hpZnQodW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuICAgICAgcGFyc2VbMl0gPSBwYXJzZVszXSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyB0cnkgcGFyc2luZyBmb3IgZnVsbCBJU08gZGF0ZXRpbWVcbiAgICAgIHBhcnNlID0gSVNPXzg2MDFfUkVHRVhQLmV4ZWModmFsKTtcbiAgICB9XG4gIH1cbiAgaWYgKHBhcnNlID09PSBudWxsKSB7XG4gICAgLy8gd2Fzbid0IGFibGUgdG8gcGFyc2UgdGhlIElTTyBkYXRldGltZVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgLy8gZW5zdXJlIGFsbCB0aGUgcGFyc2UgdmFsdWVzIGV4aXN0IHdpdGggYXQgbGVhc3QgMFxuICBmb3IgKGxldCBpID0gMTsgaSA8IDg7IGkrKykge1xuICAgIHBhcnNlW2ldID0gcGFyc2VbaV0gIT09IHVuZGVmaW5lZCA/IHBhcnNlSW50KHBhcnNlW2ldLCAxMCkgOiB1bmRlZmluZWQ7XG4gIH1cbiAgbGV0IHR6T2Zmc2V0ID0gMDtcbiAgaWYgKHBhcnNlWzldICYmIHBhcnNlWzEwXSkge1xuICAgIC8vIGhvdXJzXG4gICAgdHpPZmZzZXQgPSBwYXJzZUludChwYXJzZVsxMF0sIDEwKSAqIDYwO1xuICAgIGlmIChwYXJzZVsxMV0pIHtcbiAgICAgIC8vIG1pbnV0ZXNcbiAgICAgIHR6T2Zmc2V0ICs9IHBhcnNlSW50KHBhcnNlWzExXSwgMTApO1xuICAgIH1cbiAgICBpZiAocGFyc2VbOV0gPT09ICctJykge1xuICAgICAgLy8gKyBvciAtXG4gICAgICB0ek9mZnNldCAqPSAtMTtcbiAgICB9XG4gIH1cbiAgLy8gY2FuIGFsc28gZ2V0IHNlY29uZCBhbmQgbWlsbGlzZWNvbmQgZnJvbSBwYXJzZVs2XSBhbmQgcGFyc2VbN10gaWYgbmVlZGVkXG4gIHJldHVybiB7XG4gICAgeWVhcjogcGFyc2VbMV0sXG4gICAgbW9udGg6IHBhcnNlWzJdLFxuICAgIGRheTogcGFyc2VbM10sXG4gICAgaG91cjogcGFyc2VbNF0sXG4gICAgbWludXRlOiBwYXJzZVs1XSxcbiAgICB0ek9mZnNldCxcbiAgICBhbXBtOiBwYXJzZVs0XSA8IDEyID8gJ2FtJyA6ICdwbScsXG4gIH07XG59XG5jb25zdCBjbGFtcERhdGUgPSAoZGF0ZVBhcnRzLCBtaW5QYXJ0cywgbWF4UGFydHMpID0+IHtcbiAgaWYgKG1pblBhcnRzICYmIGlzQmVmb3JlKGRhdGVQYXJ0cywgbWluUGFydHMpKSB7XG4gICAgcmV0dXJuIG1pblBhcnRzO1xuICB9XG4gIGVsc2UgaWYgKG1heFBhcnRzICYmIGlzQWZ0ZXIoZGF0ZVBhcnRzLCBtYXhQYXJ0cykpIHtcbiAgICByZXR1cm4gbWF4UGFydHM7XG4gIH1cbiAgcmV0dXJuIGRhdGVQYXJ0cztcbn07XG4vKipcbiAqIFBhcnNlcyBhbiBob3VyIGFuZCByZXR1cm5zIGlmIHRoZSB2YWx1ZSBpcyBpbiB0aGUgbW9ybmluZyAoYW0pIG9yIGFmdGVybm9vbiAocG0pLlxuICogQHBhcmFtIGhvdXIgVGhlIGhvdXIgdG8gZm9ybWF0LCBzaG91bGQgYmUgMC0yM1xuICogQHJldHVybnMgYHBtYCBpZiB0aGUgaG91ciBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMTIsIGBhbWAgaWYgbGVzcyB0aGFuIDEyLlxuICovXG5jb25zdCBwYXJzZUFtUG0gPSAoaG91cikgPT4ge1xuICByZXR1cm4gaG91ciA+PSAxMiA/ICdwbScgOiAnYW0nO1xufTtcbi8qKlxuICogVGFrZXMgYSBtYXggZGF0ZSBzdHJpbmcgYW5kIGNyZWF0ZXMgYSBEYXRldGltZVBhcnRzXG4gKiBvYmplY3QsIGZpbGxpbmcgaW4gYW55IG1pc3NpbmcgaW5mb3JtYXRpb24uXG4gKiBGb3IgZXhhbXBsZSwgbWF4PVwiMjAxMlwiIHdvdWxkIGZpbGwgaW4gdGhlIG1pc3NpbmdcbiAqIG1vbnRoLCBkYXksIGhvdXIsIGFuZCBtaW51dGUgaW5mb3JtYXRpb24uXG4gKi9cbmNvbnN0IHBhcnNlTWF4UGFydHMgPSAobWF4LCB0b2RheVBhcnRzKSA9PiB7XG4gIGNvbnN0IHsgbW9udGgsIGRheSwgeWVhciwgaG91ciwgbWludXRlIH0gPSBwYXJzZURhdGUobWF4KTtcbiAgLyoqXG4gICAqIFdoZW4gcGFzc2luZyBpbiBgbWF4YCBvciBgbWluYCwgZGV2ZWxvcGVyc1xuICAgKiBjYW4gcGFzcyBpbiBhbnkgSVNPLTg2MDEgc3RyaW5nLiBUaGlzIG1lYW5zXG4gICAqIHRoYXQgbm90IGFsbCBvZiB0aGUgZGF0ZS90aW1lIGZpZWxkcyBhcmUgZGVmaW5lZC5cbiAgICogRm9yIGV4YW1wbGUsIHBhc3NpbmcgbWF4PVwiMjAxMlwiIGlzIHZhbGlkIGV2ZW4gdGhvdWdoXG4gICAqIHRoZXJlIGlzIG5vIG1vbnRoLCBkYXksIGhvdXIsIG9yIG1pbnV0ZSBkYXRhLlxuICAgKiBIb3dldmVyLCBhbGwgb2YgdGhpcyBkYXRhIGlzIHJlcXVpcmVkIHdoZW4gY2xhbXBpbmcgdGhlIGRhdGVcbiAgICogc28gdGhhdCB0aGUgY29ycmVjdCBpbml0aWFsIHZhbHVlIGNhbiBiZSBzZWxlY3RlZC4gQXMgYSByZXN1bHQsXG4gICAqIHdlIG5lZWQgdG8gZmlsbCBpbiBhbnkgb21pdHRlZCBkYXRhIHdpdGggdGhlIG1pbiBvciBtYXggdmFsdWVzLlxuICAgKi9cbiAgY29uc3QgeWVhclZhbHVlID0geWVhciAhPT0gbnVsbCAmJiB5ZWFyICE9PSB2b2lkIDAgPyB5ZWFyIDogdG9kYXlQYXJ0cy55ZWFyO1xuICBjb25zdCBtb250aFZhbHVlID0gbW9udGggIT09IG51bGwgJiYgbW9udGggIT09IHZvaWQgMCA/IG1vbnRoIDogMTI7XG4gIHJldHVybiB7XG4gICAgbW9udGg6IG1vbnRoVmFsdWUsXG4gICAgZGF5OiBkYXkgIT09IG51bGwgJiYgZGF5ICE9PSB2b2lkIDAgPyBkYXkgOiBnZXROdW1EYXlzSW5Nb250aChtb250aFZhbHVlLCB5ZWFyVmFsdWUpLFxuICAgIC8qKlxuICAgICAqIFBhc3NpbmcgaW4gXCJISDptbVwiIGlzIGEgdmFsaWQgSVNPLTg2MDFcbiAgICAgKiBzdHJpbmcsIHNvIHdlIGp1c3QgZGVmYXVsdCB0byB0aGUgY3VycmVudCB5ZWFyXG4gICAgICogaW4gdGhpcyBjYXNlLlxuICAgICAqL1xuICAgIHllYXI6IHllYXJWYWx1ZSxcbiAgICBob3VyOiBob3VyICE9PSBudWxsICYmIGhvdXIgIT09IHZvaWQgMCA/IGhvdXIgOiAyMyxcbiAgICBtaW51dGU6IG1pbnV0ZSAhPT0gbnVsbCAmJiBtaW51dGUgIT09IHZvaWQgMCA/IG1pbnV0ZSA6IDU5LFxuICB9O1xufTtcbi8qKlxuICogVGFrZXMgYSBtaW4gZGF0ZSBzdHJpbmcgYW5kIGNyZWF0ZXMgYSBEYXRldGltZVBhcnRzXG4gKiBvYmplY3QsIGZpbGxpbmcgaW4gYW55IG1pc3NpbmcgaW5mb3JtYXRpb24uXG4gKiBGb3IgZXhhbXBsZSwgbWluPVwiMjAxMlwiIHdvdWxkIGZpbGwgaW4gdGhlIG1pc3NpbmdcbiAqIG1vbnRoLCBkYXksIGhvdXIsIGFuZCBtaW51dGUgaW5mb3JtYXRpb24uXG4gKi9cbmNvbnN0IHBhcnNlTWluUGFydHMgPSAobWluLCB0b2RheVBhcnRzKSA9PiB7XG4gIGNvbnN0IHsgbW9udGgsIGRheSwgeWVhciwgaG91ciwgbWludXRlIH0gPSBwYXJzZURhdGUobWluKTtcbiAgLyoqXG4gICAqIFdoZW4gcGFzc2luZyBpbiBgbWF4YCBvciBgbWluYCwgZGV2ZWxvcGVyc1xuICAgKiBjYW4gcGFzcyBpbiBhbnkgSVNPLTg2MDEgc3RyaW5nLiBUaGlzIG1lYW5zXG4gICAqIHRoYXQgbm90IGFsbCBvZiB0aGUgZGF0ZS90aW1lIGZpZWxkcyBhcmUgZGVmaW5lZC5cbiAgICogRm9yIGV4YW1wbGUsIHBhc3NpbmcgbWF4PVwiMjAxMlwiIGlzIHZhbGlkIGV2ZW4gdGhvdWdoXG4gICAqIHRoZXJlIGlzIG5vIG1vbnRoLCBkYXksIGhvdXIsIG9yIG1pbnV0ZSBkYXRhLlxuICAgKiBIb3dldmVyLCBhbGwgb2YgdGhpcyBkYXRhIGlzIHJlcXVpcmVkIHdoZW4gY2xhbXBpbmcgdGhlIGRhdGVcbiAgICogc28gdGhhdCB0aGUgY29ycmVjdCBpbml0aWFsIHZhbHVlIGNhbiBiZSBzZWxlY3RlZC4gQXMgYSByZXN1bHQsXG4gICAqIHdlIG5lZWQgdG8gZmlsbCBpbiBhbnkgb21pdHRlZCBkYXRhIHdpdGggdGhlIG1pbiBvciBtYXggdmFsdWVzLlxuICAgKi9cbiAgcmV0dXJuIHtcbiAgICBtb250aDogbW9udGggIT09IG51bGwgJiYgbW9udGggIT09IHZvaWQgMCA/IG1vbnRoIDogMSxcbiAgICBkYXk6IGRheSAhPT0gbnVsbCAmJiBkYXkgIT09IHZvaWQgMCA/IGRheSA6IDEsXG4gICAgLyoqXG4gICAgICogUGFzc2luZyBpbiBcIkhIOm1tXCIgaXMgYSB2YWxpZCBJU08tODYwMVxuICAgICAqIHN0cmluZywgc28gd2UganVzdCBkZWZhdWx0IHRvIHRoZSBjdXJyZW50IHllYXJcbiAgICAgKiBpbiB0aGlzIGNhc2UuXG4gICAgICovXG4gICAgeWVhcjogeWVhciAhPT0gbnVsbCAmJiB5ZWFyICE9PSB2b2lkIDAgPyB5ZWFyIDogdG9kYXlQYXJ0cy55ZWFyLFxuICAgIGhvdXI6IGhvdXIgIT09IG51bGwgJiYgaG91ciAhPT0gdm9pZCAwID8gaG91ciA6IDAsXG4gICAgbWludXRlOiBtaW51dGUgIT09IG51bGwgJiYgbWludXRlICE9PSB2b2lkIDAgPyBtaW51dGUgOiAwLFxuICB9O1xufTtcblxuY29uc3QgdHdvRGlnaXQgPSAodmFsKSA9PiB7XG4gIHJldHVybiAoJzAnICsgKHZhbCAhPT0gdW5kZWZpbmVkID8gTWF0aC5hYnModmFsKSA6ICcwJykpLnNsaWNlKC0yKTtcbn07XG5jb25zdCBmb3VyRGlnaXQgPSAodmFsKSA9PiB7XG4gIHJldHVybiAoJzAwMCcgKyAodmFsICE9PSB1bmRlZmluZWQgPyBNYXRoLmFicyh2YWwpIDogJzAnKSkuc2xpY2UoLTQpO1xufTtcbmZ1bmN0aW9uIGNvbnZlcnREYXRhVG9JU08oZGF0YSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgIHJldHVybiBkYXRhLm1hcCgocGFydHMpID0+IGNvbnZlcnREYXRhVG9JU08ocGFydHMpKTtcbiAgfVxuICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvTk9URS1kYXRldGltZVxuICBsZXQgcnRuID0gJyc7XG4gIGlmIChkYXRhLnllYXIgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIFlZWVlcbiAgICBydG4gPSBmb3VyRGlnaXQoZGF0YS55ZWFyKTtcbiAgICBpZiAoZGF0YS5tb250aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBZWVlZLU1NXG4gICAgICBydG4gKz0gJy0nICsgdHdvRGlnaXQoZGF0YS5tb250aCk7XG4gICAgICBpZiAoZGF0YS5kYXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBZWVlZLU1NLUREXG4gICAgICAgIHJ0biArPSAnLScgKyB0d29EaWdpdChkYXRhLmRheSk7XG4gICAgICAgIGlmIChkYXRhLmhvdXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIFlZWVktTU0tRERUSEg6bW06U1NcbiAgICAgICAgICBydG4gKz0gYFQke3R3b0RpZ2l0KGRhdGEuaG91cil9OiR7dHdvRGlnaXQoZGF0YS5taW51dGUpfTowMGA7XG4gICAgICAgICAgaWYgKGRhdGEudHpPZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gWVlZWS1NTS1ERFRISDptbTpTU1pcbiAgICAgICAgICAgIHJ0biArPSAnWic7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gWVlZWS1NTS1ERFRISDptbTpTUysvLUhIOm1tXG4gICAgICAgICAgICBydG4gKz1cbiAgICAgICAgICAgICAgKGRhdGEudHpPZmZzZXQgPiAwID8gJysnIDogJy0nKSArXG4gICAgICAgICAgICAgICAgdHdvRGlnaXQoTWF0aC5mbG9vcihNYXRoLmFicyhkYXRhLnR6T2Zmc2V0IC8gNjApKSkgK1xuICAgICAgICAgICAgICAgICc6JyArXG4gICAgICAgICAgICAgICAgdHdvRGlnaXQoZGF0YS50ek9mZnNldCAlIDYwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAoZGF0YS5ob3VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBISDptbVxuICAgIHJ0biA9IHR3b0RpZ2l0KGRhdGEuaG91cikgKyAnOicgKyB0d29EaWdpdChkYXRhLm1pbnV0ZSk7XG4gIH1cbiAgcmV0dXJuIHJ0bjtcbn1cbi8qKlxuICogQ29udmVydHMgYW4gMTIgaG91ciB2YWx1ZSB0byAyNCBob3Vycy5cbiAqL1xuY29uc3QgY29udmVydDEySG91clRvMjRIb3VyID0gKGhvdXIsIGFtcG0pID0+IHtcbiAgaWYgKGFtcG0gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBob3VyO1xuICB9XG4gIC8qKlxuICAgKiBJZiBBTSBhbmQgMTJhbVxuICAgKiB0aGVuIHJldHVybiAwMDowMC5cbiAgICogT3RoZXJ3aXNlIGp1c3QgcmV0dXJuXG4gICAqIHRoZSBob3VyIHNpbmNlIGl0IGlzXG4gICAqIGFscmVhZHkgaW4gMjQgaG91ciBmb3JtYXQuXG4gICAqL1xuICBpZiAoYW1wbSA9PT0gJ2FtJykge1xuICAgIGlmIChob3VyID09PSAxMikge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiBob3VyO1xuICB9XG4gIC8qKlxuICAgKiBJZiBQTSBhbmQgMTJwbVxuICAgKiBqdXN0IHJldHVybiAxMjowMFxuICAgKiBzaW5jZSBpdCBpcyBhbHJlYWR5XG4gICAqIGluIDI0IGhvdXIgZm9ybWF0LlxuICAgKiBPdGhlcndpc2UgYWRkIDEyIGhvdXJzXG4gICAqIHRvIHRoZSB0aW1lLlxuICAgKi9cbiAgaWYgKGhvdXIgPT09IDEyKSB7XG4gICAgcmV0dXJuIDEyO1xuICB9XG4gIHJldHVybiBob3VyICsgMTI7XG59O1xuY29uc3QgZ2V0U3RhcnRPZldlZWsgPSAocmVmUGFydHMpID0+IHtcbiAgY29uc3QgeyBkYXlPZldlZWsgfSA9IHJlZlBhcnRzO1xuICBpZiAoZGF5T2ZXZWVrID09PSBudWxsIHx8IGRheU9mV2VlayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBkYXkgb2Ygd2VlayBwcm92aWRlZCcpO1xuICB9XG4gIHJldHVybiBzdWJ0cmFjdERheXMocmVmUGFydHMsIGRheU9mV2Vlayk7XG59O1xuY29uc3QgZ2V0RW5kT2ZXZWVrID0gKHJlZlBhcnRzKSA9PiB7XG4gIGNvbnN0IHsgZGF5T2ZXZWVrIH0gPSByZWZQYXJ0cztcbiAgaWYgKGRheU9mV2VlayA9PT0gbnVsbCB8fCBkYXlPZldlZWsgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gZGF5IG9mIHdlZWsgcHJvdmlkZWQnKTtcbiAgfVxuICByZXR1cm4gYWRkRGF5cyhyZWZQYXJ0cywgNiAtIGRheU9mV2Vlayk7XG59O1xuY29uc3QgZ2V0TmV4dERheSA9IChyZWZQYXJ0cykgPT4ge1xuICByZXR1cm4gYWRkRGF5cyhyZWZQYXJ0cywgMSk7XG59O1xuY29uc3QgZ2V0UHJldmlvdXNEYXkgPSAocmVmUGFydHMpID0+IHtcbiAgcmV0dXJuIHN1YnRyYWN0RGF5cyhyZWZQYXJ0cywgMSk7XG59O1xuY29uc3QgZ2V0UHJldmlvdXNXZWVrID0gKHJlZlBhcnRzKSA9PiB7XG4gIHJldHVybiBzdWJ0cmFjdERheXMocmVmUGFydHMsIDcpO1xufTtcbmNvbnN0IGdldE5leHRXZWVrID0gKHJlZlBhcnRzKSA9PiB7XG4gIHJldHVybiBhZGREYXlzKHJlZlBhcnRzLCA3KTtcbn07XG4vKipcbiAqIEdpdmVuIGRhdGV0aW1lIHBhcnRzLCBzdWJ0cmFjdFxuICogbnVtRGF5cyBmcm9tIHRoZSBkYXRlLlxuICogUmV0dXJucyBhIG5ldyBEYXRldGltZVBhcnRzIG9iamVjdFxuICogQ3VycmVudGx5IGNhbiBvbmx5IGdvIGJhY2t3YXJkIGF0IG1vc3QgMSBtb250aC5cbiAqL1xuY29uc3Qgc3VidHJhY3REYXlzID0gKHJlZlBhcnRzLCBudW1EYXlzKSA9PiB7XG4gIGNvbnN0IHsgbW9udGgsIGRheSwgeWVhciB9ID0gcmVmUGFydHM7XG4gIGlmIChkYXkgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGRheSBwcm92aWRlZCcpO1xuICB9XG4gIGNvbnN0IHdvcmtpbmdQYXJ0cyA9IHtcbiAgICBtb250aCxcbiAgICBkYXksXG4gICAgeWVhcixcbiAgfTtcbiAgd29ya2luZ1BhcnRzLmRheSA9IGRheSAtIG51bURheXM7XG4gIC8qKlxuICAgKiBJZiB3cmFwcGluZyB0byBwcmV2aW91cyBtb250aFxuICAgKiB1cGRhdGUgZGF5cyBhbmQgZGVjcmVtZW50IG1vbnRoXG4gICAqL1xuICBpZiAod29ya2luZ1BhcnRzLmRheSA8IDEpIHtcbiAgICB3b3JraW5nUGFydHMubW9udGggLT0gMTtcbiAgfVxuICAvKipcbiAgICogSWYgbW92aW5nIHRvIHByZXZpb3VzIHllYXIsIHJlc2V0XG4gICAqIG1vbnRoIHRvIERlY2VtYmVyIGFuZCBkZWNyZW1lbnQgeWVhclxuICAgKi9cbiAgaWYgKHdvcmtpbmdQYXJ0cy5tb250aCA8IDEpIHtcbiAgICB3b3JraW5nUGFydHMubW9udGggPSAxMjtcbiAgICB3b3JraW5nUGFydHMueWVhciAtPSAxO1xuICB9XG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgaG93IG1hbnkgZGF5cyBhcmUgaW4gdGhlIGN1cnJlbnRcbiAgICogbW9udGhcbiAgICovXG4gIGlmICh3b3JraW5nUGFydHMuZGF5IDwgMSkge1xuICAgIGNvbnN0IGRheXNJbk1vbnRoID0gZ2V0TnVtRGF5c0luTW9udGgod29ya2luZ1BhcnRzLm1vbnRoLCB3b3JraW5nUGFydHMueWVhcik7XG4gICAgLyoqXG4gICAgICogVGFrZSBudW0gZGF5cyBpbiBtb250aCBhbmQgYWRkIHRoZVxuICAgICAqIG51bWJlciBvZiB1bmRlcmZsb3cgZGF5cy4gVGhpcyBudW1iZXIgd2lsbFxuICAgICAqIGJlIG5lZ2F0aXZlLlxuICAgICAqIEV4YW1wbGU6IDEgd2VlayBiZWZvcmUgSmFuIDIsIDIwMjEgaXNcbiAgICAgKiBEZWNlbWJlciAyNiwgMjAyMSBzbzpcbiAgICAgKiAyIC0gNyA9IC01XG4gICAgICogMzEgKyAoLTUpID0gMjZcbiAgICAgKi9cbiAgICB3b3JraW5nUGFydHMuZGF5ID0gZGF5c0luTW9udGggKyB3b3JraW5nUGFydHMuZGF5O1xuICB9XG4gIHJldHVybiB3b3JraW5nUGFydHM7XG59O1xuLyoqXG4gKiBHaXZlbiBkYXRldGltZSBwYXJ0cywgYWRkXG4gKiBudW1EYXlzIHRvIHRoZSBkYXRlLlxuICogUmV0dXJucyBhIG5ldyBEYXRldGltZVBhcnRzIG9iamVjdFxuICogQ3VycmVudGx5IGNhbiBvbmx5IGdvIGZvcndhcmQgYXQgbW9zdCAxIG1vbnRoLlxuICovXG5jb25zdCBhZGREYXlzID0gKHJlZlBhcnRzLCBudW1EYXlzKSA9PiB7XG4gIGNvbnN0IHsgbW9udGgsIGRheSwgeWVhciB9ID0gcmVmUGFydHM7XG4gIGlmIChkYXkgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGRheSBwcm92aWRlZCcpO1xuICB9XG4gIGNvbnN0IHdvcmtpbmdQYXJ0cyA9IHtcbiAgICBtb250aCxcbiAgICBkYXksXG4gICAgeWVhcixcbiAgfTtcbiAgY29uc3QgZGF5c0luTW9udGggPSBnZXROdW1EYXlzSW5Nb250aChtb250aCwgeWVhcik7XG4gIHdvcmtpbmdQYXJ0cy5kYXkgPSBkYXkgKyBudW1EYXlzO1xuICAvKipcbiAgICogSWYgd3JhcHBpbmcgdG8gbmV4dCBtb250aFxuICAgKiB1cGRhdGUgZGF5cyBhbmQgaW5jcmVtZW50IG1vbnRoXG4gICAqL1xuICBpZiAod29ya2luZ1BhcnRzLmRheSA+IGRheXNJbk1vbnRoKSB7XG4gICAgd29ya2luZ1BhcnRzLmRheSAtPSBkYXlzSW5Nb250aDtcbiAgICB3b3JraW5nUGFydHMubW9udGggKz0gMTtcbiAgfVxuICAvKipcbiAgICogSWYgbW92aW5nIHRvIG5leHQgeWVhciwgcmVzZXRcbiAgICogbW9udGggdG8gSmFudWFyeSBhbmQgaW5jcmVtZW50IHllYXJcbiAgICovXG4gIGlmICh3b3JraW5nUGFydHMubW9udGggPiAxMikge1xuICAgIHdvcmtpbmdQYXJ0cy5tb250aCA9IDE7XG4gICAgd29ya2luZ1BhcnRzLnllYXIgKz0gMTtcbiAgfVxuICByZXR1cm4gd29ya2luZ1BhcnRzO1xufTtcbi8qKlxuICogR2l2ZW4gRGF0ZXRpbWVQYXJ0cywgZ2VuZXJhdGUgdGhlIHByZXZpb3VzIG1vbnRoLlxuICovXG5jb25zdCBnZXRQcmV2aW91c01vbnRoID0gKHJlZlBhcnRzKSA9PiB7XG4gIC8qKlxuICAgKiBJZiBjdXJyZW50IG1vbnRoIGlzIEphbnVhcnksIHdyYXAgYmFja3dhcmRzXG4gICAqICB0byBEZWNlbWJlciBvZiB0aGUgcHJldmlvdXMgeWVhci5cbiAgICovXG4gIGNvbnN0IG1vbnRoID0gcmVmUGFydHMubW9udGggPT09IDEgPyAxMiA6IHJlZlBhcnRzLm1vbnRoIC0gMTtcbiAgY29uc3QgeWVhciA9IHJlZlBhcnRzLm1vbnRoID09PSAxID8gcmVmUGFydHMueWVhciAtIDEgOiByZWZQYXJ0cy55ZWFyO1xuICBjb25zdCBudW1EYXlzSW5Nb250aCA9IGdldE51bURheXNJbk1vbnRoKG1vbnRoLCB5ZWFyKTtcbiAgY29uc3QgZGF5ID0gbnVtRGF5c0luTW9udGggPCByZWZQYXJ0cy5kYXkgPyBudW1EYXlzSW5Nb250aCA6IHJlZlBhcnRzLmRheTtcbiAgcmV0dXJuIHsgbW9udGgsIHllYXIsIGRheSB9O1xufTtcbi8qKlxuICogR2l2ZW4gRGF0ZXRpbWVQYXJ0cywgZ2VuZXJhdGUgdGhlIG5leHQgbW9udGguXG4gKi9cbmNvbnN0IGdldE5leHRNb250aCA9IChyZWZQYXJ0cykgPT4ge1xuICAvKipcbiAgICogSWYgY3VycmVudCBtb250aCBpcyBEZWNlbWJlciwgd3JhcCBmb3J3YXJkc1xuICAgKiAgdG8gSmFudWFyeSBvZiB0aGUgbmV4dCB5ZWFyLlxuICAgKi9cbiAgY29uc3QgbW9udGggPSByZWZQYXJ0cy5tb250aCA9PT0gMTIgPyAxIDogcmVmUGFydHMubW9udGggKyAxO1xuICBjb25zdCB5ZWFyID0gcmVmUGFydHMubW9udGggPT09IDEyID8gcmVmUGFydHMueWVhciArIDEgOiByZWZQYXJ0cy55ZWFyO1xuICBjb25zdCBudW1EYXlzSW5Nb250aCA9IGdldE51bURheXNJbk1vbnRoKG1vbnRoLCB5ZWFyKTtcbiAgY29uc3QgZGF5ID0gbnVtRGF5c0luTW9udGggPCByZWZQYXJ0cy5kYXkgPyBudW1EYXlzSW5Nb250aCA6IHJlZlBhcnRzLmRheTtcbiAgcmV0dXJuIHsgbW9udGgsIHllYXIsIGRheSB9O1xufTtcbmNvbnN0IGNoYW5nZVllYXIgPSAocmVmUGFydHMsIHllYXJEZWx0YSkgPT4ge1xuICBjb25zdCBtb250aCA9IHJlZlBhcnRzLm1vbnRoO1xuICBjb25zdCB5ZWFyID0gcmVmUGFydHMueWVhciArIHllYXJEZWx0YTtcbiAgY29uc3QgbnVtRGF5c0luTW9udGggPSBnZXROdW1EYXlzSW5Nb250aChtb250aCwgeWVhcik7XG4gIGNvbnN0IGRheSA9IG51bURheXNJbk1vbnRoIDwgcmVmUGFydHMuZGF5ID8gbnVtRGF5c0luTW9udGggOiByZWZQYXJ0cy5kYXk7XG4gIHJldHVybiB7IG1vbnRoLCB5ZWFyLCBkYXkgfTtcbn07XG4vKipcbiAqIEdpdmVuIERhdGV0aW1lUGFydHMsIGdlbmVyYXRlIHRoZSBwcmV2aW91cyB5ZWFyLlxuICovXG5jb25zdCBnZXRQcmV2aW91c1llYXIgPSAocmVmUGFydHMpID0+IHtcbiAgcmV0dXJuIGNoYW5nZVllYXIocmVmUGFydHMsIC0xKTtcbn07XG4vKipcbiAqIEdpdmVuIERhdGV0aW1lUGFydHMsIGdlbmVyYXRlIHRoZSBuZXh0IHllYXIuXG4gKi9cbmNvbnN0IGdldE5leHRZZWFyID0gKHJlZlBhcnRzKSA9PiB7XG4gIHJldHVybiBjaGFuZ2VZZWFyKHJlZlBhcnRzLCAxKTtcbn07XG4vKipcbiAqIElmIFBNLCB0aGVuIGludGVybmFsIHZhbHVlIHNob3VsZFxuICogYmUgY29udmVydGVkIHRvIDI0LWhyIHRpbWUuXG4gKiBEb2VzIG5vdCBhcHBseSB3aGVuIHB1YmxpY1xuICogdmFsdWVzIGFyZSBhbHJlYWR5IDI0LWhyIHRpbWUuXG4gKi9cbmNvbnN0IGdldEludGVybmFsSG91clZhbHVlID0gKGhvdXIsIHVzZTI0SG91ciwgYW1wbSkgPT4ge1xuICBpZiAodXNlMjRIb3VyKSB7XG4gICAgcmV0dXJuIGhvdXI7XG4gIH1cbiAgcmV0dXJuIGNvbnZlcnQxMkhvdXJUbzI0SG91cihob3VyLCBhbXBtKTtcbn07XG4vKipcbiAqIFVubGVzcyBvdGhlcndpc2Ugc3RhdGVkLCBhbGwgbW9udGggdmFsdWVzIGFyZVxuICogMSBpbmRleGVkIGluc3RlYWQgb2YgdGhlIHR5cGljYWwgMCBpbmRleCBpbiBKUyBEYXRlLlxuICogRXhhbXBsZTpcbiAqICAgSmFudWFyeSA9IE1vbnRoIDAgd2hlbiB1c2luZyBKUyBEYXRlXG4gKiAgIEphbnVhcnkgPSBNb250aCAxIHdoZW4gdXNpbmcgdGhpcyBkYXRldGltZSB1dGlsXG4gKi9cbi8qKlxuICogR2l2ZW4gdGhlIGN1cnJlbnQgZGF0ZXRpbWUgcGFydHMgYW5kIGEgbmV3IEFNL1BNIHZhbHVlXG4gKiBjYWxjdWxhdGUgd2hhdCB0aGUgaG91ciBzaG91bGQgYmUgaW4gMjQtaG91ciB0aW1lIGZvcm1hdC5cbiAqIFVzZWQgd2hlbiB0b2dnbGluZyB0aGUgQU0vUE0gc2VnbWVudCBzaW5jZSB3ZSBzdG9yZSBvdXIgaG91cnNcbiAqIGluIDI0LWhvdXIgdGltZSBmb3JtYXQgaW50ZXJuYWxseS5cbiAqL1xuY29uc3QgY2FsY3VsYXRlSG91ckZyb21BTVBNID0gKGN1cnJlbnRQYXJ0cywgbmV3QU1QTSkgPT4ge1xuICBjb25zdCB7IGFtcG06IGN1cnJlbnRBTVBNLCBob3VyIH0gPSBjdXJyZW50UGFydHM7XG4gIGxldCBuZXdIb3VyID0gaG91cjtcbiAgLyoqXG4gICAqIElmIGdvaW5nIGZyb20gQU0gLS0+IFBNLCBuZWVkIHRvIHVwZGF0ZSB0aGVcbiAgICpcbiAgICovXG4gIGlmIChjdXJyZW50QU1QTSA9PT0gJ2FtJyAmJiBuZXdBTVBNID09PSAncG0nKSB7XG4gICAgbmV3SG91ciA9IGNvbnZlcnQxMkhvdXJUbzI0SG91cihuZXdIb3VyLCAncG0nKTtcbiAgICAvKipcbiAgICAgKiBJZiBnb2luZyBmcm9tIFBNIC0tPiBBTVxuICAgICAqL1xuICB9XG4gIGVsc2UgaWYgKGN1cnJlbnRBTVBNID09PSAncG0nICYmIG5ld0FNUE0gPT09ICdhbScpIHtcbiAgICBuZXdIb3VyID0gTWF0aC5hYnMobmV3SG91ciAtIDEyKTtcbiAgfVxuICByZXR1cm4gbmV3SG91cjtcbn07XG4vKipcbiAqIFVwZGF0ZXMgcGFydHMgdG8gZW5zdXJlIHRoYXQgbW9udGggYW5kIGRheVxuICogdmFsdWVzIGFyZSB2YWxpZC4gRm9yIGRheXMgdGhhdCBkbyBub3QgZXhpc3QsXG4gKiB0aGUgY2xvc2VzdCB2YWxpZCBkYXkgaXMgdXNlZC5cbiAqL1xuY29uc3QgdmFsaWRhdGVQYXJ0cyA9IChwYXJ0cywgbWluUGFydHMsIG1heFBhcnRzKSA9PiB7XG4gIGNvbnN0IHsgbW9udGgsIGRheSwgeWVhciB9ID0gcGFydHM7XG4gIGNvbnN0IHBhcnRzQ29weSA9IE9iamVjdC5hc3NpZ24oe30sIHBhcnRzKTtcbiAgY29uc3QgbnVtRGF5cyA9IGdldE51bURheXNJbk1vbnRoKG1vbnRoLCB5ZWFyKTtcbiAgLyoqXG4gICAqIElmIHRoZSBtYXggbnVtYmVyIG9mIGRheXNcbiAgICogaXMgZ3JlYXRlciB0aGFuIHRoZSBkYXkgd2Ugd2FudFxuICAgKiB0byBzZXQsIHVwZGF0ZSB0aGUgRGF0ZXRpbWVQYXJ0c1xuICAgKiBkYXkgZmllbGQgdG8gYmUgdGhlIG1heCBkYXlzLlxuICAgKi9cbiAgaWYgKGRheSAhPT0gbnVsbCAmJiBudW1EYXlzIDwgZGF5KSB7XG4gICAgcGFydHNDb3B5LmRheSA9IG51bURheXM7XG4gIH1cbiAgLyoqXG4gICAqIElmIHZhbHVlIGlzIHNhbWUgZGF5IGFzIG1pbiBkYXksXG4gICAqIG1ha2Ugc3VyZSB0aGUgdGltZSB2YWx1ZSBpcyBpbiBib3VuZHMuXG4gICAqL1xuICBpZiAobWluUGFydHMgIT09IHVuZGVmaW5lZCAmJiBpc1NhbWVEYXkocGFydHNDb3B5LCBtaW5QYXJ0cykpIHtcbiAgICAvKipcbiAgICAgKiBJZiB0aGUgaG91ciBpcyBvdXQgb2YgYm91bmRzLFxuICAgICAqIHVwZGF0ZSBib3RoIHRoZSBob3VyIGFuZCBtaW51dGUuXG4gICAgICogVGhpcyBpcyBkb25lIHNvIHRoYXQgdGhlIG5ldyB0aW1lXG4gICAgICogaXMgY2xvc2VzdCB0byB3aGF0IHRoZSB1c2VyIHNlbGVjdGVkLlxuICAgICAqL1xuICAgIGlmIChwYXJ0c0NvcHkuaG91ciAhPT0gdW5kZWZpbmVkICYmIG1pblBhcnRzLmhvdXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHBhcnRzQ29weS5ob3VyIDwgbWluUGFydHMuaG91cikge1xuICAgICAgICBwYXJ0c0NvcHkuaG91ciA9IG1pblBhcnRzLmhvdXI7XG4gICAgICAgIHBhcnRzQ29weS5taW51dGUgPSBtaW5QYXJ0cy5taW51dGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBvbmx5IHRoZSBtaW51dGUgaXMgb3V0IG9mIGJvdW5kcyxcbiAgICAgICAgICogc2V0IGl0IHRvIHRoZSBtaW4gbWludXRlLlxuICAgICAgICAgKi9cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHBhcnRzQ29weS5ob3VyID09PSBtaW5QYXJ0cy5ob3VyICYmXG4gICAgICAgIHBhcnRzQ29weS5taW51dGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBtaW5QYXJ0cy5taW51dGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBwYXJ0c0NvcHkubWludXRlIDwgbWluUGFydHMubWludXRlKSB7XG4gICAgICAgIHBhcnRzQ29weS5taW51dGUgPSBtaW5QYXJ0cy5taW51dGU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBJZiB2YWx1ZSBpcyBzYW1lIGRheSBhcyBtYXggZGF5LFxuICAgKiBtYWtlIHN1cmUgdGhlIHRpbWUgdmFsdWUgaXMgaW4gYm91bmRzLlxuICAgKi9cbiAgaWYgKG1heFBhcnRzICE9PSB1bmRlZmluZWQgJiYgaXNTYW1lRGF5KHBhcnRzLCBtYXhQYXJ0cykpIHtcbiAgICAvKipcbiAgICAgKiBJZiB0aGUgaG91ciBpcyBvdXQgb2YgYm91bmRzLFxuICAgICAqIHVwZGF0ZSBib3RoIHRoZSBob3VyIGFuZCBtaW51dGUuXG4gICAgICogVGhpcyBpcyBkb25lIHNvIHRoYXQgdGhlIG5ldyB0aW1lXG4gICAgICogaXMgY2xvc2VzdCB0byB3aGF0IHRoZSB1c2VyIHNlbGVjdGVkLlxuICAgICAqL1xuICAgIGlmIChwYXJ0c0NvcHkuaG91ciAhPT0gdW5kZWZpbmVkICYmIG1heFBhcnRzLmhvdXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHBhcnRzQ29weS5ob3VyID4gbWF4UGFydHMuaG91cikge1xuICAgICAgICBwYXJ0c0NvcHkuaG91ciA9IG1heFBhcnRzLmhvdXI7XG4gICAgICAgIHBhcnRzQ29weS5taW51dGUgPSBtYXhQYXJ0cy5taW51dGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBvbmx5IHRoZSBtaW51dGUgaXMgb3V0IG9mIGJvdW5kcyxcbiAgICAgICAgICogc2V0IGl0IHRvIHRoZSBtYXggbWludXRlLlxuICAgICAgICAgKi9cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHBhcnRzQ29weS5ob3VyID09PSBtYXhQYXJ0cy5ob3VyICYmXG4gICAgICAgIHBhcnRzQ29weS5taW51dGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBtYXhQYXJ0cy5taW51dGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBwYXJ0c0NvcHkubWludXRlID4gbWF4UGFydHMubWludXRlKSB7XG4gICAgICAgIHBhcnRzQ29weS5taW51dGUgPSBtYXhQYXJ0cy5taW51dGU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJ0c0NvcHk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBjbG9zZXN0IGRhdGUgdG8gcmVmUGFydHNcbiAqIHRoYXQgYWxzbyBtZWV0cyB0aGUgY29uc3RyYWludHMgb2ZcbiAqIHRoZSAqVmFsdWVzIHBhcmFtcy5cbiAqIEBwYXJhbSByZWZQYXJ0cyBUaGUgcmVmZXJlbmNlIGRhdGVcbiAqIEBwYXJhbSBtb250aFZhbHVlcyBUaGUgYWxsb3dlZCBtb250aCB2YWx1ZXNcbiAqIEBwYXJhbSBkYXlWYWx1ZXMgVGhlIGFsbG93ZWQgZGF5IChvZiB0aGUgbW9udGgpIHZhbHVlc1xuICogQHBhcmFtIHllYXJWYWx1ZXMgVGhlIGFsbG93ZWQgeWVhciB2YWx1ZXNcbiAqIEBwYXJhbSBob3VyVmFsdWVzIFRoZSBhbGxvd2VkIGhvdXIgdmFsdWVzXG4gKiBAcGFyYW0gbWludXRlVmFsdWVzIFRoZSBhbGxvd2VkIG1pbnV0ZSB2YWx1ZXNcbiAqL1xuY29uc3QgZ2V0Q2xvc2VzdFZhbGlkRGF0ZSA9IChyZWZQYXJ0cywgbW9udGhWYWx1ZXMsIGRheVZhbHVlcywgeWVhclZhbHVlcywgaG91clZhbHVlcywgbWludXRlVmFsdWVzKSA9PiB7XG4gIGNvbnN0IHsgaG91ciwgbWludXRlLCBkYXksIG1vbnRoLCB5ZWFyIH0gPSByZWZQYXJ0cztcbiAgY29uc3QgY29weVBhcnRzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZWZQYXJ0cyksIHsgZGF5T2ZXZWVrOiB1bmRlZmluZWQgfSk7XG4gIGlmIChtb250aFZhbHVlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29weVBhcnRzLm1vbnRoID0gZmluZENsb3Nlc3RWYWx1ZShtb250aCwgbW9udGhWYWx1ZXMpO1xuICB9XG4gIC8vIERheSBpcyBudWxsYWJsZSBidXQgY2Fubm90IGJlIHVuZGVmaW5lZFxuICBpZiAoZGF5ICE9PSBudWxsICYmIGRheVZhbHVlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29weVBhcnRzLmRheSA9IGZpbmRDbG9zZXN0VmFsdWUoZGF5LCBkYXlWYWx1ZXMpO1xuICB9XG4gIGlmICh5ZWFyVmFsdWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb3B5UGFydHMueWVhciA9IGZpbmRDbG9zZXN0VmFsdWUoeWVhciwgeWVhclZhbHVlcyk7XG4gIH1cbiAgaWYgKGhvdXIgIT09IHVuZGVmaW5lZCAmJiBob3VyVmFsdWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb3B5UGFydHMuaG91ciA9IGZpbmRDbG9zZXN0VmFsdWUoaG91ciwgaG91clZhbHVlcyk7XG4gICAgY29weVBhcnRzLmFtcG0gPSBwYXJzZUFtUG0oY29weVBhcnRzLmhvdXIpO1xuICB9XG4gIGlmIChtaW51dGUgIT09IHVuZGVmaW5lZCAmJiBtaW51dGVWYWx1ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvcHlQYXJ0cy5taW51dGUgPSBmaW5kQ2xvc2VzdFZhbHVlKG1pbnV0ZSwgbWludXRlVmFsdWVzKTtcbiAgfVxuICByZXR1cm4gY29weVBhcnRzO1xufTtcbi8qKlxuICogRmluZHMgdGhlIHZhbHVlIGluIFwidmFsdWVzXCIgdGhhdCBpc1xuICogbnVtZXJpY2FsbHkgY2xvc2VzdCB0byBcInJlZmVyZW5jZVwiLlxuICogVGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgXCJ2YWx1ZXNcIiBpc1xuICogYWxyZWFkeSBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyLlxuICogQHBhcmFtIHJlZmVyZW5jZSBUaGUgcmVmZXJlbmNlIG51bWJlciB0byB1c2VcbiAqIHdoZW4gZmluZGluZyB0aGUgY2xvc2VzdCB2YWx1ZVxuICogQHBhcmFtIHZhbHVlcyBUaGUgYWxsb3dlZCB2YWx1ZXMgdGhhdCB3aWxsIGJlXG4gKiBzZWFyY2hlZCB0byBmaW5kIHRoZSBjbG9zZXN0IHZhbHVlIHRvIFwicmVmZXJlbmNlXCJcbiAqL1xuY29uc3QgZmluZENsb3Nlc3RWYWx1ZSA9IChyZWZlcmVuY2UsIHZhbHVlcykgPT4ge1xuICBsZXQgY2xvc2VzdFZhbHVlID0gdmFsdWVzWzBdO1xuICBsZXQgcmFuayA9IE1hdGguYWJzKGNsb3Nlc3RWYWx1ZSAtIHJlZmVyZW5jZSk7XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgLyoqXG4gICAgICogVGhpcyBjb2RlIHByaW9yaXRpemVzIHRoZSBmaXJzdFxuICAgICAqIGNsb3Nlc3QgcmVzdWx0LiBHaXZlbiB0d28gdmFsdWVzXG4gICAgICogd2l0aCB0aGUgc2FtZSBkaXN0YW5jZSBmcm9tIHJlZmVyZW5jZSxcbiAgICAgKiB0aGlzIGNvZGUgd2lsbCBwcmlvcml0aXplIHRoZSBzbWFsbGVyIG9mXG4gICAgICogdGhlIHR3byB2YWx1ZXMuXG4gICAgICovXG4gICAgY29uc3QgdmFsdWVSYW5rID0gTWF0aC5hYnModmFsdWUgLSByZWZlcmVuY2UpO1xuICAgIGlmICh2YWx1ZVJhbmsgPCByYW5rKSB7XG4gICAgICBjbG9zZXN0VmFsdWUgPSB2YWx1ZTtcbiAgICAgIHJhbmsgPSB2YWx1ZVJhbms7XG4gICAgfVxuICB9XG4gIHJldHVybiBjbG9zZXN0VmFsdWU7XG59O1xuXG5jb25zdCBnZXRGb3JtYXR0ZWREYXlQZXJpb2QgPSAoZGF5UGVyaW9kKSA9PiB7XG4gIGlmIChkYXlQZXJpb2QgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICByZXR1cm4gZGF5UGVyaW9kLnRvVXBwZXJDYXNlKCk7XG59O1xuY29uc3QgZ2V0TG9jYWxpemVkVGltZSA9IChsb2NhbGUsIHJlZlBhcnRzLCB1c2UyNEhvdXIpID0+IHtcbiAgaWYgKHJlZlBhcnRzLmhvdXIgPT09IHVuZGVmaW5lZCB8fCByZWZQYXJ0cy5taW51dGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAnSW52YWxpZCBUaW1lJztcbiAgfVxuICByZXR1cm4gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCB7XG4gICAgaG91cjogJ251bWVyaWMnLFxuICAgIG1pbnV0ZTogJ251bWVyaWMnLFxuICAgIHRpbWVab25lOiAnVVRDJyxcbiAgICAvKipcbiAgICAgKiBXZSB1c2UgaG91ckN5Y2xlIGhlcmUgaW5zdGVhZCBvZiBob3VyMTIgZHVlIHRvOlxuICAgICAqIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTEzNDczMTYmcT1ob3VyMTImY2FuPTJcbiAgICAgKi9cbiAgICBob3VyQ3ljbGU6IHVzZTI0SG91ciA/ICdoMjMnIDogJ2gxMicsXG4gIH0pLmZvcm1hdChuZXcgRGF0ZShjb252ZXJ0RGF0YVRvSVNPKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVmUGFydHMpLCB7IFxuICAgIC8vIFRPRE86IEZXLTE4MzEgd2lsbCByZW1vdmUgdGhlIG5lZWQgdG8gbWFudWFsbHkgc2V0IHRoZSB0ek9mZnNldCB0byB1bmRlZmluZWRcbiAgICB0ek9mZnNldDogdW5kZWZpbmVkIH0pKSkpO1xufTtcbi8qKlxuICogQWRkcyBwYWRkaW5nIHRvIGEgdGltZSB2YWx1ZSBzb1xuICogdGhhdCBpdCBpcyBhbHdheXMgMiBkaWdpdHMuXG4gKi9cbmNvbnN0IGFkZFRpbWVQYWRkaW5nID0gKHZhbHVlKSA9PiB7XG4gIGNvbnN0IHZhbHVlVG9TdHJpbmcgPSB2YWx1ZS50b1N0cmluZygpO1xuICBpZiAodmFsdWVUb1N0cmluZy5sZW5ndGggPiAxKSB7XG4gICAgcmV0dXJuIHZhbHVlVG9TdHJpbmc7XG4gIH1cbiAgcmV0dXJuIGAwJHt2YWx1ZVRvU3RyaW5nfWA7XG59O1xuLyoqXG4gKiBGb3JtYXRzIDI0IGhvdXIgdGltZXMgc28gdGhhdFxuICogaXQgYWx3YXlzIGhhcyAyIGRpZ2l0cy4gRm9yXG4gKiAxMiBob3VyIHRpbWVzIGl0IGVuc3VyZXMgdGhhdFxuICogaG91ciAwIGlzIGZvcm1hdHRlZCBhcyAnMTInLlxuICovXG5jb25zdCBnZXRGb3JtYXR0ZWRIb3VyID0gKGhvdXIsIHVzZTI0SG91cikgPT4ge1xuICBpZiAodXNlMjRIb3VyKSB7XG4gICAgcmV0dXJuIGFkZFRpbWVQYWRkaW5nKGhvdXIpO1xuICB9XG4gIC8qKlxuICAgKiBJZiB1c2luZyAxMiBob3VyXG4gICAqIGZvcm1hdCwgbWFrZSBzdXJlIGhvdXJcbiAgICogMCBpcyBmb3JtYXR0ZWQgYXMgJzEyJy5cbiAgICovXG4gIGlmIChob3VyID09PSAwKSB7XG4gICAgcmV0dXJuICcxMic7XG4gIH1cbiAgcmV0dXJuIGhvdXIudG9TdHJpbmcoKTtcbn07XG4vKipcbiAqIEdlbmVyYXRlcyBhbiBhcmlhLWxhYmVsIHRvIGJlIHJlYWQgYnkgc2NyZWVuIHJlYWRlcnNcbiAqIGdpdmVuIGEgbG9jYWwsIGEgZGF0ZSwgYW5kIHdoZXRoZXIgb3Igbm90IHRoYXQgZGF0ZSBpc1xuICogdG9kYXkncyBkYXRlLlxuICovXG5jb25zdCBnZW5lcmF0ZURheUFyaWFMYWJlbCA9IChsb2NhbGUsIHRvZGF5LCByZWZQYXJ0cykgPT4ge1xuICBpZiAocmVmUGFydHMuZGF5ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIE1NL0REL1lZWVkgd2lsbCByZXR1cm4gbWlkbmlnaHQgaW4gdGhlIHVzZXIncyB0aW1lem9uZS5cbiAgICovXG4gIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShgJHtyZWZQYXJ0cy5tb250aH0vJHtyZWZQYXJ0cy5kYXl9LyR7cmVmUGFydHMueWVhcn0gR01UKzAwMDBgKTtcbiAgY29uc3QgbGFiZWxTdHJpbmcgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGUsIHtcbiAgICB3ZWVrZGF5OiAnbG9uZycsXG4gICAgbW9udGg6ICdsb25nJyxcbiAgICBkYXk6ICdudW1lcmljJyxcbiAgICB0aW1lWm9uZTogJ1VUQycsXG4gIH0pLmZvcm1hdChkYXRlKTtcbiAgLyoqXG4gICAqIElmIGRhdGUgaXMgdG9kYXksIHByZXBlbmQgXCJUb2RheVwiIHNvIHNjcmVlbiByZWFkZXJzIGluZGljYXRlXG4gICAqIHRoYXQgdGhlIGRhdGUgaXMgdG9kYXkuXG4gICAqL1xuICByZXR1cm4gdG9kYXkgPyBgVG9kYXksICR7bGFiZWxTdHJpbmd9YCA6IGxhYmVsU3RyaW5nO1xufTtcbi8qKlxuICogR2V0cyB0aGUgZGF5IG9mIHRoZSB3ZWVrLCBtb250aCwgYW5kIGRheVxuICogVXNlZCBmb3IgdGhlIGhlYWRlciBpbiBNRCBtb2RlLlxuICovXG5jb25zdCBnZXRNb250aEFuZERheSA9IChsb2NhbGUsIHJlZlBhcnRzKSA9PiB7XG4gIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShgJHtyZWZQYXJ0cy5tb250aH0vJHtyZWZQYXJ0cy5kYXl9LyR7cmVmUGFydHMueWVhcn0gR01UKzAwMDBgKTtcbiAgcmV0dXJuIG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZSwgeyB3ZWVrZGF5OiAnc2hvcnQnLCBtb250aDogJ3Nob3J0JywgZGF5OiAnbnVtZXJpYycsIHRpbWVab25lOiAnVVRDJyB9KS5mb3JtYXQoZGF0ZSk7XG59O1xuLyoqXG4gKiBHaXZlbiBhIGxvY2FsZSBhbmQgYSBkYXRlIG9iamVjdCxcbiAqIHJldHVybiBhIGZvcm1hdHRlZCBzdHJpbmcgdGhhdCBpbmNsdWRlc1xuICogdGhlIG1vbnRoIG5hbWUgYW5kIGZ1bGwgeWVhci5cbiAqIEV4YW1wbGU6IE1heSAyMDIxXG4gKi9cbmNvbnN0IGdldE1vbnRoQW5kWWVhciA9IChsb2NhbGUsIHJlZlBhcnRzKSA9PiB7XG4gIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShgJHtyZWZQYXJ0cy5tb250aH0vJHtyZWZQYXJ0cy5kYXl9LyR7cmVmUGFydHMueWVhcn0gR01UKzAwMDBgKTtcbiAgcmV0dXJuIG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZSwgeyBtb250aDogJ2xvbmcnLCB5ZWFyOiAnbnVtZXJpYycsIHRpbWVab25lOiAnVVRDJyB9KS5mb3JtYXQoZGF0ZSk7XG59O1xuLyoqXG4gKiBHaXZlbiBhIGxvY2FsZSBhbmQgYSBkYXRlIG9iamVjdCxcbiAqIHJldHVybiBhIGZvcm1hdHRlZCBzdHJpbmcgdGhhdCBpbmNsdWRlc1xuICogdGhlIHNob3J0IG1vbnRoLCBudW1lcmljIGRheSwgYW5kIGZ1bGwgeWVhci5cbiAqIEV4YW1wbGU6IEFwciAyMiwgMjAyMVxuICovXG5jb25zdCBnZXRNb250aERheUFuZFllYXIgPSAobG9jYWxlLCByZWZQYXJ0cykgPT4ge1xuICByZXR1cm4gZ2V0TG9jYWxpemVkRGF0ZVRpbWUobG9jYWxlLCByZWZQYXJ0cywgeyBtb250aDogJ3Nob3J0JywgZGF5OiAnbnVtZXJpYycsIHllYXI6ICdudW1lcmljJyB9KTtcbn07XG4vKipcbiAqIEdpdmVuIGEgbG9jYWxlIGFuZCBhIGRhdGUgb2JqZWN0LFxuICogcmV0dXJuIGEgZm9ybWF0dGVkIHN0cmluZyB0aGF0IGluY2x1ZGVzXG4gKiB0aGUgbnVtZXJpYyBkYXkuXG4gKiBOb3RlOiBTb21lIGxhbmd1YWdlcyB3aWxsIGFkZCBsaXRlcmFsIGNoYXJhY3RlcnNcbiAqIHRvIHRoZSBlbmQuIFRoaXMgZnVuY3Rpb24gcmVtb3ZlcyB0aG9zZSBsaXRlcmFscy5cbiAqIEV4YW1wbGU6IDI5XG4gKi9cbmNvbnN0IGdldERheSA9IChsb2NhbGUsIHJlZlBhcnRzKSA9PiB7XG4gIHJldHVybiBnZXRMb2NhbGl6ZWREYXRlVGltZVBhcnRzKGxvY2FsZSwgcmVmUGFydHMsIHsgZGF5OiAnbnVtZXJpYycgfSkuZmluZCgob2JqKSA9PiBvYmoudHlwZSA9PT0gJ2RheScpLnZhbHVlO1xufTtcbi8qKlxuICogR2l2ZW4gYSBsb2NhbGUgYW5kIGEgZGF0ZSBvYmplY3QsXG4gKiByZXR1cm4gYSBmb3JtYXR0ZWQgc3RyaW5nIHRoYXQgaW5jbHVkZXNcbiAqIHRoZSBudW1lcmljIHllYXIuXG4gKiBFeGFtcGxlOiAyMDIyXG4gKi9cbmNvbnN0IGdldFllYXIgPSAobG9jYWxlLCByZWZQYXJ0cykgPT4ge1xuICByZXR1cm4gZ2V0TG9jYWxpemVkRGF0ZVRpbWUobG9jYWxlLCByZWZQYXJ0cywgeyB5ZWFyOiAnbnVtZXJpYycgfSk7XG59O1xuY29uc3QgZ2V0Tm9ybWFsaXplZERhdGUgPSAocmVmUGFydHMpID0+IHtcbiAgY29uc3QgdGltZVN0cmluZyA9IHJlZlBhcnRzLmhvdXIgIT09IHVuZGVmaW5lZCAmJiByZWZQYXJ0cy5taW51dGUgIT09IHVuZGVmaW5lZCA/IGAgJHtyZWZQYXJ0cy5ob3VyfToke3JlZlBhcnRzLm1pbnV0ZX1gIDogJyc7XG4gIHJldHVybiBuZXcgRGF0ZShgJHtyZWZQYXJ0cy5tb250aH0vJHtyZWZQYXJ0cy5kYXl9LyR7cmVmUGFydHMueWVhcn0ke3RpbWVTdHJpbmd9IEdNVCswMDAwYCk7XG59O1xuLyoqXG4gKiBHaXZlbiBhIGxvY2FsZSwgRGF0ZXRpbWVQYXJ0cywgYW5kIG9wdGlvbnNcbiAqIGZvcm1hdCB0aGUgRGF0ZXRpbWVQYXJ0cyBhY2NvcmRpbmcgdG8gdGhlIG9wdGlvbnNcbiAqIGFuZCBsb2NhbGUgY29tYmluYXRpb24uIFRoaXMgcmV0dXJucyBhIHN0cmluZy4gSWZcbiAqIHlvdSB3YW50IGFuIGFycmF5IG9mIHRoZSBpbmRpdmlkdWFsIHBpZWNlc1xuICogdGhhdCBtYWtlIHVwIHRoZSBsb2NhbGl6ZWQgZGF0ZSBzdHJpbmcsIHVzZVxuICogZ2V0TG9jYWxpemVkRGF0ZVRpbWVQYXJ0cy5cbiAqL1xuY29uc3QgZ2V0TG9jYWxpemVkRGF0ZVRpbWUgPSAobG9jYWxlLCByZWZQYXJ0cywgb3B0aW9ucykgPT4ge1xuICBjb25zdCBkYXRlID0gZ2V0Tm9ybWFsaXplZERhdGUocmVmUGFydHMpO1xuICByZXR1cm4gZ2V0RGF0ZVRpbWVGb3JtYXQobG9jYWxlLCBvcHRpb25zKS5mb3JtYXQoZGF0ZSk7XG59O1xuLyoqXG4gKiBHaXZlbiBhIGxvY2FsZSwgRGF0ZXRpbWVQYXJ0cywgYW5kIG9wdGlvbnNcbiAqIGZvcm1hdCB0aGUgRGF0ZXRpbWVQYXJ0cyBhY2NvcmRpbmcgdG8gdGhlIG9wdGlvbnNcbiAqIGFuZCBsb2NhbGUgY29tYmluYXRpb24uIFRoaXMgcmV0dXJucyBhbiBhcnJheSBvZlxuICogZWFjaCBwaWVjZSBvZiB0aGUgZGF0ZS5cbiAqL1xuY29uc3QgZ2V0TG9jYWxpemVkRGF0ZVRpbWVQYXJ0cyA9IChsb2NhbGUsIHJlZlBhcnRzLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IGRhdGUgPSBnZXROb3JtYWxpemVkRGF0ZShyZWZQYXJ0cyk7XG4gIHJldHVybiBnZXREYXRlVGltZUZvcm1hdChsb2NhbGUsIG9wdGlvbnMpLmZvcm1hdFRvUGFydHMoZGF0ZSk7XG59O1xuLyoqXG4gKiBXcmFwcGVyIGZ1bmN0aW9uIGZvciBJbnRsLkRhdGVUaW1lRm9ybWF0LlxuICogQWxsb3dzIGRldmVsb3BlcnMgdG8gYXBwbHkgYW4gYWxsb3dlZCBmb3JtYXQgdG8gRGF0ZXRpbWVQYXJ0cy5cbiAqIFRoaXMgZnVuY3Rpb24gYWxzbyBoYXMgYnVpbHQgaW4gc2FmZWd1YXJkcyBmb3Igb2xkZXIgYnJvd3NlciBidWdzXG4gKiB3aXRoIEludGwuRGF0ZVRpbWVGb3JtYXQuXG4gKi9cbmNvbnN0IGdldERhdGVUaW1lRm9ybWF0ID0gKGxvY2FsZSwgb3B0aW9ucykgPT4ge1xuICByZXR1cm4gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IHRpbWVab25lOiAnVVRDJyB9KSk7XG59O1xuLyoqXG4gKiBHZXRzIGEgbG9jYWxpemVkIHZlcnNpb24gb2YgXCJUb2RheVwiXG4gKiBGYWxscyBiYWNrIHRvIFwiVG9kYXlcIiBpbiBFbmdsaXNoIGZvclxuICogYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBSZWxhdGl2ZVRpbWVGb3JtYXQuXG4gKi9cbmNvbnN0IGdldFRvZGF5TGFiZWwgPSAobG9jYWxlKSA9PiB7XG4gIGlmICgnUmVsYXRpdmVUaW1lRm9ybWF0JyBpbiBJbnRsKSB7XG4gICAgY29uc3QgbGFiZWwgPSBuZXcgSW50bC5SZWxhdGl2ZVRpbWVGb3JtYXQobG9jYWxlLCB7IG51bWVyaWM6ICdhdXRvJyB9KS5mb3JtYXQoMCwgJ2RheScpO1xuICAgIHJldHVybiBsYWJlbC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGxhYmVsLnNsaWNlKDEpO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiAnVG9kYXknO1xuICB9XG59O1xuLyoqXG4gKiBXaGVuIGNhbGxpbmcgdG9JU09TdHJpbmcoKSwgdGhlIGJyb3dzZXJcbiAqIHdpbGwgY29udmVydCB0aGUgZGF0ZSB0byBVVEMgdGltZSBieSBlaXRoZXIgYWRkaW5nXG4gKiBvciBzdWJ0cmFjdGluZyB0aGUgdGltZSB6b25lIG9mZnNldC5cbiAqIFRvIHdvcmsgYXJvdW5kIHRoaXMsIHdlIG5lZWQgdG8gZWl0aGVyIGFkZFxuICogb3Igc3VidHJhY3QgdGhlIHRpbWUgem9uZSBvZmZzZXQgdG8gdGhlIERhdGVcbiAqIG9iamVjdCBwcmlvciB0byBjYWxsaW5nIHRvSVNPU3RyaW5nKCkuXG4gKiBUaGlzIGFsbG93cyB1cyB0byBnZXQgYW4gSVNPIHN0cmluZ1xuICogdGhhdCBpcyBpbiB0aGUgdXNlcidzIHRpbWUgem9uZS5cbiAqXG4gKiBFeGFtcGxlOlxuICogVGltZSB6b25lIG9mZnNldCBpcyAyNDBcbiAqIE1lYW5pbmc6IFRoZSBicm93c2VyIG5lZWRzIHRvIGFkZCAyNDAgbWludXRlc1xuICogdG8gdGhlIERhdGUgb2JqZWN0IHRvIGdldCBVVEMgdGltZS5cbiAqIFdoYXQgSW9uaWMgZG9lczogV2Ugc3VidHJhY3QgMjQwIG1pbnV0ZXNcbiAqIGZyb20gdGhlIERhdGUgb2JqZWN0LiBUaGUgYnJvd3NlciB0aGVuIGFkZHNcbiAqIDI0MCBtaW51dGVzIGluIHRvSVNPU3RyaW5nKCkuIFRoZSByZXN1bHRcbiAqIGlzIGEgdGltZSB0aGF0IGlzIGluIHRoZSB1c2VyJ3MgdGltZSB6b25lXG4gKiBhbmQgbm90IFVUQy5cbiAqXG4gKiBOb3RlOiBTb21lIHRpbWV6b25lcyBpbmNsdWRlIG1pbnV0ZSBhZGp1c3RtZW50c1xuICogc3VjaCBhcyAzMCBvciA0NSBtaW51dGVzLiBUaGlzIGlzIHdoeSB3ZSB1c2Ugc2V0TWludXRlc1xuICogaW5zdGVhZCBvZiBzZXRIb3Vycy5cbiAqIEV4YW1wbGU6IEluZGlhIFN0YW5kYXJkIFRpbWVcbiAqIFRpbWV6b25lIG9mZnNldDogLTMzMCA9IC01LjUgaG91cnMuXG4gKlxuICogTGlzdCBvZiB0aW1lem9uZXMgd2l0aCAzMCBhbmQgNDUgbWludXRlIHRpbWV6b25lczpcbiAqIGh0dHBzOi8vd3d3LnRpbWVhbmRkYXRlLmNvbS90aW1lL3RpbWUtem9uZXMtaW50ZXJlc3RpbmcuaHRtbFxuICovXG5jb25zdCByZW1vdmVEYXRlVHpPZmZzZXQgPSAoZGF0ZSkgPT4ge1xuICBjb25zdCB0ek9mZnNldCA9IGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgZGF0ZS5zZXRNaW51dGVzKGRhdGUuZ2V0TWludXRlcygpIC0gdHpPZmZzZXQpO1xuICByZXR1cm4gZGF0ZTtcbn07XG5jb25zdCBEQVRFX0FNID0gcmVtb3ZlRGF0ZVR6T2Zmc2V0KG5ldyBEYXRlKCcyMDIyVDAxOjAwJykpO1xuY29uc3QgREFURV9QTSA9IHJlbW92ZURhdGVUek9mZnNldChuZXcgRGF0ZSgnMjAyMlQxMzowMCcpKTtcbi8qKlxuICogRm9ybWF0cyB0aGUgbG9jYWxlJ3Mgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBkYXkgcGVyaW9kIChhbS9wbSkgZm9yIGEgZ2l2ZW5cbiAqIHJlZiBwYXJ0cyBkYXkgcGVyaW9kLlxuICpcbiAqIEBwYXJhbSBsb2NhbGUgVGhlIGxvY2FsZSB0byBmb3JtYXQgdGhlIGRheSBwZXJpb2QgaW4uXG4gKiBAcGFyYW0gdmFsdWUgVGhlIGRhdGUgc3RyaW5nLCBpbiBJU08gZm9ybWF0LlxuICogQHJldHVybnMgVGhlIGxvY2FsaXplZCBkYXkgcGVyaW9kIChhbS9wbSkgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIHZhbHVlLlxuICovXG5jb25zdCBnZXRMb2NhbGl6ZWREYXlQZXJpb2QgPSAobG9jYWxlLCBkYXlQZXJpb2QpID0+IHtcbiAgY29uc3QgZGF0ZSA9IGRheVBlcmlvZCA9PT0gJ2FtJyA/IERBVEVfQU0gOiBEQVRFX1BNO1xuICBjb25zdCBsb2NhbGl6ZWREYXlQZXJpb2QgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGUsIHtcbiAgICBob3VyOiAnbnVtZXJpYycsXG4gICAgdGltZVpvbmU6ICdVVEMnLFxuICB9KVxuICAgIC5mb3JtYXRUb1BhcnRzKGRhdGUpXG4gICAgLmZpbmQoKHBhcnQpID0+IHBhcnQudHlwZSA9PT0gJ2RheVBlcmlvZCcpO1xuICBpZiAobG9jYWxpemVkRGF5UGVyaW9kKSB7XG4gICAgcmV0dXJuIGxvY2FsaXplZERheVBlcmlvZC52YWx1ZTtcbiAgfVxuICByZXR1cm4gZ2V0Rm9ybWF0dGVkRGF5UGVyaW9kKGRheVBlcmlvZCk7XG59O1xuLyoqXG4gKiBGb3JtYXRzIHRoZSBkYXRldGltZSdzIHZhbHVlIHRvIGEgc3RyaW5nLCBmb3IgdXNlIGluIHRoZSBuYXRpdmUgaW5wdXQuXG4gKlxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBmb3JtYXQsIGVpdGhlciBhbiBJU08gc3RyaW5nIG9yIGFuIGFycmF5IHRoZXJlb2YuXG4gKi9cbmNvbnN0IGZvcm1hdFZhbHVlID0gKHZhbHVlKSA9PiB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLmpvaW4oJywnKSA6IHZhbHVlO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IGRhdGUgYXNcbiAqIGFuIElTTyBzdHJpbmcgaW4gdGhlIHVzZXInc1xuICogdGltZSB6b25lLlxuICovXG5jb25zdCBnZXRUb2RheSA9ICgpID0+IHtcbiAgLyoqXG4gICAqIGlvbi1kYXRldGltZSBpbnRlbnRpb25hbGx5IGRvZXMgbm90XG4gICAqIHBhcnNlIHRpbWUgem9uZXMvZG8gYXV0b21hdGljIHRpbWUgem9uZVxuICAgKiBjb252ZXJzaW9uIHdoZW4gYWNjZXB0aW5nIHVzZXIgaW5wdXQuXG4gICAqIEhvd2V2ZXIgd2hlbiB3ZSBnZXQgdG9kYXkncyBkYXRlIHN0cmluZyxcbiAgICogd2Ugd2FudCBpdCBmb3JtYXR0ZWQgcmVsYXRpdmUgdG8gdGhlIHVzZXInc1xuICAgKiB0aW1lIHpvbmUuXG4gICAqXG4gICAqIFdoZW4gY2FsbGluZyB0b0lTT1N0cmluZygpLCB0aGUgYnJvd3NlclxuICAgKiB3aWxsIGNvbnZlcnQgdGhlIGRhdGUgdG8gVVRDIHRpbWUgYnkgZWl0aGVyIGFkZGluZ1xuICAgKiBvciBzdWJ0cmFjdGluZyB0aGUgdGltZSB6b25lIG9mZnNldC5cbiAgICogVG8gd29yayBhcm91bmQgdGhpcywgd2UgbmVlZCB0byBlaXRoZXIgYWRkXG4gICAqIG9yIHN1YnRyYWN0IHRoZSB0aW1lIHpvbmUgb2Zmc2V0IHRvIHRoZSBEYXRlXG4gICAqIG9iamVjdCBwcmlvciB0byBjYWxsaW5nIHRvSVNPU3RyaW5nKCkuXG4gICAqIFRoaXMgYWxsb3dzIHVzIHRvIGdldCBhbiBJU08gc3RyaW5nXG4gICAqIHRoYXQgaXMgaW4gdGhlIHVzZXIncyB0aW1lIHpvbmUuXG4gICAqL1xuICByZXR1cm4gcmVtb3ZlRGF0ZVR6T2Zmc2V0KG5ldyBEYXRlKCkpLnRvSVNPU3RyaW5nKCk7XG59O1xuY29uc3QgbWludXRlcyA9IFtcbiAgMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSwgMTYsIDE3LCAxOCwgMTksIDIwLCAyMSwgMjIsIDIzLCAyNCwgMjUsIDI2LCAyNywgMjgsIDI5LCAzMCwgMzEsXG4gIDMyLCAzMywgMzQsIDM1LCAzNiwgMzcsIDM4LCAzOSwgNDAsIDQxLCA0MiwgNDMsIDQ0LCA0NSwgNDYsIDQ3LCA0OCwgNDksIDUwLCA1MSwgNTIsIDUzLCA1NCwgNTUsIDU2LCA1NywgNTgsIDU5LFxuXTtcbmNvbnN0IGhvdXIxMiA9IFswLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTFdO1xuY29uc3QgaG91cjIzID0gWzAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsIDE2LCAxNywgMTgsIDE5LCAyMCwgMjEsIDIyLCAyM107XG4vKipcbiAqIEdpdmVuIGEgbG9jYWxlIGFuZCBhIG1vZGUsXG4gKiByZXR1cm4gYW4gYXJyYXkgd2l0aCBmb3JtYXR0ZWQgZGF5c1xuICogb2YgdGhlIHdlZWsuIGlPUyBzaG91bGQgZGlzcGxheSBkYXlzXG4gKiBzdWNoIGFzIFwiTW9uXCIgb3IgXCJUdWVcIi5cbiAqIE1EIHNob3VsZCBkaXNwbGF5IGRheXMgc3VjaCBhcyBcIk1cIlxuICogb3IgXCJUXCIuXG4gKi9cbmNvbnN0IGdldERheXNPZldlZWsgPSAobG9jYWxlLCBtb2RlLCBmaXJzdERheU9mV2VlayA9IDApID0+IHtcbiAgLyoqXG4gICAqIE5vdiAxc3QsIDIwMjAgc3RhcnRzIG9uIGEgU3VuZGF5LlxuICAgKiBpb24tZGF0ZXRpbWUgYXNzdW1lcyB3ZWVrcyBzdGFydCBvbiBTdW5kYXksXG4gICAqIGJ1dCBpcyBjb25maWd1cmFibGUgdmlhIGBmaXJzdERheU9mV2Vla2AuXG4gICAqL1xuICBjb25zdCB3ZWVrZGF5Rm9ybWF0ID0gbW9kZSA9PT0gJ2lvcycgPyAnc2hvcnQnIDogJ25hcnJvdyc7XG4gIGNvbnN0IGludGwgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGUsIHsgd2Vla2RheTogd2Vla2RheUZvcm1hdCB9KTtcbiAgY29uc3Qgc3RhcnREYXRlID0gbmV3IERhdGUoJzExLzAxLzIwMjAnKTtcbiAgY29uc3QgZGF5c09mV2VlayA9IFtdO1xuICAvKipcbiAgICogRm9yIGVhY2ggZGF5IG9mIHRoZSB3ZWVrLFxuICAgKiBnZXQgdGhlIGRheSBuYW1lLlxuICAgKi9cbiAgZm9yIChsZXQgaSA9IGZpcnN0RGF5T2ZXZWVrOyBpIDwgZmlyc3REYXlPZldlZWsgKyA3OyBpKyspIHtcbiAgICBjb25zdCBjdXJyZW50RGF0ZSA9IG5ldyBEYXRlKHN0YXJ0RGF0ZSk7XG4gICAgY3VycmVudERhdGUuc2V0RGF0ZShjdXJyZW50RGF0ZS5nZXREYXRlKCkgKyBpKTtcbiAgICBkYXlzT2ZXZWVrLnB1c2goaW50bC5mb3JtYXQoY3VycmVudERhdGUpKTtcbiAgfVxuICByZXR1cm4gZGF5c09mV2Vlaztcbn07XG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyBhbGwgb2YgdGhlXG4gKiBkYXlzIGluIGEgbW9udGggZm9yIGEgZ2l2ZW4geWVhci4gVmFsdWVzIGFyZVxuICogYWxpZ25lZCB3aXRoIGEgd2VlayBjYWxlbmRhciBzdGFydGluZyBvblxuICogdGhlIGZpcnN0RGF5T2ZXZWVrIHZhbHVlIChTdW5kYXkgYnkgZGVmYXVsdClcbiAqIHVzaW5nIG51bGwgdmFsdWVzLlxuICovXG5jb25zdCBnZXREYXlzT2ZNb250aCA9IChtb250aCwgeWVhciwgZmlyc3REYXlPZldlZWspID0+IHtcbiAgY29uc3QgbnVtRGF5cyA9IGdldE51bURheXNJbk1vbnRoKG1vbnRoLCB5ZWFyKTtcbiAgY29uc3QgZmlyc3RPZk1vbnRoID0gbmV3IERhdGUoYCR7bW9udGh9LzEvJHt5ZWFyfWApLmdldERheSgpO1xuICAvKipcbiAgICogVG8gZ2V0IHRoZSBmaXJzdCBkYXkgb2YgdGhlIG1vbnRoIGFsaWduZWQgb24gdGhlIGNvcnJlY3RcbiAgICogZGF5IG9mIHRoZSB3ZWVrLCB3ZSBuZWVkIHRvIGRldGVybWluZSBob3cgbWFueSBcImZpbGxlclwiIGRheXNcbiAgICogdG8gZ2VuZXJhdGUuIFRoZXNlIGZpbGxlciBkYXlzIGFzIGVtcHR5L2Rpc2FibGVkIGJ1dHRvbnNcbiAgICogdGhhdCBmaWxsIHRoZSBzcGFjZSBvZiB0aGUgZGF5cyBvZiB0aGUgd2VlayBiZWZvcmUgdGhlIGZpcnN0XG4gICAqIG9mIHRoZSBtb250aC5cbiAgICpcbiAgICogVGhlcmUgYXJlIHR3byBjYXNlcyBoZXJlOlxuICAgKlxuICAgKiAxLiBJZiBmaXJzdE9mTW9udGggPSA0LCBmaXJzdERheU9mV2VlayA9IDAgdGhlbiB0aGUgb2Zmc2V0XG4gICAqIGlzICg0IC0gKDAgKyAxKSkgPSAzLiBTaW5jZSB0aGUgb2Zmc2V0IGxvb3AgZ29lcyBmcm9tIDAgdG8gMyBpbmNsdXNpdmUsXG4gICAqIHRoaXMgd2lsbCBnZW5lcmF0ZSA0IGZpbGxlciBkYXlzICgwLCAxLCAyLCAzKSwgYW5kIHRoZW4gZGF5IG9mIHdlZWsgNCB3aWxsIGhhdmVcbiAgICogdGhlIGZpcnN0IGRheSBvZiB0aGUgbW9udGguXG4gICAqXG4gICAqIDIuIElmIGZpcnN0T2ZNb250aCA9IDIsIGZpcnN0RGF5T2ZXZWVrID0gNCB0aGVuIHRoZSBvZmZzZXRcbiAgICogaXMgKDYgLSAoNCAtIDIpKSA9IDQuIFNpbmNlIHRoZSBvZmZzZXQgbG9vcCBnb2VzIGZyb20gMCB0byA0IGluY2x1c2l2ZSxcbiAgICogdGhpcyB3aWxsIGdlbmVyYXRlIDUgZmlsbGVyIGRheXMgKDAsIDEsIDIsIDMsIDQpLCBhbmQgdGhlbiBkYXkgb2Ygd2VlayA1IHdpbGwgaGF2ZVxuICAgKiB0aGUgZmlyc3QgZGF5IG9mIHRoZSBtb250aC5cbiAgICovXG4gIGNvbnN0IG9mZnNldCA9IGZpcnN0T2ZNb250aCA+PSBmaXJzdERheU9mV2VlayA/IGZpcnN0T2ZNb250aCAtIChmaXJzdERheU9mV2VlayArIDEpIDogNiAtIChmaXJzdERheU9mV2VlayAtIGZpcnN0T2ZNb250aCk7XG4gIGxldCBkYXlzID0gW107XG4gIGZvciAobGV0IGkgPSAxOyBpIDw9IG51bURheXM7IGkrKykge1xuICAgIGRheXMucHVzaCh7IGRheTogaSwgZGF5T2ZXZWVrOiAob2Zmc2V0ICsgaSkgJSA3IH0pO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDw9IG9mZnNldDsgaSsrKSB7XG4gICAgZGF5cyA9IFt7IGRheTogbnVsbCwgZGF5T2ZXZWVrOiBudWxsIH0sIC4uLmRheXNdO1xuICB9XG4gIHJldHVybiBkYXlzO1xufTtcbi8qKlxuICogR2l2ZW4gYSBsb2NhbCwgcmVmZXJlbmNlIGRhdGV0aW1lIHBhcnRzIGFuZCBvcHRpb25cbiAqIG1heC9taW4gYm91bmQgZGF0ZXRpbWUgcGFydHMsIGNhbGN1bGF0ZSB0aGUgYWNjZXB0YWJsZVxuICogaG91ciBhbmQgbWludXRlIHZhbHVlcyBhY2NvcmRpbmcgdG8gdGhlIGJvdW5kcyBhbmQgbG9jYWxlLlxuICovXG5jb25zdCBnZW5lcmF0ZVRpbWUgPSAocmVmUGFydHMsIGhvdXJDeWNsZSA9ICdoMTInLCBtaW5QYXJ0cywgbWF4UGFydHMsIGhvdXJWYWx1ZXMsIG1pbnV0ZVZhbHVlcykgPT4ge1xuICBjb25zdCB1c2UyNEhvdXIgPSBob3VyQ3ljbGUgPT09ICdoMjMnO1xuICBsZXQgcHJvY2Vzc2VkSG91cnMgPSB1c2UyNEhvdXIgPyBob3VyMjMgOiBob3VyMTI7XG4gIGxldCBwcm9jZXNzZWRNaW51dGVzID0gbWludXRlcztcbiAgbGV0IGlzQU1BbGxvd2VkID0gdHJ1ZTtcbiAgbGV0IGlzUE1BbGxvd2VkID0gdHJ1ZTtcbiAgaWYgKGhvdXJWYWx1ZXMpIHtcbiAgICBwcm9jZXNzZWRIb3VycyA9IHByb2Nlc3NlZEhvdXJzLmZpbHRlcigoaG91cikgPT4gaG91clZhbHVlcy5pbmNsdWRlcyhob3VyKSk7XG4gIH1cbiAgaWYgKG1pbnV0ZVZhbHVlcykge1xuICAgIHByb2Nlc3NlZE1pbnV0ZXMgPSBwcm9jZXNzZWRNaW51dGVzLmZpbHRlcigobWludXRlKSA9PiBtaW51dGVWYWx1ZXMuaW5jbHVkZXMobWludXRlKSk7XG4gIH1cbiAgaWYgKG1pblBhcnRzKSB7XG4gICAgLyoqXG4gICAgICogSWYgcmVmIGRheSBpcyB0aGUgc2FtZSBhcyB0aGVcbiAgICAgKiBtaW5pbXVtIGFsbG93ZWQgZGF5LCBmaWx0ZXIgaG91ci9taW51dGVcbiAgICAgKiB2YWx1ZXMgYWNjb3JkaW5nIHRvIG1pbiBob3VyIGFuZCBtaW51dGUuXG4gICAgICovXG4gICAgaWYgKGlzU2FtZURheShyZWZQYXJ0cywgbWluUGFydHMpKSB7XG4gICAgICAvKipcbiAgICAgICAqIFVzZXJzIG1heSBub3QgYWx3YXlzIHNldCB0aGUgaG91ci9taW51dGUgZm9yXG4gICAgICAgKiBtaW4gdmFsdWUgKGkuZS4gMjAyMS0wNi0wMikgc28gd2Ugc2hvdWxkIGFsbG93XG4gICAgICAgKiBhbGwgaG91cnMvbWludXRlcyBpbiB0aGF0IGNhc2UuXG4gICAgICAgKi9cbiAgICAgIGlmIChtaW5QYXJ0cy5ob3VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvY2Vzc2VkSG91cnMgPSBwcm9jZXNzZWRIb3Vycy5maWx0ZXIoKGhvdXIpID0+IHtcbiAgICAgICAgICBjb25zdCBjb252ZXJ0ZWRIb3VyID0gcmVmUGFydHMuYW1wbSA9PT0gJ3BtJyA/IChob3VyICsgMTIpICUgMjQgOiBob3VyO1xuICAgICAgICAgIHJldHVybiAodXNlMjRIb3VyID8gaG91ciA6IGNvbnZlcnRlZEhvdXIpID49IG1pblBhcnRzLmhvdXI7XG4gICAgICAgIH0pO1xuICAgICAgICBpc0FNQWxsb3dlZCA9IG1pblBhcnRzLmhvdXIgPCAxMztcbiAgICAgIH1cbiAgICAgIGlmIChtaW5QYXJ0cy5taW51dGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1pbmltdW0gbWludXRlIHJhbmdlIHNob3VsZCBub3QgYmUgZW5mb3JjZWQgd2hlblxuICAgICAgICAgKiB0aGUgaG91ciBpcyBncmVhdGVyIHRoYW4gdGhlIG1pbiBob3VyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgZXhhbXBsZSB3aXRoIGEgbWluaW11bSByYW5nZSBvZiAwOTozMCwgdXNlcnNcbiAgICAgICAgICogc2hvdWxkIGJlIGFibGUgdG8gc2VsZWN0IDEwOjAwLTEwOjI5IGFuZCBiZXlvbmQuXG4gICAgICAgICAqL1xuICAgICAgICBsZXQgaXNQYXN0TWluSG91ciA9IGZhbHNlO1xuICAgICAgICBpZiAobWluUGFydHMuaG91ciAhPT0gdW5kZWZpbmVkICYmIHJlZlBhcnRzLmhvdXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChyZWZQYXJ0cy5ob3VyID4gbWluUGFydHMuaG91cikge1xuICAgICAgICAgICAgaXNQYXN0TWluSG91ciA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3NlZE1pbnV0ZXMgPSBwcm9jZXNzZWRNaW51dGVzLmZpbHRlcigobWludXRlKSA9PiB7XG4gICAgICAgICAgaWYgKGlzUGFzdE1pbkhvdXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWludXRlID49IG1pblBhcnRzLm1pbnV0ZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIElmIHJlZiBkYXkgaXMgYmVmb3JlIG1pbmltdW1cbiAgICAgICAqIGRheSBkbyBub3QgcmVuZGVyIGFueSBob3Vycy9taW51dGUgdmFsdWVzXG4gICAgICAgKi9cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNCZWZvcmUocmVmUGFydHMsIG1pblBhcnRzKSkge1xuICAgICAgcHJvY2Vzc2VkSG91cnMgPSBbXTtcbiAgICAgIHByb2Nlc3NlZE1pbnV0ZXMgPSBbXTtcbiAgICAgIGlzQU1BbGxvd2VkID0gaXNQTUFsbG93ZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKG1heFBhcnRzKSB7XG4gICAgLyoqXG4gICAgICogSWYgcmVmIGRheSBpcyB0aGUgc2FtZSBhcyB0aGVcbiAgICAgKiBtYXhpbXVtIGFsbG93ZWQgZGF5LCBmaWx0ZXIgaG91ci9taW51dGVcbiAgICAgKiB2YWx1ZXMgYWNjb3JkaW5nIHRvIG1heCBob3VyIGFuZCBtaW51dGUuXG4gICAgICovXG4gICAgaWYgKGlzU2FtZURheShyZWZQYXJ0cywgbWF4UGFydHMpKSB7XG4gICAgICAvKipcbiAgICAgICAqIFVzZXJzIG1heSBub3QgYWx3YXlzIHNldCB0aGUgaG91ci9taW51dGUgZm9yXG4gICAgICAgKiBtYXggdmFsdWUgKGkuZS4gMjAyMS0wNi0wMikgc28gd2Ugc2hvdWxkIGFsbG93XG4gICAgICAgKiBhbGwgaG91cnMvbWludXRlcyBpbiB0aGF0IGNhc2UuXG4gICAgICAgKi9cbiAgICAgIGlmIChtYXhQYXJ0cy5ob3VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvY2Vzc2VkSG91cnMgPSBwcm9jZXNzZWRIb3Vycy5maWx0ZXIoKGhvdXIpID0+IHtcbiAgICAgICAgICBjb25zdCBjb252ZXJ0ZWRIb3VyID0gcmVmUGFydHMuYW1wbSA9PT0gJ3BtJyA/IChob3VyICsgMTIpICUgMjQgOiBob3VyO1xuICAgICAgICAgIHJldHVybiAodXNlMjRIb3VyID8gaG91ciA6IGNvbnZlcnRlZEhvdXIpIDw9IG1heFBhcnRzLmhvdXI7XG4gICAgICAgIH0pO1xuICAgICAgICBpc1BNQWxsb3dlZCA9IG1heFBhcnRzLmhvdXIgPj0gMTI7XG4gICAgICB9XG4gICAgICBpZiAobWF4UGFydHMubWludXRlICE9PSB1bmRlZmluZWQgJiYgcmVmUGFydHMuaG91ciA9PT0gbWF4UGFydHMuaG91cikge1xuICAgICAgICAvLyBUaGUgYXZhaWxhYmxlIG1pbnV0ZXMgc2hvdWxkIG9ubHkgYmUgZmlsdGVyZWQgd2hlbiB0aGUgaG91ciBpcyB0aGUgc2FtZSBhcyB0aGUgbWF4IGhvdXIuXG4gICAgICAgIC8vIEZvciBleGFtcGxlIGlmIHRoZSBtYXggaG91ciBpcyAxMDozMCBhbmQgdGhlIGN1cnJlbnQgaG91ciBpcyAxMDowMCxcbiAgICAgICAgLy8gdXNlcnMgc2hvdWxkIGJlIGFibGUgdG8gc2VsZWN0IDAwLTMwIG1pbnV0ZXMuXG4gICAgICAgIC8vIElmIHRoZSBjdXJyZW50IGhvdXIgaXMgMDk6MDAsIHVzZXJzIHNob3VsZCBiZSBhYmxlIHRvIHNlbGVjdCAwMC02MCBtaW51dGVzLlxuICAgICAgICBwcm9jZXNzZWRNaW51dGVzID0gcHJvY2Vzc2VkTWludXRlcy5maWx0ZXIoKG1pbnV0ZSkgPT4gbWludXRlIDw9IG1heFBhcnRzLm1pbnV0ZSk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIElmIHJlZiBkYXkgaXMgYWZ0ZXIgbWluaW11bVxuICAgICAgICogZGF5IGRvIG5vdCByZW5kZXIgYW55IGhvdXJzL21pbnV0ZSB2YWx1ZXNcbiAgICAgICAqL1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0FmdGVyKHJlZlBhcnRzLCBtYXhQYXJ0cykpIHtcbiAgICAgIHByb2Nlc3NlZEhvdXJzID0gW107XG4gICAgICBwcm9jZXNzZWRNaW51dGVzID0gW107XG4gICAgICBpc0FNQWxsb3dlZCA9IGlzUE1BbGxvd2VkID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgaG91cnM6IHByb2Nlc3NlZEhvdXJzLFxuICAgIG1pbnV0ZXM6IHByb2Nlc3NlZE1pbnV0ZXMsXG4gICAgYW06IGlzQU1BbGxvd2VkLFxuICAgIHBtOiBpc1BNQWxsb3dlZCxcbiAgfTtcbn07XG4vKipcbiAqIEdpdmVuIERhdGV0aW1lUGFydHMsIGdlbmVyYXRlIHRoZSBwcmV2aW91cyxcbiAqIGN1cnJlbnQsIGFuZCBhbmQgbmV4dCBtb250aHMuXG4gKi9cbmNvbnN0IGdlbmVyYXRlTW9udGhzID0gKHJlZlBhcnRzKSA9PiB7XG4gIHJldHVybiBbXG4gICAgZ2V0UHJldmlvdXNNb250aChyZWZQYXJ0cyksXG4gICAgeyBtb250aDogcmVmUGFydHMubW9udGgsIHllYXI6IHJlZlBhcnRzLnllYXIsIGRheTogcmVmUGFydHMuZGF5IH0sXG4gICAgZ2V0TmV4dE1vbnRoKHJlZlBhcnRzKSxcbiAgXTtcbn07XG5jb25zdCBnZXRNb250aENvbHVtbkRhdGEgPSAobG9jYWxlLCByZWZQYXJ0cywgbWluUGFydHMsIG1heFBhcnRzLCBtb250aFZhbHVlcywgZm9ybWF0T3B0aW9ucyA9IHtcbiAgbW9udGg6ICdsb25nJyxcbn0pID0+IHtcbiAgY29uc3QgeyB5ZWFyIH0gPSByZWZQYXJ0cztcbiAgY29uc3QgbW9udGhzID0gW107XG4gIGlmIChtb250aFZhbHVlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbGV0IHByb2Nlc3NlZE1vbnRocyA9IG1vbnRoVmFsdWVzO1xuICAgIGlmICgobWF4UGFydHMgPT09IG51bGwgfHwgbWF4UGFydHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1heFBhcnRzLm1vbnRoKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwcm9jZXNzZWRNb250aHMgPSBwcm9jZXNzZWRNb250aHMuZmlsdGVyKChtb250aCkgPT4gbW9udGggPD0gbWF4UGFydHMubW9udGgpO1xuICAgIH1cbiAgICBpZiAoKG1pblBhcnRzID09PSBudWxsIHx8IG1pblBhcnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtaW5QYXJ0cy5tb250aCkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcHJvY2Vzc2VkTW9udGhzID0gcHJvY2Vzc2VkTW9udGhzLmZpbHRlcigobW9udGgpID0+IG1vbnRoID49IG1pblBhcnRzLm1vbnRoKTtcbiAgICB9XG4gICAgcHJvY2Vzc2VkTW9udGhzLmZvckVhY2goKHByb2Nlc3NlZE1vbnRoKSA9PiB7XG4gICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoYCR7cHJvY2Vzc2VkTW9udGh9LzEvJHt5ZWFyfSBHTVQrMDAwMGApO1xuICAgICAgY29uc3QgbW9udGhTdHJpbmcgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGUsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZm9ybWF0T3B0aW9ucyksIHsgdGltZVpvbmU6ICdVVEMnIH0pKS5mb3JtYXQoZGF0ZSk7XG4gICAgICBtb250aHMucHVzaCh7IHRleHQ6IG1vbnRoU3RyaW5nLCB2YWx1ZTogcHJvY2Vzc2VkTW9udGggfSk7XG4gICAgfSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgY29uc3QgbWF4TW9udGggPSBtYXhQYXJ0cyAmJiBtYXhQYXJ0cy55ZWFyID09PSB5ZWFyID8gbWF4UGFydHMubW9udGggOiAxMjtcbiAgICBjb25zdCBtaW5Nb250aCA9IG1pblBhcnRzICYmIG1pblBhcnRzLnllYXIgPT09IHllYXIgPyBtaW5QYXJ0cy5tb250aCA6IDE7XG4gICAgZm9yIChsZXQgaSA9IG1pbk1vbnRoOyBpIDw9IG1heE1vbnRoOyBpKyspIHtcbiAgICAgIC8qKlxuICAgICAgICpcbiAgICAgICAqIFRoZXJlIGlzIGEgYnVnIG9uIGlPUyAxNCB3aGVyZVxuICAgICAgICogSW50bC5EYXRlVGltZUZvcm1hdCB0YWtlcyBpbnRvIGFjY291bnRcbiAgICAgICAqIHRoZSBsb2NhbCB0aW1lem9uZSBvZmZzZXQgd2hlbiBmb3JtYXR0aW5nIGRhdGVzLlxuICAgICAgICpcbiAgICAgICAqIEZvcmNpbmcgdGhlIHRpbWV6b25lIHRvICdVVEMnIGZpeGVzIHRoZSBpc3N1ZS4gSG93ZXZlcixcbiAgICAgICAqIHdlIHNob3VsZCBrZWVwIHRoaXMgd29ya2Fyb3VuZCBhcyBpdCBpcyBzYWZlci4gSW4gdGhlIGV2ZW50XG4gICAgICAgKiB0aGlzIGJyZWFrcyBpbiBhbm90aGVyIGJyb3dzZXIsIHdlIHdpbGwgbm90IGJlIGltcGFjdGVkXG4gICAgICAgKiBiZWNhdXNlIGFsbCBkYXRlcyB3aWxsIGJlIGludGVycHJldGVkIGluIFVUQy5cbiAgICAgICAqXG4gICAgICAgKiBFeGFtcGxlOlxuICAgICAgICogbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoJ2VuLVVTJywgeyBtb250aDogJ2xvbmcnIH0pLmZvcm1hdChuZXcgRGF0ZSgnU2F0IEFwciAwMSAyMDA2IDAwOjAwOjAwIEdNVC0wNDAwIChFRFQpJykpIC8vIFwiTWFyY2hcIlxuICAgICAgICogbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoJ2VuLVVTJywgeyBtb250aDogJ2xvbmcnLCB0aW1lWm9uZTogJ1VUQycgfSkuZm9ybWF0KG5ldyBEYXRlKCdTYXQgQXByIDAxIDIwMDYgMDA6MDA6MDAgR01ULTA0MDAgKEVEVCknKSkgLy8gXCJBcHJpbFwiXG4gICAgICAgKlxuICAgICAgICogSW4gY2VydGFpbiB0aW1lem9uZXMsIGlPUyAxNCBzaG93cyB0aGUgd3JvbmdcbiAgICAgICAqIGRhdGUgZm9yIC50b1VUQ1N0cmluZygpLiBUbyBjb21iYXQgdGhpcywgd2VcbiAgICAgICAqIGZvcmNlIGFsbCBvZiB0aGUgdGltZXpvbmVzIHRvIEdNVCswMDAwIChVVEMpLlxuICAgICAgICpcbiAgICAgICAqIEV4YW1wbGU6XG4gICAgICAgKiBUaW1lIFpvbmU6IENlbnRyYWwgRXVyb3BlYW4gU3RhbmRhcmQgVGltZVxuICAgICAgICogbmV3IERhdGUoJzEvMS8xOTkyJykudG9VVENTdHJpbmcoKSAvLyBcIlR1ZSwgMzEgRGVjIDE5OTEgMjM6MDA6MDAgR01UXCJcbiAgICAgICAqIG5ldyBEYXRlKCcxLzEvMTk5MiBHTVQrMDAwMCcpLnRvVVRDU3RyaW5nKCkgLy8gXCJXZWQsIDAxIEphbiAxOTkyIDAwOjAwOjAwIEdNVFwiXG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShgJHtpfS8xLyR7eWVhcn0gR01UKzAwMDBgKTtcbiAgICAgIGNvbnN0IG1vbnRoU3RyaW5nID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGZvcm1hdE9wdGlvbnMpLCB7IHRpbWVab25lOiAnVVRDJyB9KSkuZm9ybWF0KGRhdGUpO1xuICAgICAgbW9udGhzLnB1c2goeyB0ZXh0OiBtb250aFN0cmluZywgdmFsdWU6IGkgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtb250aHM7XG59O1xuLyoqXG4gKiBSZXR1cm5zIGluZm9ybWF0aW9uIHJlZ2FyZGluZ1xuICogc2VsZWN0YWJsZSBkYXRlcyAoaS5lIDFzdCwgMm5kLCAzcmQsIGV0YylcbiAqIHdpdGhpbiBhIHJlZmVyZW5jZSBtb250aC5cbiAqIEBwYXJhbSBsb2NhbGUgVGhlIGxvY2FsZSB0byBmb3JtYXQgdGhlIGRhdGUgd2l0aFxuICogQHBhcmFtIHJlZlBhcnRzIFRoZSByZWZlcmVuY2UgbW9udGgveWVhciB0byBnZW5lcmF0ZSBkYXRlcyBmb3JcbiAqIEBwYXJhbSBtaW5QYXJ0cyBUaGUgbWluaW11bSBib3VuZCBvbiB0aGUgZGF0ZSB0aGF0IGNhbiBiZSByZXR1cm5lZFxuICogQHBhcmFtIG1heFBhcnRzIFRoZSBtYXhpbXVtIGJvdW5kIG9uIHRoZSBkYXRlIHRoYXQgY2FuIGJlIHJldHVybmVkXG4gKiBAcGFyYW0gZGF5VmFsdWVzIFRoZSBhbGxvd2VkIGRhdGUgdmFsdWVzXG4gKiBAcmV0dXJucyBEYXRlIGRhdGEgdG8gYmUgdXNlZCBpbiBpb24tcGlja2VyLWNvbHVtbi1pbnRlcm5hbFxuICovXG5jb25zdCBnZXREYXlDb2x1bW5EYXRhID0gKGxvY2FsZSwgcmVmUGFydHMsIG1pblBhcnRzLCBtYXhQYXJ0cywgZGF5VmFsdWVzLCBmb3JtYXRPcHRpb25zID0ge1xuICBkYXk6ICdudW1lcmljJyxcbn0pID0+IHtcbiAgY29uc3QgeyBtb250aCwgeWVhciB9ID0gcmVmUGFydHM7XG4gIGNvbnN0IGRheXMgPSBbXTtcbiAgLyoqXG4gICAqIElmIHdlIGhhdmUgbWF4L21pbiBib3VuZHMgdGhhdCBpbiB0aGUgc2FtZVxuICAgKiBtb250aC95ZWFyIGFzIHRoZSByZWZQYXJ0cywgd2Ugc2hvdWxkXG4gICAqIHVzZSB0aGUgZGVmaW5lIGRheSBhcyB0aGUgbWF4L21pbiBkYXkuXG4gICAqIE90aGVyd2lzZSwgZmFsbGJhY2sgdG8gdGhlIG1heC9taW4gZGF5cyBpbiBhIG1vbnRoLlxuICAgKi9cbiAgY29uc3QgbnVtRGF5c0luTW9udGggPSBnZXROdW1EYXlzSW5Nb250aChtb250aCwgeWVhcik7XG4gIGNvbnN0IG1heERheSA9IChtYXhQYXJ0cyA9PT0gbnVsbCB8fCBtYXhQYXJ0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWF4UGFydHMuZGF5KSAhPT0gbnVsbCAmJiAobWF4UGFydHMgPT09IG51bGwgfHwgbWF4UGFydHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1heFBhcnRzLmRheSkgIT09IHVuZGVmaW5lZCAmJiBtYXhQYXJ0cy55ZWFyID09PSB5ZWFyICYmIG1heFBhcnRzLm1vbnRoID09PSBtb250aFxuICAgID8gbWF4UGFydHMuZGF5XG4gICAgOiBudW1EYXlzSW5Nb250aDtcbiAgY29uc3QgbWluRGF5ID0gKG1pblBhcnRzID09PSBudWxsIHx8IG1pblBhcnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtaW5QYXJ0cy5kYXkpICE9PSBudWxsICYmIChtaW5QYXJ0cyA9PT0gbnVsbCB8fCBtaW5QYXJ0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWluUGFydHMuZGF5KSAhPT0gdW5kZWZpbmVkICYmIG1pblBhcnRzLnllYXIgPT09IHllYXIgJiYgbWluUGFydHMubW9udGggPT09IG1vbnRoXG4gICAgPyBtaW5QYXJ0cy5kYXlcbiAgICA6IDE7XG4gIGlmIChkYXlWYWx1ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIGxldCBwcm9jZXNzZWREYXlzID0gZGF5VmFsdWVzO1xuICAgIHByb2Nlc3NlZERheXMgPSBwcm9jZXNzZWREYXlzLmZpbHRlcigoZGF5KSA9PiBkYXkgPj0gbWluRGF5ICYmIGRheSA8PSBtYXhEYXkpO1xuICAgIHByb2Nlc3NlZERheXMuZm9yRWFjaCgocHJvY2Vzc2VkRGF5KSA9PiB7XG4gICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoYCR7bW9udGh9LyR7cHJvY2Vzc2VkRGF5fS8ke3llYXJ9IEdNVCswMDAwYCk7XG4gICAgICBjb25zdCBkYXlTdHJpbmcgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGUsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZm9ybWF0T3B0aW9ucyksIHsgdGltZVpvbmU6ICdVVEMnIH0pKS5mb3JtYXQoZGF0ZSk7XG4gICAgICBkYXlzLnB1c2goeyB0ZXh0OiBkYXlTdHJpbmcsIHZhbHVlOiBwcm9jZXNzZWREYXkgfSk7XG4gICAgfSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgZm9yIChsZXQgaSA9IG1pbkRheTsgaSA8PSBtYXhEYXk7IGkrKykge1xuICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGAke21vbnRofS8ke2l9LyR7eWVhcn0gR01UKzAwMDBgKTtcbiAgICAgIGNvbnN0IGRheVN0cmluZyA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmb3JtYXRPcHRpb25zKSwgeyB0aW1lWm9uZTogJ1VUQycgfSkpLmZvcm1hdChkYXRlKTtcbiAgICAgIGRheXMucHVzaCh7IHRleHQ6IGRheVN0cmluZywgdmFsdWU6IGkgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXlzO1xufTtcbmNvbnN0IGdldFllYXJDb2x1bW5EYXRhID0gKGxvY2FsZSwgcmVmUGFydHMsIG1pblBhcnRzLCBtYXhQYXJ0cywgeWVhclZhbHVlcykgPT4ge1xuICB2YXIgX2EsIF9iO1xuICBsZXQgcHJvY2Vzc2VkWWVhcnMgPSBbXTtcbiAgaWYgKHllYXJWYWx1ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIHByb2Nlc3NlZFllYXJzID0geWVhclZhbHVlcztcbiAgICBpZiAoKG1heFBhcnRzID09PSBudWxsIHx8IG1heFBhcnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXhQYXJ0cy55ZWFyKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwcm9jZXNzZWRZZWFycyA9IHByb2Nlc3NlZFllYXJzLmZpbHRlcigoeWVhcikgPT4geWVhciA8PSBtYXhQYXJ0cy55ZWFyKTtcbiAgICB9XG4gICAgaWYgKChtaW5QYXJ0cyA9PT0gbnVsbCB8fCBtaW5QYXJ0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWluUGFydHMueWVhcikgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcHJvY2Vzc2VkWWVhcnMgPSBwcm9jZXNzZWRZZWFycy5maWx0ZXIoKHllYXIpID0+IHllYXIgPj0gbWluUGFydHMueWVhcik7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIGNvbnN0IHsgeWVhciB9ID0gcmVmUGFydHM7XG4gICAgY29uc3QgbWF4WWVhciA9IChfYSA9IG1heFBhcnRzID09PSBudWxsIHx8IG1heFBhcnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXhQYXJ0cy55ZWFyKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB5ZWFyO1xuICAgIGNvbnN0IG1pblllYXIgPSAoX2IgPSBtaW5QYXJ0cyA9PT0gbnVsbCB8fCBtaW5QYXJ0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWluUGFydHMueWVhcikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogeWVhciAtIDEwMDtcbiAgICBmb3IgKGxldCBpID0gbWF4WWVhcjsgaSA+PSBtaW5ZZWFyOyBpLS0pIHtcbiAgICAgIHByb2Nlc3NlZFllYXJzLnB1c2goaSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwcm9jZXNzZWRZZWFycy5tYXAoKHllYXIpID0+ICh7XG4gICAgdGV4dDogZ2V0WWVhcihsb2NhbGUsIHsgeWVhciwgbW9udGg6IHJlZlBhcnRzLm1vbnRoLCBkYXk6IHJlZlBhcnRzLmRheSB9KSxcbiAgICB2YWx1ZTogeWVhcixcbiAgfSkpO1xufTtcbi8qKlxuICogR2l2ZW4gYSBzdGFydGluZyBkYXRlIGFuZCBhbiB1cHBlciBib3VuZCxcbiAqIHRoaXMgZnVuY3Rpb25zIHJldHVybnMgYW4gYXJyYXkgb2YgYWxsXG4gKiBtb250aCBvYmplY3RzIGluIHRoYXQgcmFuZ2UuXG4gKi9cbmNvbnN0IGdldEFsbE1vbnRoc0luUmFuZ2UgPSAoY3VycmVudFBhcnRzLCBtYXhQYXJ0cykgPT4ge1xuICBpZiAoY3VycmVudFBhcnRzLm1vbnRoID09PSBtYXhQYXJ0cy5tb250aCAmJiBjdXJyZW50UGFydHMueWVhciA9PT0gbWF4UGFydHMueWVhcikge1xuICAgIHJldHVybiBbY3VycmVudFBhcnRzXTtcbiAgfVxuICByZXR1cm4gW2N1cnJlbnRQYXJ0cywgLi4uZ2V0QWxsTW9udGhzSW5SYW5nZShnZXROZXh0TW9udGgoY3VycmVudFBhcnRzKSwgbWF4UGFydHMpXTtcbn07XG4vKipcbiAqIENyZWF0ZXMgYW5kIHJldHVybnMgcGlja2VyIGl0ZW1zXG4gKiB0aGF0IHJlcHJlc2VudCB0aGUgZGF5cyBpbiBhIG1vbnRoLlxuICogRXhhbXBsZTogXCJUaHUsIEp1biAyXCJcbiAqL1xuY29uc3QgZ2V0Q29tYmluZWREYXRlQ29sdW1uRGF0YSA9IChsb2NhbGUsIHRvZGF5UGFydHMsIG1pblBhcnRzLCBtYXhQYXJ0cywgZGF5VmFsdWVzLCBtb250aFZhbHVlcykgPT4ge1xuICBsZXQgaXRlbXMgPSBbXTtcbiAgbGV0IHBhcnRzID0gW107XG4gIC8qKlxuICAgKiBHZXQgYWxsIG1vbnRoIG9iamVjdHMgZnJvbSB0aGUgbWluIGRhdGVcbiAgICogdG8gdGhlIG1heCBkYXRlLiBOb3RlOiBEbyBub3QgdXNlIGdldE1vbnRoQ29sdW1uRGF0YVxuICAgKiBhcyB0aGF0IGZ1bmN0aW9uIG9ubHkgZ2VuZXJhdGVzIGRhdGVzIHdpdGhpbiBhXG4gICAqIHNpbmdsZSB5ZWFyLlxuICAgKi9cbiAgbGV0IG1vbnRocyA9IGdldEFsbE1vbnRoc0luUmFuZ2UobWluUGFydHMsIG1heFBhcnRzKTtcbiAgLyoqXG4gICAqIEZpbHRlciBvdXQgYW55IGRpc2FsbG93ZWQgbW9udGggdmFsdWVzLlxuICAgKi9cbiAgaWYgKG1vbnRoVmFsdWVzKSB7XG4gICAgbW9udGhzID0gbW9udGhzLmZpbHRlcigoeyBtb250aCB9KSA9PiBtb250aFZhbHVlcy5pbmNsdWRlcyhtb250aCkpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYWxsIG9mIHRoZSBkYXlzIGluIHRoZSBtb250aC5cbiAgICogRnJvbSB0aGVyZSwgZ2VuZXJhdGUgYW4gYXJyYXkgd2hlcmVcbiAgICogZWFjaCBpdGVtIGhhcyB0aGUgbW9udGgsIGRhdGUsIGFuZCBkYXlcbiAgICogb2Ygd29yayBhcyB0aGUgdGV4dC5cbiAgICovXG4gIG1vbnRocy5mb3JFYWNoKChtb250aE9iamVjdCkgPT4ge1xuICAgIGNvbnN0IHJlZmVyZW5jZU1vbnRoID0geyBtb250aDogbW9udGhPYmplY3QubW9udGgsIGRheTogbnVsbCwgeWVhcjogbW9udGhPYmplY3QueWVhciB9O1xuICAgIGNvbnN0IG1vbnRoRGF5cyA9IGdldERheUNvbHVtbkRhdGEobG9jYWxlLCByZWZlcmVuY2VNb250aCwgbWluUGFydHMsIG1heFBhcnRzLCBkYXlWYWx1ZXMsIHtcbiAgICAgIG1vbnRoOiAnc2hvcnQnLFxuICAgICAgZGF5OiAnbnVtZXJpYycsXG4gICAgICB3ZWVrZGF5OiAnc2hvcnQnLFxuICAgIH0pO1xuICAgIGNvbnN0IGRhdGVQYXJ0cyA9IFtdO1xuICAgIGNvbnN0IGRhdGVDb2x1bW5JdGVtcyA9IFtdO1xuICAgIG1vbnRoRGF5cy5mb3JFYWNoKChkYXlPYmplY3QpID0+IHtcbiAgICAgIGNvbnN0IGlzVG9kYXkgPSBpc1NhbWVEYXkoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZWZlcmVuY2VNb250aCksIHsgZGF5OiBkYXlPYmplY3QudmFsdWUgfSksIHRvZGF5UGFydHMpO1xuICAgICAgLyoqXG4gICAgICAgKiBUb2RheSdzIGRhdGUgc2hvdWxkIHJlYWQgYXMgXCJUb2RheVwiIChsb2NhbGl6ZWQpXG4gICAgICAgKiBub3QgdGhlIGFjdHVhbCBkYXRlIHN0cmluZ1xuICAgICAgICovXG4gICAgICBkYXRlQ29sdW1uSXRlbXMucHVzaCh7XG4gICAgICAgIHRleHQ6IGlzVG9kYXkgPyBnZXRUb2RheUxhYmVsKGxvY2FsZSkgOiBkYXlPYmplY3QudGV4dCxcbiAgICAgICAgdmFsdWU6IGAke3JlZmVyZW5jZU1vbnRoLnllYXJ9LSR7cmVmZXJlbmNlTW9udGgubW9udGh9LSR7ZGF5T2JqZWN0LnZhbHVlfWAsXG4gICAgICB9KTtcbiAgICAgIC8qKlxuICAgICAgICogV2hlbiBzZWxlY3RpbmcgYSBkYXRlIGluIHRoZSB3aGVlbCBwaWNrZXJcbiAgICAgICAqIHdlIG5lZWQgYWNjZXNzIHRvIHRoZSByYXcgZGF0ZXRpbWUgcGFydHMgZGF0YS5cbiAgICAgICAqIFRoZSBwaWNrZXIgY29sdW1uIG9ubHkgYWNjZXB0cyB2YWx1ZXMgb2ZcbiAgICAgICAqIHR5cGUgc3RyaW5nIG9yIG51bWJlciwgc28gd2UgbmVlZCB0byByZXR1cm5cbiAgICAgICAqIHR3byBzZXRzIG9mIGRhdGE6IEEgZGF0YSBzZXQgdG8gYmUgcGFzc2VkXG4gICAgICAgKiB0byB0aGUgcGlja2VyIGNvbHVtbiwgYW5kIGEgZGF0YSBzZXQgdG9cbiAgICAgICAqIGJlIHVzZWQgdG8gcmVmZXJlbmNlIHRoZSByYXcgZGF0YSB3aGVuXG4gICAgICAgKiB1cGRhdGluZyB0aGUgcGlja2VyIGNvbHVtbiB2YWx1ZS5cbiAgICAgICAqL1xuICAgICAgZGF0ZVBhcnRzLnB1c2goe1xuICAgICAgICBtb250aDogcmVmZXJlbmNlTW9udGgubW9udGgsXG4gICAgICAgIHllYXI6IHJlZmVyZW5jZU1vbnRoLnllYXIsXG4gICAgICAgIGRheTogZGF5T2JqZWN0LnZhbHVlLFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcGFydHMgPSBbLi4ucGFydHMsIC4uLmRhdGVQYXJ0c107XG4gICAgaXRlbXMgPSBbLi4uaXRlbXMsIC4uLmRhdGVDb2x1bW5JdGVtc107XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHBhcnRzLFxuICAgIGl0ZW1zLFxuICB9O1xufTtcbmNvbnN0IGdldFRpbWVDb2x1bW5zRGF0YSA9IChsb2NhbGUsIHJlZlBhcnRzLCBob3VyQ3ljbGUsIG1pblBhcnRzLCBtYXhQYXJ0cywgYWxsb3dlZEhvdXJWYWx1ZXMsIGFsbG93ZWRNaW51dGVWYWx1ZXMpID0+IHtcbiAgY29uc3QgdXNlMjRIb3VyID0gaXMyNEhvdXIobG9jYWxlLCBob3VyQ3ljbGUpO1xuICBjb25zdCB7IGhvdXJzLCBtaW51dGVzLCBhbSwgcG0gfSA9IGdlbmVyYXRlVGltZShyZWZQYXJ0cywgdXNlMjRIb3VyID8gJ2gyMycgOiAnaDEyJywgbWluUGFydHMsIG1heFBhcnRzLCBhbGxvd2VkSG91clZhbHVlcywgYWxsb3dlZE1pbnV0ZVZhbHVlcyk7XG4gIGNvbnN0IGhvdXJzSXRlbXMgPSBob3Vycy5tYXAoKGhvdXIpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgdGV4dDogZ2V0Rm9ybWF0dGVkSG91cihob3VyLCB1c2UyNEhvdXIpLFxuICAgICAgdmFsdWU6IGdldEludGVybmFsSG91clZhbHVlKGhvdXIsIHVzZTI0SG91ciwgcmVmUGFydHMuYW1wbSksXG4gICAgfTtcbiAgfSk7XG4gIGNvbnN0IG1pbnV0ZXNJdGVtcyA9IG1pbnV0ZXMubWFwKChtaW51dGUpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgdGV4dDogYWRkVGltZVBhZGRpbmcobWludXRlKSxcbiAgICAgIHZhbHVlOiBtaW51dGUsXG4gICAgfTtcbiAgfSk7XG4gIGNvbnN0IGRheVBlcmlvZEl0ZW1zID0gW107XG4gIGlmIChhbSAmJiAhdXNlMjRIb3VyKSB7XG4gICAgZGF5UGVyaW9kSXRlbXMucHVzaCh7XG4gICAgICB0ZXh0OiBnZXRMb2NhbGl6ZWREYXlQZXJpb2QobG9jYWxlLCAnYW0nKSxcbiAgICAgIHZhbHVlOiAnYW0nLFxuICAgIH0pO1xuICB9XG4gIGlmIChwbSAmJiAhdXNlMjRIb3VyKSB7XG4gICAgZGF5UGVyaW9kSXRlbXMucHVzaCh7XG4gICAgICB0ZXh0OiBnZXRMb2NhbGl6ZWREYXlQZXJpb2QobG9jYWxlLCAncG0nKSxcbiAgICAgIHZhbHVlOiAncG0nLFxuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgbWludXRlc0RhdGE6IG1pbnV0ZXNJdGVtcyxcbiAgICBob3Vyc0RhdGE6IGhvdXJzSXRlbXMsXG4gICAgZGF5UGVyaW9kRGF0YTogZGF5UGVyaW9kSXRlbXMsXG4gIH07XG59O1xuXG5leHBvcnQgeyBnZXREYXlDb2x1bW5EYXRhIGFzIEEsIGdldFllYXJDb2x1bW5EYXRhIGFzIEIsIGlzTW9udGhGaXJzdExvY2FsZSBhcyBDLCBnZXRUaW1lQ29sdW1uc0RhdGEgYXMgRCwgaXNMb2NhbGVEYXlQZXJpb2RSVEwgYXMgRSwgZ2V0RGF5c09mV2VlayBhcyBGLCBnZXRNb250aEFuZFllYXIgYXMgRywgZ2V0RGF5c09mTW9udGggYXMgSCwgZ2VuZXJhdGVNb250aHMgYXMgSSwgaXMyNEhvdXIgYXMgSiwgZ2V0TG9jYWxpemVkVGltZSBhcyBLLCBnZXRNb250aEFuZERheSBhcyBMLCBmb3JtYXRWYWx1ZSBhcyBNLCBnZXROZXh0WWVhciBhcyBOLCBnZXRQcmV2aW91c1llYXIgYXMgTywgY2xhbXBEYXRlIGFzIFAsIHBhcnNlQW1QbSBhcyBRLCBjYWxjdWxhdGVIb3VyRnJvbUFNUE0gYXMgUiwgZ2V0TG9jYWxpemVkRGF0ZVRpbWUgYXMgUywgZ2V0TW9udGhEYXlBbmRZZWFyIGFzIFQsIGdldERheSBhcyBhLCBpc0FmdGVyIGFzIGIsIGlzU2FtZURheSBhcyBjLCBnZXRQcmV2aW91c01vbnRoIGFzIGQsIGdldE5leHRNb250aCBhcyBlLCBnZXRQYXJ0c0Zyb21DYWxlbmRhckRheSBhcyBmLCBnZW5lcmF0ZURheUFyaWFMYWJlbCBhcyBnLCBnZXRFbmRPZldlZWsgYXMgaCwgaXNCZWZvcmUgYXMgaSwgZ2V0U3RhcnRPZldlZWsgYXMgaiwgZ2V0UHJldmlvdXNEYXkgYXMgaywgZ2V0TmV4dERheSBhcyBsLCBnZXRQcmV2aW91c1dlZWsgYXMgbSwgZ2V0TmV4dFdlZWsgYXMgbiwgcGFyc2VNYXhQYXJ0cyBhcyBvLCBwYXJzZU1pblBhcnRzIGFzIHAsIHBhcnNlRGF0ZSBhcyBxLCBjb252ZXJ0VG9BcnJheU9mTnVtYmVycyBhcyByLCBjb252ZXJ0RGF0YVRvSVNPIGFzIHMsIGdldFRvZGF5IGFzIHQsIGdldENsb3Nlc3RWYWxpZERhdGUgYXMgdSwgdmFsaWRhdGVQYXJ0cyBhcyB2LCB3YXJuSWZWYWx1ZU91dE9mQm91bmRzIGFzIHcsIGdldE51bURheXNJbk1vbnRoIGFzIHgsIGdldENvbWJpbmVkRGF0ZUNvbHVtbkRhdGEgYXMgeSwgZ2V0TW9udGhDb2x1bW5EYXRhIGFzIHogfTtcbiIsIi8qIVxuICogKEMpIElvbmljIGh0dHA6Ly9pb25pY2ZyYW1ld29yay5jb20gLSBNSVQgTGljZW5zZVxuICovXG4vKipcbiAqIExvZ3MgYSB3YXJuaW5nIHRvIHRoZSBjb25zb2xlIHdpdGggYW4gSW9uaWMgcHJlZml4XG4gKiB0byBpbmRpY2F0ZSB0aGUgbGlicmFyeSB0aGF0IGlzIHdhcm5pbmcgdGhlIGRldmVsb3Blci5cbiAqXG4gKiBAcGFyYW0gbWVzc2FnZSAtIFRoZSBzdHJpbmcgbWVzc2FnZSB0byBiZSBsb2dnZWQgdG8gdGhlIGNvbnNvbGUuXG4gKi9cbmNvbnN0IHByaW50SW9uV2FybmluZyA9IChtZXNzYWdlLCAuLi5wYXJhbXMpID0+IHtcbiAgcmV0dXJuIGNvbnNvbGUud2FybihgW0lvbmljIFdhcm5pbmddOiAke21lc3NhZ2V9YCwgLi4ucGFyYW1zKTtcbn07XG4vKlxuICogTG9ncyBhbiBlcnJvciB0byB0aGUgY29uc29sZSB3aXRoIGFuIElvbmljIHByZWZpeFxuICogdG8gaW5kaWNhdGUgdGhlIGxpYnJhcnkgdGhhdCBpcyB3YXJuaW5nIHRoZSBkZXZlbG9wZXIuXG4gKlxuICogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgc3RyaW5nIG1lc3NhZ2UgdG8gYmUgbG9nZ2VkIHRvIHRoZSBjb25zb2xlLlxuICogQHBhcmFtIHBhcmFtcyAtIEFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHN1cHBseSB0byB0aGUgY29uc29sZS5lcnJvci5cbiAqL1xuY29uc3QgcHJpbnRJb25FcnJvciA9IChtZXNzYWdlLCAuLi5wYXJhbXMpID0+IHtcbiAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoYFtJb25pYyBFcnJvcl06ICR7bWVzc2FnZX1gLCAuLi5wYXJhbXMpO1xufTtcbi8qKlxuICogUHJpbnRzIGFuIGVycm9yIGluZm9ybWluZyBkZXZlbG9wZXJzIHRoYXQgYW4gaW1wbGVtZW50YXRpb24gcmVxdWlyZXMgYW4gZWxlbWVudCB0byBiZSB1c2VkXG4gKiB3aXRoaW4gYSBzcGVjaWZpYyBzZWxlY3Rvci5cbiAqXG4gKiBAcGFyYW0gZWwgVGhlIHdlYiBjb21wb25lbnQgZWxlbWVudCB0aGlzIGlzIHJlcXVpcmluZyB0aGUgZWxlbWVudC5cbiAqIEBwYXJhbSB0YXJnZXRTZWxlY3RvcnMgVGhlIHNlbGVjdG9yIG9yIHNlbGVjdG9ycyB0aGF0IHdlcmUgbm90IGZvdW5kLlxuICovXG5jb25zdCBwcmludFJlcXVpcmVkRWxlbWVudEVycm9yID0gKGVsLCAuLi50YXJnZXRTZWxlY3RvcnMpID0+IHtcbiAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoYDwke2VsLnRhZ05hbWUudG9Mb3dlckNhc2UoKX0+IG11c3QgYmUgdXNlZCBpbnNpZGUgJHt0YXJnZXRTZWxlY3RvcnMuam9pbignIG9yICcpfS5gKTtcbn07XG5cbmV4cG9ydCB7IHByaW50UmVxdWlyZWRFbGVtZW50RXJyb3IgYXMgYSwgcHJpbnRJb25FcnJvciBhcyBiLCBwcmludElvbldhcm5pbmcgYXMgcCB9O1xuIiwiLyohXG4gKiAoQykgSW9uaWMgaHR0cDovL2lvbmljZnJhbWV3b3JrLmNvbSAtIE1JVCBMaWNlbnNlXG4gKi9cbmNvbnN0IGhvc3RDb250ZXh0ID0gKHNlbGVjdG9yLCBlbCkgPT4ge1xuICByZXR1cm4gZWwuY2xvc2VzdChzZWxlY3RvcikgIT09IG51bGw7XG59O1xuLyoqXG4gKiBDcmVhdGUgdGhlIG1vZGUgYW5kIGNvbG9yIGNsYXNzZXMgZm9yIHRoZSBjb21wb25lbnQgYmFzZWQgb24gdGhlIGNsYXNzZXMgcGFzc2VkIGluXG4gKi9cbmNvbnN0IGNyZWF0ZUNvbG9yQ2xhc3NlcyA9IChjb2xvciwgY3NzQ2xhc3NNYXApID0+IHtcbiAgcmV0dXJuIHR5cGVvZiBjb2xvciA9PT0gJ3N0cmluZycgJiYgY29sb3IubGVuZ3RoID4gMFxuICAgID8gT2JqZWN0LmFzc2lnbih7ICdpb24tY29sb3InOiB0cnVlLCBbYGlvbi1jb2xvci0ke2NvbG9yfWBdOiB0cnVlIH0sIGNzc0NsYXNzTWFwKSA6IGNzc0NsYXNzTWFwO1xufTtcbmNvbnN0IGdldENsYXNzTGlzdCA9IChjbGFzc2VzKSA9PiB7XG4gIGlmIChjbGFzc2VzICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBhcnJheSA9IEFycmF5LmlzQXJyYXkoY2xhc3NlcykgPyBjbGFzc2VzIDogY2xhc3Nlcy5zcGxpdCgnICcpO1xuICAgIHJldHVybiBhcnJheVxuICAgICAgLmZpbHRlcigoYykgPT4gYyAhPSBudWxsKVxuICAgICAgLm1hcCgoYykgPT4gYy50cmltKCkpXG4gICAgICAuZmlsdGVyKChjKSA9PiBjICE9PSAnJyk7XG4gIH1cbiAgcmV0dXJuIFtdO1xufTtcbmNvbnN0IGdldENsYXNzTWFwID0gKGNsYXNzZXMpID0+IHtcbiAgY29uc3QgbWFwID0ge307XG4gIGdldENsYXNzTGlzdChjbGFzc2VzKS5mb3JFYWNoKChjKSA9PiAobWFwW2NdID0gdHJ1ZSkpO1xuICByZXR1cm4gbWFwO1xufTtcbmNvbnN0IFNDSEVNRSA9IC9eW2Etel1bYS16MC05K1xcLS5dKjovO1xuY29uc3Qgb3BlblVSTCA9IGFzeW5jICh1cmwsIGV2LCBkaXJlY3Rpb24sIGFuaW1hdGlvbikgPT4ge1xuICBpZiAodXJsICE9IG51bGwgJiYgdXJsWzBdICE9PSAnIycgJiYgIVNDSEVNRS50ZXN0KHVybCkpIHtcbiAgICBjb25zdCByb3V0ZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdpb24tcm91dGVyJyk7XG4gICAgaWYgKHJvdXRlcikge1xuICAgICAgaWYgKGV2ICE9IG51bGwpIHtcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByb3V0ZXIucHVzaCh1cmwsIGRpcmVjdGlvbiwgYW5pbWF0aW9uKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuZXhwb3J0IHsgY3JlYXRlQ29sb3JDbGFzc2VzIGFzIGMsIGdldENsYXNzTWFwIGFzIGcsIGhvc3RDb250ZXh0IGFzIGgsIG9wZW5VUkwgYXMgbyB9O1xuIl0sIm5hbWVzIjpbInAiLCJwcmludElvbldhcm5pbmciLCJpc1NhbWVEYXkiLCJiYXNlUGFydHMiLCJjb21wYXJlUGFydHMiLCJtb250aCIsImRheSIsInllYXIiLCJpc0JlZm9yZSIsImlzQWZ0ZXIiLCJ3YXJuSWZWYWx1ZU91dE9mQm91bmRzIiwidmFsdWUiLCJtaW4iLCJtYXgiLCJ2YWx1ZUFycmF5IiwiQXJyYXkiLCJpc0FycmF5IiwidmFsIiwidW5kZWZpbmVkIiwiSlNPTiIsInN0cmluZ2lmeSIsImlzTGVhcFllYXIiLCJpczI0SG91ciIsImxvY2FsZSIsImhvdXJDeWNsZSIsImZvcm1hdHRlZCIsIkludGwiLCJEYXRlVGltZUZvcm1hdCIsImhvdXIiLCJvcHRpb25zIiwicmVzb2x2ZWRPcHRpb25zIiwiZGF0ZSIsIkRhdGUiLCJwYXJ0cyIsImZvcm1hdFRvUGFydHMiLCJmaW5kIiwidHlwZSIsIkVycm9yIiwiZ2V0TnVtRGF5c0luTW9udGgiLCJpc01vbnRoRmlyc3RMb2NhbGUiLCJmb3JtYXRPcHRpb25zIiwiaXNMb2NhbGVEYXlQZXJpb2RSVEwiLCJJU09fODYwMV9SRUdFWFAiLCJUSU1FX1JFR0VYUCIsImNvbnZlcnRUb0FycmF5T2ZOdW1iZXJzIiwiaW5wdXQiLCJwcm9jZXNzZWRJbnB1dCIsInJlcGxhY2UiLCJzcGxpdCIsInZhbHVlcyIsIm1hcCIsIm51bSIsInBhcnNlSW50IiwiZmlsdGVyIiwiaXNGaW5pdGUiLCJnZXRQYXJ0c0Zyb21DYWxlbmRhckRheSIsImVsIiwiZ2V0QXR0cmlidXRlIiwiZGF5T2ZXZWVrIiwicGFyc2VEYXRlIiwidmFsU3RyIiwicGFyc2UiLCJleGVjIiwidW5zaGlmdCIsImkiLCJ0ek9mZnNldCIsIm1pbnV0ZSIsImFtcG0iLCJjbGFtcERhdGUiLCJkYXRlUGFydHMiLCJtaW5QYXJ0cyIsIm1heFBhcnRzIiwicGFyc2VBbVBtIiwicGFyc2VNYXhQYXJ0cyIsInRvZGF5UGFydHMiLCJ5ZWFyVmFsdWUiLCJtb250aFZhbHVlIiwicGFyc2VNaW5QYXJ0cyIsInR3b0RpZ2l0IiwiTWF0aCIsImFicyIsInNsaWNlIiwiZm91ckRpZ2l0IiwiY29udmVydERhdGFUb0lTTyIsImRhdGEiLCJydG4iLCJmbG9vciIsImNvbnZlcnQxMkhvdXJUbzI0SG91ciIsImdldFN0YXJ0T2ZXZWVrIiwicmVmUGFydHMiLCJzdWJ0cmFjdERheXMiLCJnZXRFbmRPZldlZWsiLCJhZGREYXlzIiwiZ2V0TmV4dERheSIsImdldFByZXZpb3VzRGF5IiwiZ2V0UHJldmlvdXNXZWVrIiwiZ2V0TmV4dFdlZWsiLCJudW1EYXlzIiwid29ya2luZ1BhcnRzIiwiZGF5c0luTW9udGgiLCJnZXRQcmV2aW91c01vbnRoIiwibnVtRGF5c0luTW9udGgiLCJnZXROZXh0TW9udGgiLCJjaGFuZ2VZZWFyIiwieWVhckRlbHRhIiwiZ2V0UHJldmlvdXNZZWFyIiwiZ2V0TmV4dFllYXIiLCJnZXRJbnRlcm5hbEhvdXJWYWx1ZSIsInVzZTI0SG91ciIsImNhbGN1bGF0ZUhvdXJGcm9tQU1QTSIsImN1cnJlbnRQYXJ0cyIsIm5ld0FNUE0iLCJjdXJyZW50QU1QTSIsIm5ld0hvdXIiLCJ2YWxpZGF0ZVBhcnRzIiwicGFydHNDb3B5IiwiT2JqZWN0IiwiYXNzaWduIiwiZ2V0Q2xvc2VzdFZhbGlkRGF0ZSIsIm1vbnRoVmFsdWVzIiwiZGF5VmFsdWVzIiwieWVhclZhbHVlcyIsImhvdXJWYWx1ZXMiLCJtaW51dGVWYWx1ZXMiLCJjb3B5UGFydHMiLCJmaW5kQ2xvc2VzdFZhbHVlIiwicmVmZXJlbmNlIiwiY2xvc2VzdFZhbHVlIiwicmFuayIsImxlbmd0aCIsInZhbHVlUmFuayIsImdldEZvcm1hdHRlZERheVBlcmlvZCIsImRheVBlcmlvZCIsInRvVXBwZXJDYXNlIiwiZ2V0TG9jYWxpemVkVGltZSIsInRpbWVab25lIiwiZm9ybWF0IiwiYWRkVGltZVBhZGRpbmciLCJ2YWx1ZVRvU3RyaW5nIiwidG9TdHJpbmciLCJnZXRGb3JtYXR0ZWRIb3VyIiwiZ2VuZXJhdGVEYXlBcmlhTGFiZWwiLCJ0b2RheSIsImxhYmVsU3RyaW5nIiwid2Vla2RheSIsImdldE1vbnRoQW5kRGF5IiwiZ2V0TW9udGhBbmRZZWFyIiwiZ2V0TW9udGhEYXlBbmRZZWFyIiwiZ2V0TG9jYWxpemVkRGF0ZVRpbWUiLCJnZXREYXkiLCJnZXRMb2NhbGl6ZWREYXRlVGltZVBhcnRzIiwib2JqIiwiZ2V0WWVhciIsImdldE5vcm1hbGl6ZWREYXRlIiwidGltZVN0cmluZyIsImdldERhdGVUaW1lRm9ybWF0IiwiZ2V0VG9kYXlMYWJlbCIsImxhYmVsIiwiUmVsYXRpdmVUaW1lRm9ybWF0IiwibnVtZXJpYyIsImNoYXJBdCIsInJlbW92ZURhdGVUek9mZnNldCIsImdldFRpbWV6b25lT2Zmc2V0Iiwic2V0TWludXRlcyIsImdldE1pbnV0ZXMiLCJEQVRFX0FNIiwiREFURV9QTSIsImdldExvY2FsaXplZERheVBlcmlvZCIsImxvY2FsaXplZERheVBlcmlvZCIsInBhcnQiLCJmb3JtYXRWYWx1ZSIsImpvaW4iLCJnZXRUb2RheSIsInRvSVNPU3RyaW5nIiwibWludXRlcyIsImhvdXIxMiIsImhvdXIyMyIsImdldERheXNPZldlZWsiLCJtb2RlIiwiZmlyc3REYXlPZldlZWsiLCJ3ZWVrZGF5Rm9ybWF0IiwiaW50bCIsInN0YXJ0RGF0ZSIsImRheXNPZldlZWsiLCJjdXJyZW50RGF0ZSIsInNldERhdGUiLCJnZXREYXRlIiwicHVzaCIsImdldERheXNPZk1vbnRoIiwiZmlyc3RPZk1vbnRoIiwib2Zmc2V0IiwiZGF5cyIsImdlbmVyYXRlVGltZSIsInByb2Nlc3NlZEhvdXJzIiwicHJvY2Vzc2VkTWludXRlcyIsImlzQU1BbGxvd2VkIiwiaXNQTUFsbG93ZWQiLCJpbmNsdWRlcyIsImNvbnZlcnRlZEhvdXIiLCJpc1Bhc3RNaW5Ib3VyIiwiaG91cnMiLCJhbSIsInBtIiwiZ2VuZXJhdGVNb250aHMiLCJnZXRNb250aENvbHVtbkRhdGEiLCJtb250aHMiLCJwcm9jZXNzZWRNb250aHMiLCJmb3JFYWNoIiwicHJvY2Vzc2VkTW9udGgiLCJtb250aFN0cmluZyIsInRleHQiLCJtYXhNb250aCIsIm1pbk1vbnRoIiwiZ2V0RGF5Q29sdW1uRGF0YSIsIm1heERheSIsIm1pbkRheSIsInByb2Nlc3NlZERheXMiLCJwcm9jZXNzZWREYXkiLCJkYXlTdHJpbmciLCJnZXRZZWFyQ29sdW1uRGF0YSIsIl9hIiwiX2IiLCJwcm9jZXNzZWRZZWFycyIsIm1heFllYXIiLCJtaW5ZZWFyIiwiZ2V0QWxsTW9udGhzSW5SYW5nZSIsImdldENvbWJpbmVkRGF0ZUNvbHVtbkRhdGEiLCJpdGVtcyIsIm1vbnRoT2JqZWN0IiwicmVmZXJlbmNlTW9udGgiLCJtb250aERheXMiLCJkYXRlQ29sdW1uSXRlbXMiLCJkYXlPYmplY3QiLCJpc1RvZGF5IiwiZ2V0VGltZUNvbHVtbnNEYXRhIiwiYWxsb3dlZEhvdXJWYWx1ZXMiLCJhbGxvd2VkTWludXRlVmFsdWVzIiwiaG91cnNJdGVtcyIsIm1pbnV0ZXNJdGVtcyIsImRheVBlcmlvZEl0ZW1zIiwibWludXRlc0RhdGEiLCJob3Vyc0RhdGEiLCJkYXlQZXJpb2REYXRhIiwiQSIsIkIiLCJDIiwiRCIsIkUiLCJGIiwiRyIsIkgiLCJJIiwiSiIsIksiLCJMIiwiTSIsIk4iLCJPIiwiUCIsIlEiLCJSIiwiUyIsIlQiLCJhIiwiYiIsImMiLCJkIiwiZSIsImYiLCJnIiwiaCIsImoiLCJrIiwibCIsIm0iLCJuIiwibyIsInEiLCJyIiwicyIsInQiLCJ1IiwidiIsInciLCJ4IiwieSIsInoiLCJtZXNzYWdlIiwicGFyYW1zIiwiY29uc29sZSIsIndhcm4iLCJwcmludElvbkVycm9yIiwiZXJyb3IiLCJwcmludFJlcXVpcmVkRWxlbWVudEVycm9yIiwidGFyZ2V0U2VsZWN0b3JzIiwidGFnTmFtZSIsInRvTG93ZXJDYXNlIiwiaG9zdENvbnRleHQiLCJzZWxlY3RvciIsImNsb3Nlc3QiLCJjcmVhdGVDb2xvckNsYXNzZXMiLCJjb2xvciIsImNzc0NsYXNzTWFwIiwiZ2V0Q2xhc3NMaXN0IiwiY2xhc3NlcyIsImFycmF5IiwidHJpbSIsImdldENsYXNzTWFwIiwiU0NIRU1FIiwib3BlblVSTCIsInVybCIsImV2IiwiZGlyZWN0aW9uIiwiYW5pbWF0aW9uIiwidGVzdCIsInJvdXRlciIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsInByZXZlbnREZWZhdWx0Il0sInNvdXJjZVJvb3QiOiJ3ZWJwYWNrOi8vLyIsInhfZ29vZ2xlX2lnbm9yZUxpc3QiOlswLDEsMl19