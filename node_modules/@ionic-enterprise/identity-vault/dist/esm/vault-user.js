import { AuthMode, VaultErrorCodes } from './definitions';
/**
 * @hidden
 *
 * @ignore
 */
// eslint-disable-next-line @typescript-eslint/ban-types
export class IonicIdentityVaultUser {
    constructor(platform, options, descriptor) {
        this.platform = platform;
        this.options = options;
        this._readyCalled = false;
        this.descriptor = descriptor || { username: '_lastUser', vaultId: 'default' };
        this._readyPromise = this.initializeVault();
    }
    get token() {
        const session = this.session;
        return session === null || session === void 0 ? void 0 : session.token;
    }
    get username() {
        const session = this.session;
        return session === null || session === void 0 ? void 0 : session.username;
    }
    get config() {
        if (!this._config) {
            return undefined;
        }
        let authMode;
        const bioEnabled = this._config.isBiometricsEnabled;
        const passEnabled = this._config.isPasscodeEnabled;
        const secureStorageMode = this._config.isSecureStorageModeEnabled;
        if (secureStorageMode) {
            authMode = AuthMode.SecureStorage;
        }
        else if (bioEnabled && passEnabled) {
            authMode = AuthMode.BiometricAndPasscode;
        }
        else if (bioEnabled && !passEnabled) {
            authMode = AuthMode.BiometricOnly;
        }
        else if (!bioEnabled && passEnabled) {
            authMode = AuthMode.PasscodeOnly;
        }
        else if (!bioEnabled && !passEnabled) {
            authMode = AuthMode.InMemoryOnly;
        }
        return {
            authMode: authMode,
            isPasscodeSetupNeeded: this._config.isPasscodeSetupNeeded,
            lockAfter: this._config.lockAfter,
            hideScreenOnBackground: this._config.hideScreenOnBackground,
        };
    }
    // overidable event handlers
    onVaultLocked(_event) {
        /* Do Nothing */
    }
    onSessionRestoreError(_err) {
        /* Do Nothing */
    }
    onUnlockOnReadyError(_err) {
        /* Do Nothing */
    }
    onVaultUnlocked(_config) {
        /* Do Nothing */
    }
    onVaultReady(_config) {
        /* Do Nothing */
    }
    onSetupError(_error) {
        /* Do Nothing */
    }
    onConfigChange(_config) {
        /* Do Nothing */
    }
    onSessionRestored(_session) {
        /* Do Nothing */
    }
    async onPasscodeRequest(_isPasscodeSetRequest) {
        return;
    }
    async onReady(vault) {
        if (this._readyCalled) {
            return;
        }
        this._readyCalled = true;
        this.vault = vault;
        const inUse = await this.vault.isInUse();
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this._config = vault.config;
        const locked = await this.vault.isLocked();
        let restoreSessionError;
        try {
            if (this.options.restoreSessionOnReady && inUse) {
                await this._restoreSession();
            }
        }
        catch (e) {
            restoreSessionError = e;
        }
        let unlockOnReadyError;
        try {
            if (locked && this.options.unlockOnReady) {
                await this._unlock();
            }
        }
        catch (e) {
            unlockOnReadyError = e;
        }
        // Note Swallow all errors in init like Vault is Locked Etc.
        try {
            if (!inUse) {
                await this._trySetAuthMode(this.options.authMode);
            }
        }
        catch (e) {
            // Do Nothing
        }
        this._readyResolve();
        this.onVaultReady(this.config);
        if (restoreSessionError) {
            this.onSessionRestoreError(restoreSessionError);
        }
        if (unlockOnReadyError) {
            this.onUnlockOnReadyError(restoreSessionError);
        }
    }
    onLock(event) {
        this.session = undefined;
        this.onVaultLocked(event);
    }
    async onUnlock(config) {
        await this.ready();
        this._config = config;
        this.onVaultUnlocked(this.config);
    }
    onError(error) {
        this._readyReject(error);
        this.onSetupError(error);
    }
    onConfig(config) {
        this._config = config;
        this.onConfigChange(this.config);
    }
    async ready() {
        return this._readyPromise;
    }
    async _unlock(authMode) {
        const locked = await this.vault.isLocked();
        if (!locked) {
            return;
        }
        authMode = authMode !== undefined && authMode !== AuthMode.BiometricOrPasscode ? authMode : this.config.authMode;
        switch (authMode) {
            case AuthMode.BiometricOnly:
                return this.vault.unlock();
            case AuthMode.PasscodeOnly:
                return this.unlockWithPasscode();
            case AuthMode.BiometricAndPasscode:
                try {
                    await this.vault.unlock();
                    return;
                }
                catch (e) {
                    const handleableErrors = [
                        VaultErrorCodes.AuthFailed,
                        VaultErrorCodes.BiometricsNotEnabled,
                        VaultErrorCodes.UserCanceledInteraction,
                        VaultErrorCodes.InvalidatedCredential,
                    ];
                    if (handleableErrors.indexOf(e.code) > -1) {
                        await this.unlockWithPasscode();
                        // The user removed fingerprints/faceID and so the bio creds are gone
                        // if they are using passcode auth we can resave the credential to autoreset
                        // the mode to PasscodeOnly if bio is no longer available.
                        if (e.code === VaultErrorCodes.InvalidatedCredential) {
                            const session = await this.restoreSession();
                            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                            await this.saveSession(session);
                        }
                        return;
                    }
                    throw e;
                }
        }
    }
    async unlock(authMode) {
        await this.ready();
        return this._unlock(authMode);
    }
    async unlockWithPasscode() {
        const passcode = await this.onPasscodeRequest(false);
        return this.vault.unlock(true, passcode);
    }
    async _setPasscode() {
        const locked = await this.vault.isLocked();
        if (locked) {
            // eslint-disable-next-line no-throw-literal
            throw { code: VaultErrorCodes.VaultLocked, message: 'Operation not allowed while vault locked.' };
        }
        const passcode = await this.onPasscodeRequest(true);
        return this.vault.setPasscode(passcode);
    }
    async setPasscode() {
        await this.ready();
        return this._setPasscode();
    }
    async getSession() {
        await this.ready();
        if (this.options.unlockOnAccess) {
            await this._unlock();
        }
        return this.session;
    }
    async _restoreSession() {
        const inUse = await this.vault.isInUse();
        if (!inUse) {
            return;
        }
        if (this.options.unlockOnAccess) {
            await this._unlock();
        }
        this.session = await this.vault.getValue('session');
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.onSessionRestored(this.session);
        return this.session;
    }
    async restoreSession() {
        await this.ready();
        return this._restoreSession();
    }
    async saveSession(session) {
        await this.ready();
        if (this.config.isPasscodeSetupNeeded) {
            await this.setPasscode();
        }
        try {
            await this.vault.storeValue('session', session);
        }
        catch (e) {
            // Catch the case where Biometrics with Passcode Fallback
            // was enabled but the user disabled passcode or removed their
            // fingerprints/faceid and try to recover by setting to passcode only
            // mode.
            if (e.code === VaultErrorCodes.SecurityNotAvailable) {
                const authMode = await this.getAuthMode();
                if (authMode === AuthMode.BiometricAndPasscode) {
                    await this.setAuthMode(AuthMode.PasscodeOnly);
                    return this.saveSession(session);
                }
            }
            throw e;
        }
        this.session = session;
    }
    async login(session, authMode) {
        await this.ready();
        await this.logout();
        await this._trySetAuthMode(authMode);
        return this.saveSession(session);
    }
    async getVault() {
        await this.ready();
        return this.vault;
    }
    async initializeVault() {
        await this.platform.ready();
        if (this.vault != null) {
            return Promise.resolve();
        }
        if (this.vIonicNativeAuth == null) {
            this.vIonicNativeAuth = this.getPlugin();
        }
        const readyPromise = new Promise((resolve, reject) => {
            this._readyResolve = resolve;
            this._readyReject = reject;
        });
        const { lockAfter, hideScreenOnBackground, shouldClearVaultAfterTooManyFailedAttempts, allowSystemPinFallback, androidPromptNegativeButtonText, androidPromptTitle, androidPromptSubtitle, androidPromptDescription, androidPINPromptTitle, androidPINPromptSubtitle, androidPINPromptConfirmTitle, androidPINPromptVerifyTitle, androidPINPromptConfirmButtonText, androidPINPromptNegativeButtonText, iosPromptText, } = this.options;
        this.vault = this.vIonicNativeAuth.getVault(Object.assign(Object.assign({ lockAfter,
            hideScreenOnBackground,
            shouldClearVaultAfterTooManyFailedAttempts,
            allowSystemPinFallback,
            androidPromptNegativeButtonText,
            androidPromptTitle,
            androidPromptSubtitle,
            androidPromptDescription,
            androidPINPromptTitle,
            androidPINPromptSubtitle,
            androidPINPromptConfirmTitle,
            androidPINPromptVerifyTitle,
            androidPINPromptConfirmButtonText,
            androidPINPromptNegativeButtonText,
            iosPromptText }, this.descriptor), { onLock: this.onLock.bind(this), onConfig: this.onConfig.bind(this), onError: this.onError.bind(this), onUnlock: this.onUnlock.bind(this), onReady: this.onReady.bind(this) }));
        return readyPromise;
    }
    getPlugin() {
        return IonicNativeAuth;
    }
    async getBiometricType() {
        await this.ready();
        return this.vault.getBiometricType();
    }
    async getAvailableHardware() {
        await this.ready();
        return this.vault.getAvailableHardware();
    }
    async lockOut() {
        await this.ready();
        await this.vault.lock();
        this.session = undefined;
    }
    async logout() {
        await this.ready();
        await this.vault.clear();
        this.session = undefined;
        this._config = await this.vault.getConfig();
    }
    async hasStoredSession() {
        await this.ready();
        return this.vault.isInUse();
    }
    async setBiometricsEnabled(isBiometricsEnabled) {
        await this.ready();
        return this._setBiometricsEnabled(isBiometricsEnabled);
    }
    async _setBiometricsEnabled(isBiometricsEnabled) {
        return this.vault.setBiometricsEnabled(isBiometricsEnabled);
    }
    async setHideScreenOnBackground(enabled) {
        await this.ready();
        return this.vault.setHideScreenOnBackground(enabled);
    }
    async setPasscodeEnabled(isPasscodeEnabled) {
        await this.ready();
        await this._setPasscodeEnabled(isPasscodeEnabled);
    }
    async _setPasscodeEnabled(isPasscodeEnabled) {
        await this.vault.setPasscodeEnabled(isPasscodeEnabled);
        this._config = await this.vault.getConfig();
        if (this.config.isPasscodeSetupNeeded) {
            await this._setPasscode();
        }
    }
    async isBiometricsEnabled() {
        await this.ready();
        return this.vault.isBiometricsEnabled();
    }
    async isBiometricsAvailable() {
        await this.ready();
        return this.vault.isBiometricsAvailable();
    }
    async isBiometricsSupported() {
        await this.ready();
        return this.vault.isBiometricsSupported();
    }
    async isSecureStorageModeEnabled() {
        await this.ready();
        return this.vault.isSecureStorageModeEnabled();
    }
    async isPasscodeEnabled() {
        await this.ready();
        return this.vault.isPasscodeEnabled();
    }
    async _setAuthMode(authMode) {
        authMode = authMode !== undefined ? authMode : this.config.authMode;
        if (authMode === this.config.authMode) {
            return;
        }
        switch (authMode) {
            case AuthMode.BiometricOnly:
                await this._setBiometricsEnabled(true);
                await this._setPasscodeEnabled(false);
                break;
            case AuthMode.PasscodeOnly:
                await this._setPasscodeEnabled(true);
                await this._setBiometricsEnabled(false);
                break;
            case AuthMode.BiometricAndPasscode:
                await this._setPasscodeEnabled(true);
                await this._setBiometricsEnabled(true);
                break;
            case AuthMode.BiometricOrPasscode:
                try {
                    await this._setBiometricsEnabled(true);
                    await this._setPasscodeEnabled(false);
                }
                catch (error) {
                    await this._setPasscodeEnabled(true);
                }
                break;
            case AuthMode.InMemoryOnly:
                await this._setPasscodeEnabled(false);
                await this._setBiometricsEnabled(false);
                await this.vault.setSecureStorageModeEnabled(false);
                break;
            case AuthMode.SecureStorage:
                // Note: Setting this mode automatically disables the other modes in native code.
                await this.vault.setSecureStorageModeEnabled(true);
                break;
            default:
                // eslint-disable-next-line no-throw-literal
                throw { code: VaultErrorCodes.InvalidAuthMode, message: 'Invalid AuthMode' };
        }
    }
    async _trySetAuthMode(authMode) {
        try {
            await this._setAuthMode(authMode);
        }
        catch (error) {
            if (error.code !== VaultErrorCodes.BiometricsNotEnabled && error.code !== VaultErrorCodes.SecurityNotAvailable) {
                throw error;
            }
        }
    }
    async setAuthMode(authMode) {
        await this.ready();
        return this._setAuthMode(authMode);
    }
    async getAuthMode() {
        await this.ready();
        this._config = await this.vault.getConfig();
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return this.config.authMode;
    }
}
//# sourceMappingURL=vault-user.js.map