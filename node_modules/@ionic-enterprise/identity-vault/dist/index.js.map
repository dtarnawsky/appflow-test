{"version":3,"file":"index.js","sources":["../src/definitions.ts","../../../node_modules/tslib/tslib.es6.js","../src/BrowserVault.ts","../src/Vault.ts","../src/Device.ts","../src/vault-user.ts","../src/VaultMigrator.ts"],"sourcesContent":["/**\n * The meaning of the error code in the thrown {@link VaultError}.\n */\nexport enum VaultErrorCodes {\n  /**\n   * An unknown error happened.\n   * @constant `0`\n   */\n  Unknown,\n  /**\n   * The operation failed because the vault was locked.\n   * @constant `1`\n   */\n  VaultLocked,\n  /**\n   * The operation failed because the vault was unavailable.\n   * The most likely cause of this error is that a vault has not been configured.\n   * @constant `2`\n   */\n  VaultUnavailable,\n  /**\n   * The operation failed because the some of the vault provided arguments were invalid.\n   * @constant `3`\n   */\n  InvalidArguments,\n  /**\n   * The credentials were invalidated. This can happen when a user changes biometrics or passcode.\n   * @constant `4`\n   */\n  InvalidatedCredential,\n  /**\n   * Biometric security is unavailable due to a passcode not being set up at the system level.\n   * In order to use biometric identification on the device a system level passcode must be set up by the user.\n   * @constant `5`\n   */\n  SecurityNotAvailable,\n  /**\n   * User authentication failed.\n   * @constant `6`\n   */\n  AuthFailed,\n  /**\n   * Too many failed authentication attempts made against the custom passcode vault, so the vault was cleared and user will need to login again.\n   * @constant `7`\n   */\n  TooManyFailedAttempts,\n  /**\n   * The user cancelled the native authentication dialog.\n   *\n   * **Note**: On iOS, this error code will also be thrown in the event that the native authentication dialog fails as a result of too many failed attempts.\n   * The user will be forced to cancel the dialog, triggering this error code.\n   *\n   * On Android, this error also will be thrown if using {@link DeviceSecurityType.SystemPasscode} or {@link DeviceSecurityType.Both} in the event of too many failed attempts.\n   * Its currently not possible to get the nature of failures from the native authentication dialog, and similar to iOS, the user will be forced to cancel the dialog, triggering this error code.\n   * @constant `8`\n   */\n  UserCanceledInteraction,\n  /**\n   * The user provided mismatched passcodes.\n   * @constant `9`\n   */\n  MismatchedPasscode,\n  /**\n   * The operation requires passcode to be setup but it isn't set yet. Call {@link Vault.setCustomPasscode} to set it.\n   * @constant `10`\n   */\n  MissingPasscode,\n  /**\n   * The operation failed because the application tried to unlock the vault with passcode authentication,\n   * but the vault is not configured to allow passcode authentication.\n   * @constant `11`\n   */\n  PasscodeNotEnabled,\n  /**\n   * The key was not found. This can happen when a user changes biometrics or passcode.\n   * @constant `12`\n   */\n  KeyNotFound,\n  /**\n   * The operation failed because biometric authentication is not enabled.\n   * This can occur when biometrics is not supported by the device\n   * or when biometrics has not been configured for the device or vault.\n   * @constant `13`\n   */\n  BiometricsNotEnabled,\n  /**\n   * @ignore\n   */\n  InvalidAuthMode,\n  /**\n   * Biometrics have not been authed yet (Android only)\n   * @constant `15`\n   */\n  MissingBiometrics,\n  /**\n   * {@link DeviceSecurityType.SystemPasscode} for {@link DeviceSecurityType} not available on this Android device.\n   * @constant `16`\n   */\n  AndroidSystemPasscodeUnavailable,\n  /**\n   * Biometrics have been locked out, usually because of too many failed attempts.\n   *\n   * **Note:** This error will never be thrown if using {@link DeviceSecurityType.SystemPasscode} or {@link DeviceSecurityType.Both}.\n   * Its currently not possible to get the nature of failures from the native authentication dialog, so the only error that would be thrown is {@link VaultErrorCodes.UserCanceledInteraction} as the user\n   * is forced to cancel the prompt.\n   *\n   * @constant `17`\n   */\n  AndroidBiometricsLockedOut,\n  /**\n   * Biometrics have been locked out, usually because of too many failed attempts.\n   *\n   * @constant `18`\n   */\n  iOSBiometricsLockedOut,\n  /**\n   * An unexpected error has occurred in the Android keystore.\n   * Some android devices (such as the Samsung S10) will return this error code when\n   * a maximum number of failed attempts is reached and the device must be restarted.\n   * See: [Max Uses Per Boot](https://source.android.com/security/keystore/tags#max_uses_per_boot)\n   *\n   * @constant `19`\n   */\n  AndroidUnexpectedKeystoreError,\n}\n\n/**\n * The meaning of the error code in the thrown {@link DeviceError}.\n */\nexport enum DeviceErrorCodes {\n  /**\n   * An unknown error happened.\n   * @constant `0`\n   */\n  Unknown,\n  /**\n   * The operation failed because the some of the vault provided arguments were invalid.\n   * @constant `1`\n   */\n  InvalidArguments,\n  /**\n   * The user cancelled the native authentication dialog.\n   *\n   * **Note**: On iOS, this error code will also be thrown in the event that the native authentication dialog fails as a result of too many failed attempts.\n   * The user will be forced to cancel the dialog, triggering this error code.\n   *\n   * @constant `2`\n   */\n  UserCanceledInteraction,\n  /**\n   * Biometric security is unavailable due to a passcode not being set up at the system level.\n   * In order to use biometric identification on the device a system level passcode must be set up by the user.\n   * @constant `3`\n   */\n  SecurityNotAvailable,\n  /**\n   * User authentication failed.\n   * @constant `4`\n   */\n  AuthFailed,\n  /**\n   * Biometrics have been locked out, usually because of too many failed attempts.\n   *\n   * @constant `5`\n   */\n  BiometricsLockedOut,\n  /**\n   * The operation failed because biometric authentication is not enabled.\n   * This can occur when biometrics is not supported by the device\n   * or when biometrics has not been configured for the device or vault.\n   * @constant `6`\n   */\n  BiometricsNotEnabled,\n}\n\n/**\n * An error that can be thrown by the plugin.\n *\n * @example\n * try {\n *  vault.unlock();\n * } catch(e) {\n *   switch (e.code) {\n *     case VaultErrorCodes.AuthFailed:\n *       alert('You failed to authenticate!');\n *       break;\n *     case VaultErrorCodes.UserCanceledInteraction:\n *       alert('You cancelled the face id prompt!');\n *       break;\n *     default:\n *       throw e;\n *   }\n * }\n */\nexport interface VaultError {\n  /**\n   * - Type: `string`\n   *\n   * A text description of the error that occurred.\n   */\n  message: string;\n  /**\n   * - Type: {@link VaultErrorCodes}\n   *\n   * The error code enum representing the error.\n   */\n  code: VaultErrorCodes;\n}\n\n/**\n * An error that can be thrown in the Device class.\n *\n * @example\n * try {\n *  await Device.showBiometricPrompt(promptConfig);\n * } catch(e) {\n *   switch (e.code) {\n *     case DeviceErrorCodes.AuthFailed:\n *       alert('You failed to authenticate!');\n *       break;\n *     case DeviceErrorCodes.UserCanceledInteraction:\n *       alert('You cancelled the face id prompt!');\n *       break;\n *     default:\n *       throw e;\n *   }\n * }\n */\nexport interface DeviceError {\n  /**\n   * - Type: `string`\n   *\n   * A text description of the error that occurred.\n   */\n  message: string;\n  /**\n   * - Type: {@link DeviceErrorCodes}\n   *\n   * The error code enum representing the error.\n   */\n  code: DeviceErrorCodes;\n}\n\n/**\n * The possible values returned by {@link Device.getAvailableHardware}\n */\nexport enum SupportedBiometricType {\n  /** The device supports fingerprint scanning. */\n  Fingerprint = 'fingerprint',\n  /** The device supports facial recognition. */\n  Face = 'face',\n  /** The device supports iris scanning. */\n  Iris = 'iris',\n}\n\n/**\n * Possible device biometric strength levels on Android (always `strong` on iOS).\n * [More Information](https://source.android.com/security/biometric/measure#tiered-authentication).\n */\nexport enum BiometricSecurityStrength {\n  /** Refers to Class 2 - Weak biometric security */\n  Weak = 'weak',\n  /** Refers to Class 3 - Strong biometric security */\n  Strong = 'strong',\n}\n\n/**\n * Possible app biometric permissions states on iOS (always `granted` on Android and on iOS with TouchID).\n */\nexport enum BiometricPermissionState {\n  /** App has been granted permission to use FaceID */\n  Granted = 'granted',\n  /** App has been denied permission to use FaceID */\n  Denied = 'denied',\n  /** User has not yet been prompted to allow FaceID */\n  Prompt = 'prompt',\n}\n\n/**\n * When type is set to 'DeviceSecurity', determines which aspects of the device to use to secure the vault.\n * Note: Android only supports `SystemPasscode` on Android 11 and greater.\n * @default `Both`\n */\nexport enum DeviceSecurityType {\n  /** Will allow a system passcode to secure the vault. On Android, only supported on Android 11 and greater. */\n  SystemPasscode = 'SystemPasscode',\n  /** WIll allow biometric hardware tos secure the vault. */\n  Biometrics = 'Biometrics',\n  /** WIll allow both SystemPasscode or Biometrics as an option to secure the vault. */\n  Both = 'Both',\n  /** No biometric security option will be used. */\n  None = 'None',\n}\n\n/**\n * The type of vault\n */\nexport enum VaultType {\n  /**\n   * No additional security is required in the app as long as the device was unlocked with a secure method.\n   *\n   * On iOS, this vault is synchronized via iCloud or new device setup.\n   * */\n  SecureStorage = 'SecureStorage',\n  /**\n   * Uses additional device features to add an additional layer of security while the user is in the app.\n   *\n   * On iOS, this vault is NOT synchronized via iCloud or new device setup.\n   * */\n  DeviceSecurity = 'DeviceSecurity',\n  /**\n   * User will set a custom passcode that will be used to access the vault.\n   *\n   * On iOS, this vault is NOT synchronized via iCloud or new device setup.\n   * */\n  CustomPasscode = 'CustomPasscode',\n  /** Data will persist only while the application is in memory.\n   *\n   *  On iOS, this vault is NOT synchronized via iCloud or new device setup.\n   */\n  InMemory = 'InMemory',\n}\n\n/**\n * For Android, when type is {@link VaultType.DeviceSecurity} and deviceSecurityType is {@link DeviceSecurityType.Both}, this options specifies if you want to\n * prefer a Strong Cryptographic Vault or the System Passcode fallback when they both aren't available.\n * @default `StrongVault`\n */\nexport enum AndroidBiometricCryptoPreference {\n  /** Prefer to use a strong cryptographic vault. */\n  StrongVault = 'StrongVault',\n  /** Prefer the system passcode fallback. */\n  SystemPasscode = 'SystemPasscode',\n}\n\n// OLD METHODS\n\n/**\n * The type of authentication the vault should be configured to allow.\n * @deprecated For use in legacy Vault Migrator only.\n * @ignore\n */\nexport enum AuthMode {\n  /**\n   * Biometrics authentication should only be allowed\n   */\n  BiometricOnly,\n\n  /**\n   * Passcode authentication should only be allowed\n   */\n  PasscodeOnly,\n\n  /**\n   * Both biometric and passcode authentication should be allowed\n   */\n  BiometricAndPasscode,\n\n  /**\n   * Both biometric and passcode authentication should be disabled.\n   * With this setting all data in the vault will be cleared on lock or\n   * if the app is closed. Stored data is kept only in memory.\n   */\n  InMemoryOnly,\n\n  /**\n   * Use biometrics if it is available, otherwise use passcode\n   */\n  BiometricOrPasscode,\n\n  /**\n   * Both biometric and passcode authentication will be disabled but any stored values\n   * will persist and be stored securely at rest using the keychain and will be available\n   * without needing to authenticate via passcode or biometrics when the device is unlocked.\n   */\n  SecureStorage,\n}\n\n/**\n * The interface for the Default Session.\n * Extend this interface to make a custom session\n *\n * @example\n * MyCustomSession extends DefaultSession {\n *   email: string;\n *   age: number;\n *   nicknames: string[];\n * }\n *\n * @ignore\n */\nexport interface DefaultSession {\n  username: string;\n  token: string;\n}\n\n/**\n * The possible values returned by {@link getBiometricType}\n * @property `touchID` | `faceID` | `none`\n * @ignore\n */\nexport type BiometricType = 'touchID' | 'faceID' | 'none';\n\n/**\n * An interface that describes the vault. In {@link IdentityVaultUser} this\n * defaults to `_lastUser` & `default` you can optionally add this to the constructor\n * to accomplish advanced use cases multi-tenant vaults.\n *\n * @deprecated For use in legacy Vault Migrator only.\n * @ignore\n */\nexport interface VaultDescriptor {\n  /**\n   * The username for the vault you wish to access\n   */\n  username: string;\n\n  /**\n   * The vaultId for the vault you wish to access\n   */\n  vaultId: string;\n}\n\n/**\n * The configuration returned from {@link IonicNativeAuthPlugin} when {@link getConfig} is called.\n *\n * @ignore\n */\nexport interface PluginConfiguration {\n  /**\n   * The values the uniquely identify the vault\n   */\n  descriptor: VaultDescriptor;\n\n  /**\n   * Whether biometric authentication is enabled for the vault\n   */\n  isBiometricsEnabled: boolean;\n\n  /**\n   * Whether passcode authentication is enabled for the vault\n   */\n  isPasscodeEnabled: boolean;\n\n  /**\n   * Whether {@link AuthMode.SecureStorage} is enabled for the vault\n   */\n  isSecureStorageModeEnabled: boolean;\n\n  /**\n   * Whether a passcode needs to be set with {@link setPasscode}\n   */\n  isPasscodeSetupNeeded: boolean;\n\n  /**\n   * Obscures the app when backgrounded to avoid leaking sensitive information, such as financial statements or balances.\n   * App screenshots won't work on Android 10 devices using gesture navigation if this option is set to true.\n   */\n  hideScreenOnBackground: boolean;\n\n  /**\n   * The amount of number of milliseconds the app can be in the background for until the vault locks\n   */\n  lockAfter: number;\n}\n\n/**\n * @hidden\n * @deprecated For use in legacy Vault Migrator only.\n * @ignore\n */\nexport interface VaultOptionsBase {\n  /**\n   * The {@link AuthMode} to configure a new vault with. Note: This will only\n   * affect newly created vaults. Vaults with existing data and configuration will use\n   * there previous configuration. They can be change by unlocking and then chaning the AuthMode.\n   *\n   * @default - {@link BiometricAndPasscode}\n   *\n   */\n  authMode?: AuthMode;\n\n  /**\n   * The amount of number of milliseconds the app can be in the background for until the vault locks.\n   * A value of 0 means the vault won't lock in the background.\n   * @default 0\n   */\n  lockAfter?: number;\n\n  /**\n   * Obscures the app when backgrounded to avoid leaking sensitive information, such as financial statements or balances.\n   * App screenshots won't work on Android 10 devices using gesture navigation if this option is set to true.\n   * @default false\n   */\n  hideScreenOnBackground?: boolean;\n\n  /**\n   * After too many failed authentication attempts, should the vault be cleared?\n   * @default true\n   */\n  shouldClearVaultAfterTooManyFailedAttempts?: boolean;\n\n  /**\n   * If biometric auth fails, allow system pin fallback.\n   * @default false\n   */\n  allowSystemPinFallback?: boolean;\n\n  /**\n   * The title text for the Android authentication prompt.\n   * @default \"Please Authenticate\"\n   */\n  androidPromptTitle?: string;\n\n  /**\n   * The subtitle text for the Android authentication prompt.\n   * @default null\n   */\n  androidPromptSubtitle?: string;\n\n  /**\n   * The description text for the Android authentication prompt.\n   * @default null\n   */\n  androidPromptDescription?: string;\n\n  /**\n   * The cancel text for the Android authentication prompt.\n   * @default \"Cancel\"\n   */\n  androidPromptNegativeButtonText?: string;\n\n  /**\n   * The subtitle text for the Android pin authentication prompt.\n   * @default null\n   */\n  androidPINPromptSubtitle?: string;\n  /**\n   * The title text for verifying a pin in the Android pin authentication prompt.\n   * @default \"Please Authenticate\"\n   */\n  androidPINPromptVerifyTitle?: string;\n  /**\n   * The title text for entering a new pin in the Android pin authentication prompt.\n   * @default \"Please Authenticate\"\n   */\n  androidPINPromptTitle?: string;\n  /**\n   * The title text for confirming a new pin in the Android pin authentication prompt.\n   * @default \"Please Authenticate\"\n   */\n  androidPINPromptConfirmTitle?: string;\n  /**\n   * The confirm button text for the Android pin authentication prompt.\n   * @default \"OK\"\n   */\n  androidPINPromptConfirmButtonText?: string;\n  /**\n   * The cancel button text for the Android pin authentication prompt.\n   * @default \"Cancel\"\n   */\n  androidPINPromptNegativeButtonText?: string;\n\n  /**\n   * For iOS, the prompt text for the biometric prompt\n   * @default \"Authenticate to log in\"\n   */\n  iosPromptText?: string;\n}\n\n/**\n * The options passed in to initialize the vault.\n *\n * @deprecated For use in legacy Vault Migrator only.\n * @ignore\n */\nexport interface VaultOptions extends VaultOptionsBase {\n  /**\n   * Whether or not to attempt to automatically restore the session when the vault is ready\n   * If {@link restoreSessionOnReady} and {@link unlockOnAccess} are\n   * both true the vault will be immediately unlocked & the session restored if onReady if the\n   * vault is in use.\n   * @default false\n   */\n  restoreSessionOnReady?: boolean;\n\n  /**\n   * Whether or not to attempt to automatically unlock the vault when a value is accessed.\n   * If {@link restoreSessionOnReady} and {@link unlockOnAccess} are\n   * both true the vault will be immediately unlocked & the session restored if onReady if the\n   * vault is in use.\n   * @default false\n   */\n  unlockOnAccess?: boolean;\n\n  /**\n   * Whether or not to attempt to automatically unlock the vault when the vault is ready\n   * @default false\n   */\n  unlockOnReady?: boolean;\n}\n\n/**\n * The configuration file returned to event handlers such as\n * {@link onConfigChange} and {@link onVaultReady}.\n * @ignore\n */\nexport interface VaultConfig extends VaultOptionsBase {\n  /**\n   * Whether a passcode needs to be set with {@link setPasscode}\n   */\n  isPasscodeSetupNeeded: boolean;\n}\n\n/**\n * The options passed the the {@link IonicNativeAuthPlugin} when creating a vault with {@link getVault}\n * @ignore\n */\nexport interface PluginOptions extends VaultDescriptor {\n  /**\n   * The amount of number of milliseconds the app can be in the background for until the vault locks\n   */\n  lockAfter?: number;\n\n  /**\n   * Obscures the app when backgrounded to avoid leaking sensitive information, such as financial statements or balances.\n   * App screenshots won't work on Android 10 devices using gesture navigation if this option is set to true.\n   *\n   * @default false\n   */\n  hideScreenOnBackground?: boolean;\n\n  /**\n   * After too many failed authentication attempts, should the vault be cleared?\n   * @default true\n   */\n  shouldClearVaultAfterTooManyFailedAttempts?: boolean;\n\n  /**\n   * If biometric auth fails, allow system pin fallback.\n   *\n   * Please note: when Android devices are set to allow system pin fallback, the behavior of the biometrics prompt changes.\n   * The OS biometric prompt will not report that biometrics failed nor that the user has been locked out of biometrics.\n   * It is only currently possible to know the user either canceled the authentication prompt, or was successful in verifying.\n   *\n   * @default false\n   */\n  allowSystemPinFallback?: boolean;\n\n  /**\n   * The title text for the Android authentication prompt.\n   * @default \"Please Authenticate\"\n   */\n  androidPromptTitle?: string;\n\n  /**\n   * The subtitle text for the Android authentication prompt.\n   * @default null\n   */\n  androidPromptSubtitle?: string;\n\n  /**\n   * The description text for the Android authentication prompt.\n   * @default null\n   */\n  androidPromptDescription?: string;\n\n  /**\n   * The cancel text for the Android authentication prompt.\n   * @default \"Cancel\"\n   */\n  androidPromptNegativeButtonText?: string;\n\n  /**\n   * The subtitle text for the Android pin authentication prompt.\n   * @default null\n   */\n  androidPINPromptSubtitle?: string;\n  /**\n   * The title text for verifying a pin in the Android pin authentication prompt.\n   * @default \"Please Authenticate\"\n   */\n  androidPINPromptVerifyTitle?: string;\n  /**\n   * The title text for entering a new pin in the Android pin authentication prompt.\n   * @default \"Please Authenticate\"\n   */\n  androidPINPromptTitle?: string;\n  /**\n   * The title text for confirming a new pin in the Android pin authentication prompt.\n   * @default \"Please Authenticate\"\n   */\n  androidPINPromptConfirmTitle?: string;\n  /**\n   * The confirm button text for the Android pin authentication prompt.\n   * @default \"OK\"\n   */\n  androidPINPromptConfirmButtonText?: string;\n  /**\n   * The cancel button text for the Android pin authentication prompt.\n   * @default \"Cancel\"\n   */\n  androidPINPromptNegativeButtonText?: string;\n\n  /**\n   * For iOS, the localized explanation for authentication shown in the dialog presented to the user.\n   * @default \"Authenticate to log in\"\n   */\n  iosPromptText?: string;\n\n  /**\n   * A handler that will receive events any time the vault is locked\n   */\n  onLock?(event: LockEvent): any;\n\n  /**\n   * A handler that will receive events any time the vault is unlocked\n   */\n  onUnlock?(event: PluginConfiguration): any;\n\n  /**\n   * A handler that will receive events any time the vault is configuration is changed\n   */\n  onConfig?(event: PluginConfiguration): any;\n\n  /**\n   * Called when there is an error during vault setup\n   *\n   * @param error - The {@link VaultError} that occurred.\n   *\n   */\n  onError?(error: VaultError): any;\n\n  /**\n   * Called when the vault is configured and available.\n   *\n   * @param vault - The {@link IdentityVault}  instance.\n   *\n   */\n  onReady?(vault: IdentityVault): any;\n}\n\n/**\n * The underlying vault API. You can gain direct access to the vault for more advanced usage by\n * using the {@link getVault IdentityVaultUser.getVault} method.\n * @ignore\n */\nexport interface IdentityVault {\n  /**\n   * The current configuration of the vault will stay current as long as {@link unsubscribe} is not called.\n   */\n  config?: PluginConfiguration;\n\n  /**\n   * Unsubscribe the instance from events about the vault.\n   *\n   * @example\n   * vault.unsubscribe();\n   *\n   */\n  unsubscribe(): Promise<void>;\n\n  /**\n   * Clear all vault data including stored tokens, values, and passcodes. The vault will be empty and unlocked after this.\n   *\n   * @example\n   * vault.clear()\n   */\n  clear(): Promise<void>;\n\n  /**\n   * Lock the vault clearing the contents from memory and requiring biometrics or passcode to unlock\n   *\n   * @example\n   * vault.lock()\n   */\n  lock(): Promise<void>;\n\n  /**\n   * Check whether the vault is currently locked\n   *\n   * @example\n   * if(!(await vault.isLocked())) {\n   *     // Do something if vault is not locked\n   * }\n   *\n   * @returns whether the vault is locked\n   */\n  isLocked(): Promise<boolean>;\n\n  /**\n   * Check whether the vault is currently empty\n   *\n   * @example\n   * if(!(await vault.isEmpty())) {\n   *     // Do something if vault is not empty\n   * }\n   *\n   * @returns whether the vault is empty\n   */\n  isEmpty(): Promise<boolean>;\n\n  /**\n   * Check whether the biometrics are locked on the device\n   *\n   * @example\n   * const bioLockedOut = await vault.isLockedOutOfBiometrics();\n   *\n   * @returns whether biometrics are locked\n   */\n  isLockedOutOfBiometrics(): Promise<boolean>;\n\n  /**\n   * Check whether the vault has any values stored in it.\n   *\n   * @example\n   * const vaultIsInUse = await vault.isInUse();\n   *\n   * @returns whether the vault has stored values\n   */\n  isInUse(): Promise<boolean>;\n\n  /**\n   * Get the current configuration of the vault\n   *\n   * @example\n   * const config = await vault.getConfig();\n   *\n   * @returns the configuration\n   */\n  getConfig(): Promise<PluginConfiguration>;\n\n  /**\n   * Check how many remaining failed attempts are left until vault clears\n   *\n   * @example\n   * const remainingAttempts = await vault.remainingAttempts();\n   *\n   * @returns the number of remaining attempts\n   */\n  remainingAttempts(): Promise<number>;\n\n  /**\n   * Get the username associated with the vault\n   *\n   * @example\n   * const username = await vault.getUsername();\n   *\n   * @returns the username for the vault\n   */\n  getUsername(): Promise<string>;\n\n  /**\n   * Store a value securely in the token slot. This is equivalent to calling {@link storeValue storeValue(\"token\", token)}.\n   *\n   * @example\n   * vault.storeToken(token);\n   *\n   * @param token - the value to store in the token slot\n   *\n   * @throws {@link VaultError} - if vault is locked, or if passcode is enabled but passcode has not been setup\n   */\n  storeToken(token: any): Promise<void>;\n\n  /**\n   * Get any data stored in the token slot. This is equivalent to calling {@link getValue getValue(\"token\")}.\n   *\n   * @example\n   * const token = await vault.getToken();\n   *\n   * @returns token data\n   *\n   * @throws {@link VaultError} - if vault is locked\n   */\n  getToken(): Promise<any>;\n\n  /**\n   * Store data securely under the given key.\n   *\n   * @example\n   * vault.storeValue(\"email\", emailToken);\n   *\n   * @param key - the key to store in the value in\n   * @param value - the value to store\n   *\n   * @throws {@link VaultError} - if vault is locked, or if passcode is enabled but passcode has not been setup\n   */\n  storeValue(key: string, value: any): Promise<void>;\n\n  /**\n   * Removes data under the given key.\n   *\n   * @example\n   * vault.removeValue(\"email\");\n   *\n   * @param key - the key to remove the value from\n   *\n   * @throws {@link VaultError} - if vault is locked, or if passcode is enabled but passcode has not been setup\n   */\n  removeValue(key: string): Promise<void>;\n\n  /**\n   * Get a value stored under the given key.\n   *\n   * @param key - the key where the value is stored\n   *\n   * @returns the value stored at the key\n   *\n   * @throws {@link VaultError} - if vault is locked\n   */\n  getValue(key: string): Promise<any>;\n\n  /**\n   * Get all keys with stored values.\n   *\n   * @example\n   * const keys = await vault.getKeys();\n   *\n   * @returns array with all keys\n   *\n   * @throws {@link VaultError} - if vault is locked\n   */\n  getKeys(): Promise<string[]>;\n\n  /**\n   * Get the type of biometrics the device supports\n   *\n   * @example\n   * const biometricType = await vault.getBiometricType();\n   *\n   * @deprecated this method has been deprecated in favor of {@link getAvailableHardware}\n   *\n   * @returns the type of biometrics the device supports\n   */\n  getBiometricType(): Promise<BiometricType>;\n\n  /**\n   * Gets the types of biometrics the device supports.\n   *\n   * Please note, this method only shows the biometrics the device is capable of, and does\n   * not reflect whether the biometric methods are enrolled or enabled.\n   *\n   * Traditionally Android has only supported fingerprint biometrics through the SDK. As of\n   * Android 10 multiple options are supported. Samsung devices can offer iris and face\n   * biometrics that exists outside the scope of the Android SDK. Since there is no official\n   * Android SDK support to detect those Samsung features, we attempt to determine their\n   * presence based on if the device has the Samsung face or iris biometrics software installed.\n   *\n   * @example\n   * const availableHardware = await vault.getAvailableHardware();\n   *\n   * @returns the list of biometrics the device supports\n   */\n  getAvailableHardware(): Promise<SupportedBiometricType[]>;\n\n  /**\n   * Enable/Disable Biometric authentication for the vault\n   *\n   * @example\n   * vault.setBiometricsEnabled(true);\n   *\n   * @param isBiometricsEnabled - whether or not biometrics should be enabled\n   *\n   * @throws {@link VaultError} - if biometrics is unavailable or the vault is locked\n   */\n  setBiometricsEnabled(isBiometricsEnabled: boolean): Promise<void>;\n\n  /**\n   * Set whether or not the screen will be obscured in app switcher mode\n   *\n   * @param enabled\n   * @param dimBiometrics? - optional boolean for Android to obscure\n   * the screen behind biometric prompts via dimming the background instead of the splash screen.\n   *\n   * @returns void\n   */\n  setHideScreenOnBackground(enabled: boolean, dimBiometrics?: boolean): Promise<void>;\n\n  /**\n   * Check whether or not biometrics is enabled on the vault\n   *\n   * @example\n   * const biometricsEnabled = await vault.isBiometricsEnabled();\n   *\n   * @returns whether or not biometrics is enabled\n   */\n  isBiometricsEnabled(): Promise<boolean>;\n\n  /**\n   * Check whether or not biometrics is supported by the device\n   * and has been configured by the current user of the device\n   *\n   * @example\n   * const biometricsAvailable = await vault.isBiometricsAvailable();\n   *\n   * @returns whether or not biometrics is available\n   */\n  isBiometricsAvailable(): Promise<boolean>;\n\n  /**\n   * Check whether or not biometrics is supported by the device\n   *\n   * @example\n   * const biometricsSupported = await vault.isBiometricsSupported();\n   *\n   * @returns whether or not biometrics is supported\n   */\n  isBiometricsSupported(): Promise<boolean>;\n\n  /**\n   * Check whether or not a passcode needs to be set for the vault using {@link setPasscode}\n   *\n   * @example\n   * const passcodeSetupNeeded = await vault.isPasscodeSetupNeeded();\n   *\n   * @returns whether or not the passcode needs to be set\n   */\n  isPasscodeSetupNeeded(): Promise<boolean>;\n\n  /**\n   * Set or Change the passcode for the vault\n   *\n   * @example\n   * vault.setPasscode();\n   *\n   * @param passcode - The passcode to set. If left null a native dialog will prompt the user to enter it.\n   *\n   * @throws {@link VaultError} - if the vault is locked, passcode is disabled, user canceled pin prompt, or pin was mismatched\n   */\n  setPasscode(passcode?: string): Promise<void>;\n\n  /**\n   * Check if passcode authentication is enabled for the vault\n   *\n   * @example\n   * const passcodeEnabled = await vault.isPasscodeEnabled();\n   *\n   * @returns whether or not the passcode is enabled\n   */\n  isPasscodeEnabled(): Promise<boolean>;\n\n  /**\n   * Enable/Disable passcode authentication for the vault\n   *\n   * @example\n   * vault.setPasscodeEnabled(true);\n   *\n   * @param isPasscodeEnabled - whether or not passcode should be enabled\n   *\n   * @throws {@link VaultError} - if the vault is locked\n   */\n  setPasscodeEnabled(isPasscodeEnabled: boolean): Promise<void>;\n\n  /**\n   * Check if {@link AuthMode.SecureStorage} is enabled for the vault\n   *\n   * @example\n   * const secureStorageModeEnabled = await vault.isSecureStorageModeEnabled();\n   *\n   * @returns whether or not the secure storage mode is enabled\n   */\n  isSecureStorageModeEnabled(): Promise<boolean>;\n\n  /**\n   * Enable/Disable secure storage mode for the vault. Setting {@link AuthMode.SecureStorage} automatically disables passcode\n   * and biometric authentication and allows for session values to be stored persistently and securely at rest using the keychain but allowing the user\n   * to access the data without authenticating as long as the device is unlocked.\n   *\n   * @example\n   * vault.setSecureStorageModeEnabled(true);\n   *\n   * @param isSecureStorageModeEnabled - whether or not secure storage mode should be enabled\n   *\n   * @throws {@link VaultError} - if the vault is locked\n   */\n  setSecureStorageModeEnabled(isSecureStorageModeEnabled: boolean): Promise<void>;\n\n  /**\n   * Unlock the vault using either passcode or biometrics\n   *\n   * @example\n   * vault.unlock();\n   *\n   * @param usingPasscode - whether or not to use passcode to unlock the vault\n   * @param passcode - The passcode to use. If left null a native dialog will prompt the user to enter it.\n   *\n   * @throws {@link VaultError} - if the vault is locked, the unlock type wasn't enabled, user canceled pin prompt, or pin was mismatched\n   */\n  unlock(usingPasscode?: boolean, passcode?: string): Promise<void>;\n}\n\n/**\n * The lock event passed to the {@link onVaultLocked} handler.\n * @ignore\n */\nexport interface LockEvent {\n  /**\n   * If the data was persisted to the device before lock\n   */\n  saved: boolean;\n  /**\n   * If the lock was due to a background timeout\n   */\n  timeout: boolean;\n}\n\n/**\n * The main class which you can extend in order to implement vault usage.\n *  @typeparam `T` must extend {@link DefaultSession}\n *\n * @usage\n * ```typescript\n * interface MyCustomSession extends DefaultSession {\n *   // username & token are inherited\n *   email: string;\n *   age: number;\n *   nicknames: string[];\n * }\n *\n * export class IdentityService extends IonicIdentityVaultUser<MyCustomSession> {\n *\n * constructor(private http: HttpClient, private router: Router, platform: Platform) {\n *   super(platform, {\n *     authMode: AuthMode.BiometricAndPasscode,\n *     restoreSessionOnReady: false,\n *     unlockOnReady: false, // set true to auto prompt the user to unlock when vault is ready\n *     unlockOnAccess: true,\n *     lockAfter: 5000, // lock after 5 seconds in the background\n *     hideScreenOnBackground: true\n *   });\n *\n *   onVaultUnlocked(config: VaultConfig) {\n *     //Route to my home page\n *   }\n *\n *   onVaultLocked(event: LockEvent) {\n *     //Route to my login page\n *   }\n *\n * }\n * ```\n * @ignore\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport interface IdentityVaultUser<T extends {} = DefaultSession> {\n  /**\n   * Get raw access to the underlying vault api\n   */\n  getVault(): Promise<IdentityVault>;\n\n  /**\n   * The stored session data\n   */\n  getSession(): Promise<T | undefined>;\n\n  /**\n   * Get the session from memory (without checking the vault for it)\n   */\n  getSession(): Promise<T | undefined>;\n\n  /**\n   * Called when the vault has been locked\n   * @param event - The data about the lock event {@link LockEvent}\n   */\n  onVaultLocked(event: LockEvent): any;\n\n  /**\n   * Called when the vault has been unlocked\n   *\n   * @param config - The current configuration {@link VaultConfig} of the vault\n   */\n  onVaultUnlocked(state: VaultConfig): any;\n\n  /**\n   * Called when there has been a configuration change in the vault\n   *\n   * @param config - The updated configuration {@link VaultConfig} of the vault\n   */\n  onConfigChange(state: VaultConfig): any;\n\n  /**\n   * Called when the vault is ready\n   *\n   * @param config - The current configuration {@link VaultConfig} of the vault\n   *\n   * @returns - A promise that resolves when the vault is successfully configured and available.\n   */\n  onVaultReady(state: VaultConfig): any;\n\n  /**\n   * Called when there is an error during vault setup\n   *\n   * @param error - The {@link VaultError} that occurred.\n   *\n   */\n  onSetupError(error: VaultError): any;\n\n  /**\n   * Called when the session object is restored.\n   *\n   * @param session - The {@link DefaultSession} or user defined session that occurred.\n   *\n   */\n  onSessionRestored(session: T): any;\n\n  /**\n   * Called when the session fails to auto restore\n   *\n   * @param err - The {@link VaultError} or that occurred.\n   *\n   */\n  onSessionRestoreError(err: VaultError): any;\n\n  /**\n   * Called when the automatically unlocking the vault after it is ready fails.\n   *\n   * @param err - The {@link VaultError} or that occurred.\n   *\n   */\n  onUnlockOnReadyError(err: VaultError): any;\n\n  /**\n   * Called when attempting passcode unlock to allow for user defined passcode prompts.\n   *\n   * @param isPasscodeSetRequest - Whether or not this is a request to set the passcode.\n   *\n   * @returns - a string to use as the passcode of undefined to use native prompts\n   *\n   */\n  onPasscodeRequest(isPasscodeSetRequest: boolean): Promise<string | void>;\n\n  /**\n   * Promise ensuring the user vault is ready to be accessed or denoting an error in setup;\n   *\n   * @returns - A promise that resolves when the vault is succesfully configured and available.\n   */\n  ready(): Promise<void>;\n\n  /**\n   * Get the type of biometrics the device supports\n   *\n   * @returns the type of biometrics the device supports\n   */\n  getBiometricType(): Promise<BiometricType>;\n\n  /**\n   * Set the {@link AuthMode} for the vault. The vault must be unlocked or this will throw an error.\n   *\n   * @param authMode - The {@link AuthMode} to use.\n   *\n   * @throws {@link VaultError} - If the vault is locked or the mode is unavailale due to device hardware\n   */\n  setAuthMode(authMode: AuthMode): Promise<void>;\n\n  /**\n   * Get the {@link AuthMode} for the vault.\n   */\n  getAuthMode(): Promise<AuthMode>;\n\n  /**\n   * Returns the underlying Plugin Implementation. This can be overriden in the sub class\n   * service to allow for a customer browser implementation. Note that when overriding this\n   * with a browser implementation you should use the storeValue/getValue functions with the key\n   * `session` to store & retrieve the session as described or by {@link DefaultSession} or the interface\n   * that extends it.\n   *\n   * @usage\n   * ```typescript\n   * getPlugin(): IonicNativeAuthPlugin {\n   *   if (this.platform.is('cordova')) {\n   *     return super.getPlugin();\n   *   }\n   *   // MyCustomerBrowserImplementation must implement the IonicNativeAuthPlugin interface\n   *   // make sure getValue('session') & storeValue('session') store & retrieve the session.\n   *   return MyCustomBrowserImplementation();\n   * }\n   * ```\n   */\n  getPlugin(): IonicNativeAuthPlugin;\n\n  /**\n   * Lock the user out without clearing their secure session\n   * information from the vault\n   */\n  lockOut(): Promise<void>;\n\n  /**\n   * Unlock the user's vault using the AuthMode configured for the vault\n   * or the override passed in to the call.\n   * This will call the {@link onPasscodeRequest} handler\n   * if the specified {@link AuthMode} allows for it to allow for user defined passcode prompt\n   * You can get more fine grain contol using the {@link IdentityVault} directly\n   * by calling {@link getVault}\n   */\n  unlock(authMode?: AuthMode): Promise<void>;\n\n  /**\n   * Log the user out entirely, and forget any stored\n   * authentication tokens\n   */\n  logout(): Promise<void>;\n\n  /**\n   * Check if there are any saved sessions in the vault\n   */\n  hasStoredSession(): Promise<boolean>;\n\n  /**\n   * Restore the session from the vault\n   */\n  restoreSession(): Promise<T | undefined>;\n\n  /**\n   * Store the session to the vault\n   * @param session - the session to store\n   */\n  saveSession(session: T): Promise<void>;\n\n  /**\n   * Login a new session for the user. This method will clear the vault & any stored PIN for\n   * previously stored sessions.\n   *\n   * @param session - the session to store\n   * @param authMode? - optionally specify the {@link AuthMode} to  use for the new session.\n   * Defaults to the current configuration for the vault if undefined.\n   *\n   */\n  login(session: T, authMode?: AuthMode): Promise<void>;\n\n  /**\n   * Enable/Disable Biometric authentication\n   *\n   * @param isBiometricsEnabled - whether or not biometrics should be enabled\n   *\n   * @throws {@link VaultError} - if biometrics is unavailable or the vault is locked\n   */\n  setBiometricsEnabled(isBiometricsEnabled: boolean): Promise<void>;\n\n  /**\n   * Set whether or not the screen will be obscured in app switcher mode\n   *\n   * @param enabled\n   * @param dimBiometrics? - optional parameter for Android to obscure the screen behind biometric prompts via dimming the background instead of the splash screen.\n   *\n   * @returns void\n   */\n  setHideScreenOnBackground(enabled: boolean, dimBiometrics?: boolean): Promise<void>;\n\n  /**\n   * Enable/Disable passcode authentication. This will cause {@link setPasscode}\n   * to fire if passcode setup is required causing\n   * the {@link onPasscodeRequest} handler to fire\n   * to allow for user defined passcode prompt.\n   * You can get more fine grain contol using the {@link IdentityVault} directly\n   * by calling {@link getVault}\n   *\n   * @param isPasscodeEnabled - whether or not passcode should be enabled\n   *\n   * @throws {@link VaultError} - if the vault is locked\n   */\n  setPasscodeEnabled(isPasscodeEnabled: boolean): Promise<void>;\n\n  /**\n   * Set or change the passcode for the user\n   * This will call the {@link onPasscodeRequest} handler\n   * to allow for user defined passcode prompt.\n   * You can get more fine grain contol using the {@link IdentityVault} directly\n   * by calling {@link getVault}\n   *\n   * @throws {@link VaultError} - if the vault is locked, passcode is disabled, user canceled pin prompt, or pin was mismatched\n   */\n  setPasscode(): Promise<void>;\n\n  /**\n   * Check whether or not biometrics is enabled on the vault\n   *\n   * @returns whether or not biometrics is enabled\n   */\n  isBiometricsEnabled(): Promise<boolean>;\n\n  /**\n   * Check whether or not biometrics is supported by the device\n   * and has been configured by the current user of the device\n   *\n   * @returns whether or not biometrics is available\n   */\n  isBiometricsAvailable(): Promise<boolean>;\n\n  /**\n   * Check whether or not biometrics is supported by the device\n   *\n   * @returns whether or not biometrics is supported\n   */\n  isBiometricsSupported(): Promise<boolean>;\n\n  /**\n   * Check if passcode authentication is enabled for the vault\n   *\n   * @returns whether or not the passcode is enabled\n   */\n  isPasscodeEnabled(): Promise<boolean>;\n\n  /**\n   * Check if {@link AuthMode.SecureStorage} is enabled for the vault\n   *\n   * @returns whether or not the secure storage mode is enabled\n   */\n  isSecureStorageModeEnabled(): Promise<boolean>;\n}\n\n/**\n * The native plugin\n * @ignore\n */\nexport interface IonicNativeAuthPlugin {\n  getVault(config: PluginOptions): IdentityVault;\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import type { IdentityVaultConfig } from './IdentityVaultConfig';\nimport type { VaultInterface, VaultLockEvent } from './VaultInterface';\nimport type { VaultError } from './definitions';\nimport { VaultErrorCodes } from './definitions';\n\ntype Callback<T = any> = (value: T) => void;\ntype EmptyCallback = () => void;\nconst STORAGE_KEYS = {\n  DATA: 'data',\n};\n\n/**\n * THIS VAULT DOES NOT IMPLEMENT SECURE STORAGE IN THE BROWSER. It only exists\n * as a way to run browser-compatible code in place of Identity Vault. Browsers\n * do not have a secure storage element same as native devices. This class\n * is intended to be used to enable running your application in the browser while\n * simulating the functions of Identity Vault using sessionStorage.\n *\n * Represents a vault implementation for browser compatibility.\n */\nexport class BrowserVault implements VaultInterface {\n  /** @ignore */\n  private isVaultLocked = false;\n\n  /** @ignore */\n  private isVaultEmpty = true;\n\n  /** @ignore */\n  private configCallback: Callback<IdentityVaultConfig> | undefined;\n\n  /** @ignore */\n  private errorCallback: Callback<VaultError> | undefined;\n\n  /** @ignore */\n  private lockCallback: Callback<VaultLockEvent> | undefined;\n\n  /** @ignore */\n  private unlockCallback: EmptyCallback | undefined;\n\n  /** @ignore */\n  config: IdentityVaultConfig;\n\n  /**\n   * @usage\n   * ```typescript\n   * const vault = new Vault({\n   *  key: 'com.company.myvaultapp',\n   *  type: 'CustomPasscode',\n   *  deviceSecurityType: 'Both',\n   *  lockAfterBackgrounded: 2000,\n   * });\n   * ```\n   * @param config\n   */\n  constructor(config: IdentityVaultConfig) {\n    console.warn(\n      'THIS VAULT DOES NOT IMPLEMENT SECURE STORAGE IN THE BROWSER AND IS NOT INTENDED FOR PRODUCTION USE. It only exists as a way to run browser-compatible code in place of Identity Vault. Browsers do not have a secure storage element same as native devices. This class is intended to be used to enable running your application in the browser while simulating the functions of Identity Vault using sessionStorage.'\n    );\n    this.config = Object.assign(\n      {\n        deviceSecurityType: 'Both',\n        androidBiometricsPreferStrongVaultOrSystemPasscode: 'StrongVault',\n        shouldClearVaultAfterTooManyFailedAttempts: false,\n        customPasscodeInvalidUnlockAttempts: 5,\n        unlockVaultOnLoad: false,\n      },\n      config\n    );\n    this.isVaultLocked = config.unlockVaultOnLoad ? false : true;\n  }\n\n  /** @deprecated Deprecated in favor of using the isEmpty method. */\n  /** See {@link Vault.doesVaultExist} */\n  doesVaultExist(): Promise<boolean> {\n    const data = this.getDataObj();\n    return Promise.resolve(!!data);\n  }\n\n  /** See {@link Vault.clear} */\n  clear(): Promise<void> {\n    this.unlockIfLocked();\n    sessionStorage.removeItem(this.getKey(STORAGE_KEYS.DATA));\n    this.isVaultEmpty = true;\n    return Promise.resolve();\n  }\n\n  /** See {@link Vault.exportVault} */\n  exportVault(): Promise<Record<string, string>> {\n    this.unlockIfLocked();\n    const data = this.getDataObj();\n    return Promise.resolve(data ?? {});\n  }\n\n  /** See {@link Vault.importVault} */\n  importVault(data: Record<string, string>): Promise<void> {\n    this.setDataObj(data);\n    return Promise.resolve();\n  }\n\n  /** See {@link Vault.isLocked} */\n  isLocked(): Promise<boolean> {\n    return Promise.resolve(this.isVaultLocked);\n  }\n\n  /** See {@link Vault.isEmpty} */\n  isEmpty(): Promise<boolean> {\n    return Promise.resolve(this.isVaultEmpty);\n  }\n\n  /** See {@link Vault.getKeys} */\n  getKeys(): Promise<string[]> {\n    this.unlockIfLocked();\n    const data = this.getDataObj();\n    if (!data) return Promise.resolve([]);\n    return Promise.resolve(Object.keys(data));\n  }\n\n  /** See {@link Vault.getValue} */\n  getValue<T = any>(key: string): Promise<T | null> {\n    this.unlockIfLocked();\n    const data = this.getDataObj();\n    return Promise.resolve(data?.[key] ?? null);\n  }\n\n  /** See {@link Vault.lock} */\n  lock(): Promise<void> {\n    this.lockCallback?.({ timeout: false });\n    return Promise.resolve();\n  }\n\n  /** See {@link Vault.removeValue} */\n  removeValue(key: string): Promise<void> {\n    this.unlockIfLocked();\n    const data = this.getDataObj();\n    if (!data) return Promise.resolve();\n    const { [key]: removed, ...dataAfterRemoval } = data;\n    this.setDataObj(dataAfterRemoval);\n    return Promise.resolve();\n  }\n\n  /** See {@link Vault.setCustomPasscode} */\n  setCustomPasscode(passcode: string): Promise<void> {\n    return Promise.resolve();\n  }\n\n  /** See {@link Vault.setValue} */\n  setValue<T = any>(key: string, value: T): Promise<void> {\n    this.unlockIfLocked();\n    const data = this.getDataObj();\n    if (!data) {\n      this.setDataObj({ [key]: value });\n    } else {\n      this.setDataObj({ ...data, [key]: value });\n    }\n    return Promise.resolve();\n  }\n\n  /** See {@link Vault.onConfigChanged} */\n  onConfigChanged(callback: Callback<IdentityVaultConfig>): void {\n    this.configCallback = callback;\n  }\n\n  /** See {@link Vault.onError} */\n  onError(callback: Callback<VaultError>): void {\n    this.errorCallback = callback;\n  }\n\n  /** See {@link Vault.onLock} */\n  onLock(callback: Callback<VaultLockEvent>): void {\n    this.lockCallback = callback;\n  }\n\n  /** See {@link Vault.onPasscodeRequested} */\n  onPasscodeRequested(callback: (isPasscodeSetRequest: boolean, onComplete: (code: string) => void) => void): void;\n  onPasscodeRequested(callback: (isPasscodeSetRequest: boolean) => Promise<void>): void;\n  onPasscodeRequested(callback: (isPasscodeSetRequest: boolean, onComplete: (code: string) => void) => void): void {\n    // No passcode support\n  }\n\n  /** See {@link Vault.onUnlock} */\n  onUnlock(callback: EmptyCallback): void {\n    this.unlockCallback = callback;\n  }\n\n  /** See {@link Vault.unlock} */\n  unlock(): Promise<void> {\n    this.unlockCallback?.();\n    return Promise.resolve();\n  }\n\n  /** See {@link Vault.updateConfig} */\n  updateConfig(config: IdentityVaultConfig): Promise<void> {\n    this.config = config;\n    this.configCallback?.(config);\n    return Promise.resolve();\n  }\n\n  /** @ignore */\n  requestBiometricPrompt(): Promise<boolean> {\n    this.unlockIfLocked();\n    return Promise.resolve(true);\n  }\n\n  /** @ignore */\n  private unlockIfLocked(): void {\n    if (this.isVaultLocked) {\n      this.unlock();\n    }\n  }\n\n  /** @ignore */\n  private getDataObj(): Record<string, any> | null {\n    const value = sessionStorage.getItem(this.getKey(STORAGE_KEYS.DATA));\n    if (!value) return null;\n    try {\n      const dataObj = JSON.parse(value);\n      this.isVaultEmpty = Object.keys(dataObj).length <= 0;\n      return dataObj;\n    } catch (e) {\n      this.errorCallback?.({\n        message: 'Unable to parse data store',\n        code: VaultErrorCodes.Unknown,\n      });\n      return null;\n    }\n  }\n\n  /** @ignore */\n  private setDataObj(data: Record<string, any>): void {\n    try {\n      const dataStr = JSON.stringify(data);\n      sessionStorage.setItem(this.getKey(STORAGE_KEYS.DATA), dataStr);\n      this.isVaultEmpty = Object.keys(data).length <= 0;\n    } catch (e) {\n      this.errorCallback?.({\n        message: 'Unable to serialize data',\n        code: VaultErrorCodes.Unknown,\n      });\n    }\n  }\n\n  /** @ignore */\n  private getKey(key: string): string {\n    return `IV-${this.config.key}-${key}`;\n  }\n}\n","import type { IdentityVaultConfig } from './IdentityVaultConfig';\nimport type { VaultInterface, VaultLockEvent } from './VaultInterface';\nimport type { VaultError } from './definitions';\nimport { AndroidBiometricCryptoPreference, DeviceSecurityType, VaultErrorCodes, VaultType } from './definitions';\n\n/**\n * Represents a vault for secure value storage\n */\nexport class Vault implements VaultInterface {\n  /** @ignore */\n  private passCodeRequestedCallback?:\n    | ((isPasscodeSetRequest: boolean, onComplete: (code: string) => void) => void)\n    | ((isPasscodeSetRequest: boolean) => Promise<void>);\n\n  /** @ignore */\n  private defaultConfig = {\n    deviceSecurityType: DeviceSecurityType.None,\n    androidBiometricsPreferStrongVaultOrSystemPasscode: AndroidBiometricCryptoPreference.StrongVault,\n    shouldClearVaultAfterTooManyFailedAttempts: false,\n    customPasscodeInvalidUnlockAttempts: 5,\n    unlockVaultOnLoad: false,\n  };\n\n  /**\n   * Contains the current config properties of the vault.\n   * See the {@link IdentityVaultConfig | IdentityVaultConfig} docs page for more info.\n   *\n   * @usage\n   * ```typescript\n   * const newVault = new Vault(vaultConfig);\n   * if(newVault.config.deviceSecurityType === DeviceSecurityType.None) {\n   *   ...\n   * }\n   * ```\n   *\n   */\n  config: IdentityVaultConfig;\n\n  /**\n   * @usage\n   * ```typescript\n   * const vault = new Vault({\n   *  key: 'com.company.myvaultapp',\n   *  type: 'CustomPasscode',\n   *  deviceSecurityType: DeviceSecurityType.None,\n   *  lockAfterBackgrounded: 2000,\n   * });\n   * ```\n   * @param config\n   */\n  constructor(config: IdentityVaultConfig) {\n    // set defaults\n    this.config = Object.assign(this.defaultConfig, config);\n\n    // setting sane defaults\n    if (config.deviceSecurityType === DeviceSecurityType.None && config.type === VaultType.DeviceSecurity) {\n      config.deviceSecurityType = DeviceSecurityType.Both;\n    }\n\n    this.resume = this.resume.bind(this);\n    this.handleError = this.handleError.bind(this);\n    this.setup().then(() => {\n      this.getPersistedVaultConfig();\n    });\n  }\n\n  /**\n   * Resolves true if a vault with the same key already exists, and false if not.\n   * The vault does not need to be unlocked to check.\n   *\n   * __Note:__\n   *  - Using {@link Vault.removeValue | removeValue()} to remove all of your vault data will not cause this function to resolve false, however {@link Vault.clear | clear()} will.\n   *  - A vault only exists once it has been interacted with at least once via any of the following instance methods.\n   *    - {@link Vault.setValue | setValue()}\n   *    - {@link Vault.removeValue | removeValue()}\n   *    - {@link Vault.importVault | importVault()}\n   *    - {@link Vault.exportVault | exportVault()}\n   *    - {@link Vault.unlock | unlock()}\n   *    - {@link Vault.updateConfig | updateConfig()}\n   *\n   * @usage\n   * ```typescript\n   * const vault = new Vault(existingVaultConfig);\n   * const vaultExists = await vault.doesVaultExists()\n   * if (!vaultExists) {\n   *  // the vault does not exist...\n   * }\n   * ```\n   *\n   * @deprecated Deprecated in favor of using the {@link Vault.isEmpty | isEmpty()} method.\n   */\n  doesVaultExist(): Promise<boolean> {\n    return new Promise<boolean>((resolve, reject) => {\n      cordova.exec(\n        (data) => {\n          resolve(JSON.parse(data));\n        },\n        (error) => {\n          this.handleError(resolve, reject, error, () => this.doesVaultExist());\n        },\n        'VaultPlugin',\n        'doesVaultExist',\n        [this.config]\n      );\n    });\n  }\n\n  /**\n   * Clears out the current vault and removes it from the system.\n   * Note: The vault does not need to be unlocked in order to clear it. No credentials are checked\n   * when clearing the vault.\n   *\n   * @usage\n   * ```typescript\n   * const vault = new Vault(existingVaultConfig);\n   * await vault.clear();\n   * ```\n   */\n  clear(): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      cordova.exec(\n        (data) => {\n          resolve();\n        },\n        (error) => {\n          this.handleError(resolve, reject, error, () => this.clear());\n        },\n        'VaultPlugin',\n        'clear',\n        [this.config]\n      );\n    });\n  }\n\n  /**\n   * Exports the data of the current vault in its entirety.\n   * The data is a map with keys that are strings and values that are JSON.\n   * Calling `exportVault` will attempt to unlock the vault if it is currently locked.\n   *\n   * @usage\n   * ```typescript\n   * const vault = new Vault(existingVaultConfig);\n   * const data = await vault.exportVault();\n   * ```\n   *\n   * @return The resolved object is a map with string keys and string values.\n   *\n   */\n  exportVault(): Promise<{ [key: string]: string }> {\n    return new Promise<{ [key: string]: string }>((resolve, reject) => {\n      cordova.exec(\n        (data) => {\n          resolve(JSON.parse(data));\n        },\n        (error) => {\n          this.handleError(resolve, reject, error, () => this.exportVault());\n        },\n        'VaultPlugin',\n        'exportVault',\n        [this.config]\n      );\n    });\n  }\n\n  /**\n   * Imports data into the vault, replacing the current contents of the vault.\n   * The data is a map with keys that are strings and values that are JSON.\n   * Calling `importVault` will attempt to unlock the vault if it is currently locked.\n   *\n   * @usage\n   * ```typescript\n   * const dataFromElsewhere = await getUserData();\n   * const newVault = new Vault(vaultConfig);\n   * await newVault.importVault(dataFromElsewhere);\n   * ```\n   *\n   * @param data The entire data object to be imported. The shape of data must be {[key: string]: string}.\n   *\n   */\n  importVault(data: { [key: string]: string }): Promise<void> {\n    const jsonData = JSON.stringify(data);\n    return new Promise<void>((resolve, reject) => {\n      cordova.exec(\n        resolve,\n        (error) => {\n          this.handleError(resolve, reject, error, () => this.importVault(data));\n        },\n        'VaultPlugin',\n        'importVault',\n        [this.config, jsonData]\n      );\n    });\n  }\n\n  /**\n   * Checks if the vault is currently in a locked state, which signifies that the contents\n   * of the secure vault are not currently accessible. `isLocked` can also return true if the\n   * vault does not exist.\n   *\n   * @usage\n   * ```typescript\n   * const vault = new Vault(existingVaultConfig);\n   * const locked = await vault.isLocked();\n   * if (locked) {\n   *  // vault is locked (or does not exist);\n   * }\n   * ```\n   */\n  isLocked(): Promise<boolean> {\n    return new Promise<boolean>((resolve, reject) => {\n      cordova.exec(\n        (data) => {\n          resolve(JSON.parse(data));\n        },\n        (error) => {\n          this.handleError(resolve, reject, error);\n        },\n        'VaultPlugin',\n        'isLocked',\n        [this.config]\n      );\n    });\n  }\n\n  /**\n   * Returns an array of keys that are currently in the vault.\n   * Calling `getKeys` will attempt to unlock the vault if it is currently locked.\n   *\n   * @usage\n   * ```typescript\n   * const vault = new Vault(existingVaultConfig);\n   * const allKeys = await vault.getKeys();\n   * allKeys.forEach((key) => {\n   *  // do something with the key\n   * });\n   * ```\n   */\n  getKeys(): Promise<string[]> {\n    return new Promise<string[]>((resolve, reject) => {\n      cordova.exec(\n        (data) => {\n          resolve(JSON.parse(data));\n        },\n        (error) => {\n          this.handleError(resolve, reject, error, () => this.getKeys());\n        },\n        'VaultPlugin',\n        'getKeys',\n        [this.config]\n      );\n    });\n  }\n\n  /**\n   * Gets the value for a given key. Returns null if the key does not exist.\n   * Calling `getValue` will attempt to unlock the vault if it is currently locked.\n   *\n   * @usage\n   * ```typescript\n   * const vault = new Vault(existingVaultConfig);\n   * const userFirstName = await vault.getValue<string>(\"firstname\");\n   * ```\n   *\n   * @param key The key to look up the value for\n   *\n   */\n  getValue<T = any>(key: string): Promise<T | null> {\n    return new Promise<T | null>((resolve, reject) => {\n      cordova.exec(\n        (data: string | null) => {\n          if (!data) {\n            // android returns null as an empty string, so manually convert it here\n            resolve(null);\n          } else {\n            try {\n              resolve(JSON.parse(data));\n            } catch (err) {\n              resolve(data as any);\n            }\n          }\n        },\n        (error) => {\n          this.handleError(resolve, reject, error, () => this.getValue(key));\n        },\n        'VaultPlugin',\n        'getValue',\n        [this.config, key]\n      );\n    });\n  }\n\n  /**\n   * Locks the vault if it is currently unlocked.\n   * Locking the vault with remove all secure data from memory inside of Identity Vault, but not your application.\n   *\n   * @usage\n   * ```typescript\n   * const vault = new Vault(existingVaultConfig);\n   * await vault.lock();\n   * ```\n   */\n  lock(): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      cordova.exec(\n        (data) => {\n          resolve();\n        },\n        (error) => {\n          this.handleError(resolve, reject, error);\n        },\n        'VaultPlugin',\n        'lock',\n        [this.config]\n      );\n    });\n  }\n\n  /**\n   * Removes a value from the vault.\n   * Calling `removeValue` will attempt to unlock the vault if it is currently locked.\n   *\n   * @usage\n   * ```typescript\n   * const vault = new Vault(existingVaultConfig);\n   * await vault.removeValue(\"address\");\n   * ```\n   *\n   * @param key The key to remove\n   *\n   */\n  removeValue(key: string): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      cordova.exec(\n        resolve,\n        (error) => {\n          this.handleError(resolve, reject, error, () => this.removeValue(key));\n        },\n        'VaultPlugin',\n        'removeValue',\n        [this.config, key]\n      );\n    });\n  }\n\n  /**\n   * When the vault type is set to 'CustomPasscode', this method sets the passcode required to\n   * secure the vault. If the vault is unlocked this method can be used to change the passcode.\n   *\n   * This method is typically called in the `onPasscodeRequested` callback.\n   *\n   * @usage\n   * ```typescript\n   * const vault = new Vault(existingVaultConfig);\n   * const code = window.prompt(\"Enter your passcode.\");\n   * if (code) {\n   *  await vault.setCustomPasscode(code);\n   * }\n   * ```\n   *\n   * @param passcode The user supplied passcode to secure the vault with.\n   *\n   */\n  setCustomPasscode(passcode: string): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      cordova.exec(\n        resolve,\n        (error) => {\n          this.handleError(resolve, reject, error);\n        },\n        'VaultPlugin',\n        'setCustomPasscode',\n        [this.config, passcode]\n      );\n    });\n  }\n\n  /**\n   * Sets the value of an item in the vault.\n   * Calling `setValue` will attempt to unlock the vault if it is currently locked.\n   *\n   * @usage\n   * ```typescript\n   * const vault = new Vault(existingVaultConfig);\n   * await vault.setValue<string>(\"theme\", theme);\n   * ```\n   *\n   * @param key The key for the new value.\n   * @param value The value to store in the vault. Value can be of any type, as it will be parsed to JSON in the vault.\n   *\n   */\n  setValue<T = any>(key: string, value: T): Promise<void> {\n    const jsonValue = JSON.stringify(value);\n    return new Promise<void>((resolve, reject) => {\n      cordova.exec(\n        resolve,\n        (error) => {\n          this.handleError(resolve, reject, error, () => this.setValue(key, value));\n        },\n        'VaultPlugin',\n        'setValue',\n        [this.config, key, jsonValue]\n      );\n    });\n  }\n\n  /**\n   * Triggers when a config change occurs.\n   *\n   * @usage\n   * ```typescript\n   * vault.onConfigChanged((config) => {\n   *  console.log(\"updated config: \", config);\n   * });\n   * ```\n   * @param callback The callback function that will be called when the event triggers. Passes in the current vault config.\n   *\n   */\n  onConfigChanged(callback: (config: IdentityVaultConfig) => void): void {\n    cordova.exec(\n      (data) => {\n        callback(JSON.parse(data));\n      },\n      (error) => console.error(error),\n      'VaultPlugin',\n      'onConfigChanged',\n      []\n    );\n  }\n\n  /**\n   * Triggers when an error occurs in the application.\n   * Errors that come back as rejected promises also trigger this event.\n   *\n   * @usage\n   * ```typescript\n   * vault.onError((err) => {\n   *  console.log('ERROR from callback', JSON.stringify(err));\n   * });\n   * ```\n   *\n   * @param callback The callback function that will be called when the event triggers. Passes in the error object.\n   *\n   */\n  onError(callback: (err: VaultError) => void): void {\n    cordova.exec(\n      () => {\n        // Do Nothing\n      },\n      callback,\n      'VaultPlugin',\n      'onError',\n      [this.config]\n    );\n  }\n\n  /**\n   * Triggers when the vault enters a locked state.\n   *\n   * @usage\n   * ```typescript\n   * vault.onLock((lockEvent) => { displayNotification(`Vault locked. Was from timeout: ${lockEvent.timeout}`); })\n   * ```\n   *\n   * @param callback The callback function that will be called when the event triggers. Passes in an object with a boolean property of `timeout` indicating if the lock was due to a background timeout or not.\n   *\n   */\n  onLock(callback: (lockEvent: VaultLockEvent) => void): void {\n    cordova.exec(\n      (data) => {\n        const d = JSON.parse(data);\n        callback({ timeout: d.timeout });\n      },\n      (error) => console.error(error),\n      'VaultPlugin',\n      'onLock',\n      [this.config]\n    );\n  }\n\n  /**\n   * For CustomPasscode vaults, this event triggers when the vault is attempting to unlock and needs the user to provide a passcode.\n   *\n   * The callback parameter is a function that has two parameters available to it:\n   * - `isPasscodeSetRequest` is a boolean value indicating whether the passcode needs to be setup for the first time or not.\n   * - `onComplete` is a function that accepts a string parameter 'code', that when called will set the passcode on the vault and attempt to unlock the vault again calling the same method that originally tried to unlock the vault.\n   *\n   * @usage\n   * ```typescript\n   * vault.onPasscodeRequested((isPasscodeSetRequest, onComplete) => {\n   *   const message = isPasscodeSetRequest\n   *     ? 'Setup Passcode' // passcode is being set for first time\n   *     : 'Enter passcode'; // passcode is being asked for unlock\n   *   const passcode = window.prompt(message) || '';\n   *   onComplete(passcode);\n   * });\n   * ```\n   *\n   * @param callback The callback function that will be called when the event triggers. Contains a boolean that indicates if the passcode is being setup for the first time for the vault or not, and an onComplete function to be called when a passcode is ready to be set on the vault.\n   *\n   */\n  onPasscodeRequested(callback: (isPasscodeSetRequest: boolean, onComplete: (code: string) => void) => void): void;\n  /**\n   * For CustomPasscode vaults, this event triggers when the vault is attempting to unlock and needs the user to provide a passcode.\n   *\n   * The callback parameter is a async function that has one parameter available to it:\n   * - `isPasscodeSetRequest` is a boolean value indicating whether the passcode needs to be setup for the first time or not.\n   *\n   * When the callback function is resolved, an attempt to unlock the vault again calling the same method that originally tried to unlock the vault will be made.\n   * Before the function is resolved, you should prompt the user to supply a passcode, and then supply that value to `setCustomPasscode`.\n   *\n   * @usage\n   * ```typescript\n   * vault.onPasscodeRequested(async (isPasscodeSetRequest) => {\n   *   const message = isPasscodeSetRequest\n   *     ? 'Setup Passcode' // passcode is being set for first time\n   *     : 'Enter passcode'; // passcode is being asked for unlock\n   *   // async yourGetPasscodeFromUser() returns a string of the users entry or null if canceled.\n   *   const passcode = await yourGetPasscodeFromUser(message);\n   *   await vault.setCustomPasscode(passcode ?? '');\n   * });\n   * ```\n   *\n   * @param callback The callback function that will be called when the event triggers. This async function returns a promise with a boolean that indicates if the passcode is being setup for the first time for the vault or not.\n   *\n   */\n  onPasscodeRequested(callback: (isPasscodeSetRequest: boolean) => Promise<void>): void;\n  onPasscodeRequested(callback: (isPasscodeSetRequest: boolean, onComplete: (code: string) => void) => void): void {\n    this.passCodeRequestedCallback = callback;\n  }\n\n  /**\n   * Triggers when the vault enters an unlocked state.\n   *\n   * @usage\n   * ```typescript\n   * vault.onUnlock(() => {\n   *  console.log(\"vault is now unlocked\");\n   * });\n   * ```\n   * @param callback The callback function that will be called when the event triggers.\n   *\n   */\n  onUnlock(callback: () => void): void {\n    cordova.exec(callback, (error) => console.error(error), 'VaultPlugin', 'onUnlock', [this.config]);\n  }\n\n  /**\n   * Manually unlock the vault. Will trigger any authentication mechanism needed to access the vault (passcode, biometrics, etc..).\n   *\n   * @usage\n   * ```typescript\n   * const vault = new Vault(existingVaultConfig);\n   * await vault.unlock();\n   * ```\n   */\n  unlock(): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      cordova.exec(\n        () => {\n          resolve();\n        },\n        (error) => {\n          this.handleError(resolve, reject, error, () => this.unlock());\n        },\n        'VaultPlugin',\n        'unlock',\n        [this.config]\n      );\n    });\n  }\n\n  /**\n   * Updates the configuration of the current vault.\n   *\n   *  @usage\n   * ```typescript\n   * async function changeVaultType(type: VaultType) {\n   *  const vault = new Vault(this.existingVaultConfig);\n   *  const newConfig = { ...this.existingVaultConfig, type };\n   *  await vault.updateConfig(newConfig);\n   *  this.existingVaultConfig = newConfig;\n   * }\n   * ```\n   *\n   * @param config The new config\n   *\n   */\n  updateConfig(config: IdentityVaultConfig): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      config = Object.assign(this.defaultConfig, config);\n\n      // setting sane defaults\n      if (config.deviceSecurityType === DeviceSecurityType.None && config.type === VaultType.DeviceSecurity) {\n        config.deviceSecurityType = DeviceSecurityType.Both;\n      }\n\n      cordova.exec(\n        () => {\n          this.config = config;\n          resolve();\n        },\n        (error) => {\n          this.handleError(resolve, reject, error, () => this.updateConfig(config));\n        },\n        'VaultPlugin',\n        'updateConfig',\n        [config]\n      );\n    });\n  }\n\n  /**\n   * Resolves true if a vault contains no data, and false if any data exists in the vault.\n   * The vault does not need to be unlocked to check.\n   *\n   * __Note:__ Vaults created prior to version 5.2.0 will return false until the vault is unlocked for the first time after updating, even if the vault contains no data.\n   * After which this method will return the expected value.\n   *\n   * @usage\n   * ```typescript\n   * const vault = new Vault(existingVaultConfig);\n   * const vaultIsEmpty = await vault.isEmpty()\n   * if (vaultIsEmpty) {\n   *  // the vault is empty and contains no data...\n   * }\n   * ```\n   */\n  isEmpty(): Promise<boolean> {\n    return new Promise((resolve, reject) => {\n      cordova.exec(\n        (data) => {\n          resolve(JSON.parse(data));\n        },\n        (error) => {\n          this.handleError(resolve, reject, error);\n        },\n        'VaultPlugin',\n        'isEmpty',\n        [this.config]\n      );\n    });\n  }\n\n  /** @ignore */\n  private async handleError(resolve: (data: any) => void, reject: (error: any) => void, error: any, retryFunc?: any) {\n    if (error.code === VaultErrorCodes.MissingPasscode && this.passCodeRequestedCallback) {\n      const checkRetry = async () => {\n        if (retryFunc) {\n          try {\n            const data = await retryFunc();\n            resolve(data);\n          } catch (e) {\n            reject(e);\n          }\n        }\n      };\n\n      const res = this.passCodeRequestedCallback(error.extra.isPasscodeSetRequest, (code: string) => {\n        this.setCustomPasscode(code);\n        checkRetry();\n      });\n\n      if (res instanceof Promise) {\n        await res;\n        await checkRetry();\n      }\n    } else if (error.code === VaultErrorCodes.MissingBiometrics) {\n      cordova.exec(\n        async () => {\n          const data = await retryFunc();\n          resolve(data);\n        },\n        (e) => reject(e),\n        'VaultPlugin',\n        'requestBiometricPrompt',\n        [this.config]\n      );\n    } else {\n      reject(error);\n    }\n  }\n\n  /** @ignore */\n  requestBiometricPrompt(): Promise<boolean> {\n    return new Promise<boolean>((resolve, reject) => {\n      cordova.exec(\n        (data) => {\n          resolve(JSON.parse(data));\n        },\n        (error) => {\n          this.handleError(resolve, reject, error, () => this.requestBiometricPrompt());\n        },\n        'VaultPlugin',\n        'requestBiometricPrompt',\n        [this.config]\n      );\n    });\n  }\n\n  /**\n   * @ignore\n   */\n  private resume() {\n    const noop = () => {\n      // Do Nothing\n    };\n    cordova.exec(\n      noop,\n      (error) => {\n        this.handleError(noop, noop, error, () => this.resume());\n      },\n      'VaultPlugin',\n      'appResumed',\n      [this.config]\n    );\n  }\n\n  /**\n   * @ignore\n   */\n  private setup() {\n    return new Promise((resolve, reject) => {\n      document.addEventListener('resume', this.resume, false);\n      cordova.exec(\n        resolve,\n        (error) => {\n          this.handleError(resolve, reject, error);\n        },\n        'VaultPlugin',\n        'setup',\n        [this.config]\n      );\n    });\n  }\n\n  /**\n   * @ignore\n   */\n  private getPersistedVaultConfig() {\n    return new Promise<void>((resolve, reject) => {\n      cordova.exec(\n        (data: string | null) => {\n          if (!data) {\n            resolve();\n          } else {\n            const vaultConfig = JSON.parse(data) as IdentityVaultConfig;\n            this.config = Object.assign(this.config, vaultConfig);\n            resolve();\n          }\n        },\n        (error) => {\n          this.handleError(resolve, reject, error);\n        },\n        'VaultPlugin',\n        'getVaultConfig',\n        [this.config]\n      );\n    });\n  }\n}\n","/* eslint-disable @typescript-eslint/no-useless-constructor */\nimport type { PromptConfig } from './PromptConfig';\nimport type { SupportedBiometricType } from './definitions';\nimport { BiometricPermissionState, BiometricSecurityStrength } from './definitions';\n\nexport class Device {\n  /** @ignore */\n  constructor() {\n    // Nothing\n  }\n\n  /**\n   * Gets the types of biometrics the device supports.\n   *\n   * @usage\n   * ```typescript\n   * const hardware = await Device.getAvailableHardware();\n   * hardware.forEach((biometricType) => console.log(\"Type: \" + biometricType));\n   * ```\n   */\n  public static getAvailableHardware(): Promise<SupportedBiometricType[]> {\n    return new Promise<SupportedBiometricType[]>((resolve, reject) => {\n      if (!('cordova' in window)) {\n        resolve([]);\n        return;\n      }\n\n      cordova.exec(\n        (data) => {\n          resolve(data);\n        },\n        (error) => {\n          Device.handleError(resolve, reject, error);\n        },\n        'DevicePlugin',\n        'getAvailableHardware',\n        []\n      );\n    });\n  }\n\n  /**\n   * Check whether biometrics are locked out on the device.\n   *\n   * On Android, the locked out state will only known after an attempted biometric unlock.\n   *\n   * @usage\n   * ```typescript\n   * const isLockedOut = await Device.isLockedOutOfBiometrics();\n   * if (isLockedOut) {\n   *  // device is locked out ...\n   * }\n   * ```\n   */\n  public static isLockedOutOfBiometrics(): Promise<boolean> {\n    return new Promise<boolean>((resolve, reject) => {\n      if (!('cordova' in window)) {\n        resolve(false);\n        return;\n      }\n\n      cordova.exec(\n        (data) => {\n          resolve(JSON.parse(data));\n        },\n        (error) => {\n          Device.handleError(resolve, reject, error);\n        },\n        'DevicePlugin',\n        'isLockedOutOfBiometrics',\n        []\n      );\n    });\n  }\n\n  /**\n   * Checks the device biometric strength level.\n   *\n   * On iOS this will always return 'strong'.\n   *\n   * @usage\n   * ```typescript\n   * const biometricStrength = await Device.getBiometricStrengthLevel();\n   * ```\n   */\n  public static getBiometricStrengthLevel(): Promise<BiometricSecurityStrength> {\n    return new Promise<BiometricSecurityStrength>((resolve, reject) => {\n      if (!('cordova' in window)) {\n        resolve(BiometricSecurityStrength.Weak);\n        return;\n      }\n      cordova.exec(\n        (data) => {\n          resolve(data);\n        },\n        (error) => {\n          Device.handleError(resolve, reject, error);\n        },\n        'DevicePlugin',\n        'getBiometricStrengthLevel',\n        []\n      );\n    });\n  }\n\n  /**\n   * Check whether or not the screen will be obscured in app switcher mode.\n   *\n   * @usage\n   * ```typescript\n   * const willHideScreen = await Device.isHideScreenOnBackgroundEnabled();\n   * ```\n   */\n  public static isHideScreenOnBackgroundEnabled(): Promise<boolean> {\n    return new Promise<boolean>((resolve, reject) => {\n      if (!('cordova' in window)) {\n        resolve(false);\n        return;\n      }\n      cordova.exec(\n        (data) => {\n          resolve(JSON.parse(data));\n        },\n        (error) => {\n          Device.handleError(resolve, reject, error);\n        },\n        'DevicePlugin',\n        'isHideScreenOnBackgroundEnabled',\n        []\n      );\n    });\n  }\n\n  /**\n   * Set whether or not the screen will be obscured in app switcher mode.\n   * If enabled, by default the screen behind biometric prompts will be obscured via the splash screen.\n   *\n   * For Android, an optional boolean *dimBiometrics* can be set to obscure\n   * the screen behind biometric prompts via dimming the background instead.\n   *\n   * @usage\n   * ```typescript\n   * await Device.setHideScreenOnBackground(true, true);\n   * ```\n   */\n  public static setHideScreenOnBackground(enabled = false, dimBiometrics = false): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      if (!('cordova' in window)) {\n        resolve();\n        return;\n      }\n      cordova.exec(\n        () => {\n          resolve();\n        },\n        (error) => {\n          Device.handleError(resolve, reject, error);\n        },\n        'DevicePlugin',\n        'setHideScreenOnBackground',\n        [enabled, dimBiometrics]\n      );\n    });\n  }\n\n  /**\n   * Check whether the device OS-level passcode has been set.\n   *\n   * @usage\n   * ```typescript\n   * const hasSystemPasscode = await Device.isSystemPasscodeSet();\n   * if (hasSystemPasscode) {\n   *  // device has a system passcode\n   * }\n   * ```\n   */\n  public static isSystemPasscodeSet(): Promise<boolean> {\n    return new Promise<boolean>((resolve, reject) => {\n      if (!('cordova' in window)) {\n        resolve(false);\n        return;\n      }\n      cordova.exec(\n        (data) => {\n          resolve(JSON.parse(data));\n        },\n        (error) => {\n          Device.handleError(resolve, reject, error);\n        },\n        'DevicePlugin',\n        'isSystemPasscodeSet',\n        []\n      );\n    });\n  }\n\n  /**\n   * Check whether or not biometrics is supported by the device and has been configured by the current user of the device.\n   *\n   * @usage\n   * ```typescript\n   * const biometricsEnabled = await Device.isBiometricsEnabled();\n   * if (!biometricsEnabled) {\n   *  // biometrics not enabled on this device...\n   * }\n   * ```\n   */\n  public static isBiometricsEnabled(): Promise<boolean> {\n    return new Promise<boolean>((resolve, reject) => {\n      if (!('cordova' in window)) {\n        resolve(false);\n        return;\n      }\n\n      cordova.exec(\n        (data) => {\n          console.log('biometrics is enabled: ', data);\n          resolve(JSON.parse(data));\n        },\n        (error) => {\n          Device.handleError(resolve, reject, error);\n        },\n        'DevicePlugin',\n        'isBiometricsEnabled',\n        []\n      );\n    });\n  }\n\n  /**\n   * Returns the current state of biometric permissions.\n   *\n   * On Android and iOS devices with TouchID, this always returns `granted`.\n   *\n   * @usage\n   * ```typescript\n   * const permissions = await Device.isBiometricsAllowed();\n   * if (permissions === BiometricPermissionState.Denied) {\n   *  // user must enable FaceID for the application...\n   * }\n   * ```\n   */\n  public static isBiometricsAllowed(): Promise<BiometricPermissionState> {\n    return new Promise<BiometricPermissionState>((resolve, reject) => {\n      if (!('cordova' in window)) {\n        resolve(BiometricPermissionState.Denied);\n        return;\n      }\n\n      cordova.exec(\n        (data) => {\n          resolve(data);\n        },\n        (error) => {\n          Device.handleError(resolve, reject, error);\n        },\n        'DevicePlugin',\n        'isBiometricsAllowed',\n        []\n      );\n    });\n  }\n\n  /**\n   * Check whether or not biometrics is supported by the device.\n   *\n   * @usage\n   * ```typescript\n   * const biometricsSupported = await Device.isBiometricsSupported();\n   * if (biometricsSupported) {\n   *   // biometrics is supported on this device...\n   * }\n   * ```\n   */\n  public static isBiometricsSupported(): Promise<boolean> {\n    return new Promise<boolean>((resolve, reject) => {\n      if (!('cordova' in window)) {\n        resolve(false);\n        return;\n      }\n\n      cordova.exec(\n        (data) => {\n          resolve(JSON.parse(data));\n        },\n        (error) => {\n          Device.handleError(resolve, reject, error);\n        },\n        'DevicePlugin',\n        'isBiometricsSupported',\n        []\n      );\n    });\n  }\n\n  /**\n   * Check if the device has a secure hardware enclave.\n   *\n   * @usage\n   * ```typescript\n   * const hasSecureHardware = await Device.hasSecureHardware();\n   * if (!hasSecureHardware) {\n   *    // this device doesn't have secure hardware\n   * }\n   * ```\n   */\n  public static hasSecureHardware(): Promise<boolean> {\n    return new Promise<boolean>((resolve, reject) => {\n      if (!('cordova' in window)) {\n        resolve(false);\n        return;\n      }\n\n      cordova.exec(\n        (data) => {\n          resolve(JSON.parse(data));\n        },\n        (error) => {\n          Device.handleError(resolve, reject, error);\n        },\n        'DevicePlugin',\n        'hasSecureHardware',\n        []\n      );\n    });\n  }\n\n  /**\n   * Show a biometric prompt.\n   *\n   * @usage\n   * ```typescript\n   * try {\n   *  const promptConfig = {...};\n   *  await Device.showBiometricPrompt(promptConfig);\n   *  // biometric prompt succeeded successfully\n   * } catch (err) {\n   *  // handle error\n   * }\n   * ```\n   */\n  public static showBiometricPrompt(config: PromptConfig): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      if (!('cordova' in window)) {\n        resolve();\n        return;\n      }\n\n      cordova.exec(\n        () => {\n          resolve();\n        },\n        (error) => {\n          Device.handleError(resolve, reject, error);\n        },\n        'DevicePlugin',\n        'showBiometricPrompt',\n        [config]\n      );\n    });\n  }\n\n  /**\n   * @ignore\n   */\n  private static async handleError(\n    resolve: (data: any) => void,\n    reject: (error: any) => void,\n    error: any,\n    retryFunc?: any\n  ) {\n    reject(error);\n  }\n}\n","import type {\n  DefaultSession,\n  IdentityVault,\n  IdentityVaultUser,\n  IonicNativeAuthPlugin,\n  VaultDescriptor,\n  VaultOptions,\n  PluginConfiguration,\n  LockEvent,\n  VaultError,\n  VaultConfig,\n  BiometricType,\n  SupportedBiometricType,\n} from './definitions';\nimport { AuthMode, VaultErrorCodes } from './definitions';\n\ndeclare let IonicNativeAuth: IonicNativeAuthPlugin;\n\n/**\n * @hidden\n *\n * @ignore\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport class IonicIdentityVaultUser<T extends {} = DefaultSession> implements IdentityVaultUser<T> {\n  private vault!: IdentityVault;\n  private vIonicNativeAuth?: IonicNativeAuthPlugin;\n  private _readyPromise: Promise<any>;\n  private _config!: PluginConfiguration;\n  private _readyResolve!: (value?: void | PromiseLike<void>) => void;\n  private _readyReject!: (reason?: any) => void;\n  private _readyCalled = false;\n  private descriptor: VaultDescriptor;\n  private session?: T;\n\n  constructor(\n    public platform: { ready: () => Promise<any> },\n    private readonly options: VaultOptions,\n    descriptor?: VaultDescriptor\n  ) {\n    this.descriptor = descriptor || { username: '_lastUser', vaultId: 'default' };\n    this._readyPromise = this.initializeVault();\n  }\n\n  get token(): string | undefined {\n    const session: any = this.session;\n    return session?.token;\n  }\n\n  get username(): string | undefined {\n    const session: any = this.session;\n    return session?.username;\n  }\n\n  get config(): VaultConfig {\n    if (!this._config) {\n      return undefined as any;\n    }\n    let authMode: AuthMode | undefined;\n    const bioEnabled = this._config.isBiometricsEnabled;\n    const passEnabled = this._config.isPasscodeEnabled;\n    const secureStorageMode = this._config.isSecureStorageModeEnabled;\n    if (secureStorageMode) {\n      authMode = AuthMode.SecureStorage;\n    } else if (bioEnabled && passEnabled) {\n      authMode = AuthMode.BiometricAndPasscode;\n    } else if (bioEnabled && !passEnabled) {\n      authMode = AuthMode.BiometricOnly;\n    } else if (!bioEnabled && passEnabled) {\n      authMode = AuthMode.PasscodeOnly;\n    } else if (!bioEnabled && !passEnabled) {\n      authMode = AuthMode.InMemoryOnly;\n    }\n    return {\n      authMode: authMode,\n      isPasscodeSetupNeeded: this._config.isPasscodeSetupNeeded,\n      lockAfter: this._config.lockAfter,\n      hideScreenOnBackground: this._config.hideScreenOnBackground,\n    };\n  }\n\n  // overidable event handlers\n  onVaultLocked(_event: LockEvent): void {\n    /* Do Nothing */\n  }\n  onSessionRestoreError(_err: VaultError): void {\n    /* Do Nothing */\n  }\n  onUnlockOnReadyError(_err: VaultError): void {\n    /* Do Nothing */\n  }\n  onVaultUnlocked(_config: VaultConfig): void {\n    /* Do Nothing */\n  }\n  onVaultReady(_config: VaultConfig): void {\n    /* Do Nothing */\n  }\n  onSetupError(_error: VaultError): void {\n    /* Do Nothing */\n  }\n  onConfigChange(_config: VaultConfig): void {\n    /* Do Nothing */\n  }\n  onSessionRestored(_session: T): void {\n    /* Do Nothing */\n  }\n  async onPasscodeRequest(_isPasscodeSetRequest: boolean): Promise<string | undefined> {\n    return;\n  }\n\n  private async onReady(vault: IdentityVault) {\n    if (this._readyCalled) {\n      return;\n    }\n    this._readyCalled = true;\n    this.vault = vault;\n    const inUse = await this.vault.isInUse();\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this._config = vault.config!;\n    const locked = await this.vault.isLocked();\n\n    let restoreSessionError!: VaultError;\n\n    try {\n      if (this.options.restoreSessionOnReady && inUse) {\n        await this._restoreSession();\n      }\n    } catch (e) {\n      restoreSessionError = e as VaultError;\n    }\n\n    let unlockOnReadyError!: VaultError;\n    try {\n      if (locked && this.options.unlockOnReady) {\n        await this._unlock();\n      }\n    } catch (e) {\n      unlockOnReadyError = e as VaultError;\n    }\n\n    // Note Swallow all errors in init like Vault is Locked Etc.\n    try {\n      if (!inUse) {\n        await this._trySetAuthMode(this.options.authMode);\n      }\n    } catch (e) {\n      // Do Nothing\n    }\n    this._readyResolve();\n    this.onVaultReady(this.config);\n    if (restoreSessionError) {\n      this.onSessionRestoreError(restoreSessionError);\n    }\n    if (unlockOnReadyError) {\n      this.onUnlockOnReadyError(restoreSessionError);\n    }\n  }\n\n  private onLock(event: LockEvent) {\n    this.session = undefined;\n    this.onVaultLocked(event);\n  }\n\n  private async onUnlock(config: PluginConfiguration) {\n    await this.ready();\n    this._config = config;\n    this.onVaultUnlocked(this.config);\n  }\n\n  private onError(error: VaultError) {\n    this._readyReject(error);\n    this.onSetupError(error);\n  }\n\n  private onConfig(config: PluginConfiguration) {\n    this._config = config;\n    this.onConfigChange(this.config);\n  }\n\n  public async ready(): Promise<void> {\n    return this._readyPromise;\n  }\n\n  private async _unlock(authMode?: AuthMode): Promise<void> {\n    const locked = await this.vault.isLocked();\n    if (!locked) {\n      return;\n    }\n    authMode = authMode !== undefined && authMode !== AuthMode.BiometricOrPasscode ? authMode : this.config.authMode;\n    switch (authMode) {\n      case AuthMode.BiometricOnly:\n        return this.vault.unlock();\n      case AuthMode.PasscodeOnly:\n        return this.unlockWithPasscode();\n      case AuthMode.BiometricAndPasscode:\n        try {\n          await this.vault.unlock();\n          return;\n        } catch (e: any) {\n          const handleableErrors = [\n            VaultErrorCodes.AuthFailed,\n            VaultErrorCodes.BiometricsNotEnabled,\n            VaultErrorCodes.UserCanceledInteraction,\n            VaultErrorCodes.InvalidatedCredential,\n          ];\n          if (handleableErrors.indexOf(e.code) > -1) {\n            await this.unlockWithPasscode();\n            // The user removed fingerprints/faceID and so the bio creds are gone\n            // if they are using passcode auth we can resave the credential to autoreset\n            // the mode to PasscodeOnly if bio is no longer available.\n            if (e.code === VaultErrorCodes.InvalidatedCredential) {\n              const session = await this.restoreSession();\n              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n              await this.saveSession(session!);\n            }\n            return;\n          }\n          throw e;\n        }\n    }\n  }\n\n  public async unlock(authMode?: AuthMode): Promise<void> {\n    await this.ready();\n    return this._unlock(authMode);\n  }\n\n  private async unlockWithPasscode() {\n    const passcode = await this.onPasscodeRequest(false);\n    return this.vault.unlock(true, passcode);\n  }\n\n  private async _setPasscode() {\n    const locked = await this.vault.isLocked();\n    if (locked) {\n      // eslint-disable-next-line no-throw-literal\n      throw { code: VaultErrorCodes.VaultLocked, message: 'Operation not allowed while vault locked.' };\n    }\n    const passcode = await this.onPasscodeRequest(true);\n    return this.vault.setPasscode(passcode);\n  }\n\n  public async setPasscode(): Promise<void> {\n    await this.ready();\n    return this._setPasscode();\n  }\n\n  public async getSession(): Promise<T | undefined> {\n    await this.ready();\n    if (this.options.unlockOnAccess) {\n      await this._unlock();\n    }\n    return this.session;\n  }\n\n  private async _restoreSession(): Promise<T | undefined> {\n    const inUse = await this.vault.isInUse();\n    if (!inUse) {\n      return;\n    }\n    if (this.options.unlockOnAccess) {\n      await this._unlock();\n    }\n    this.session = await this.vault.getValue('session');\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this.onSessionRestored(this.session!);\n    return this.session;\n  }\n\n  public async restoreSession(): Promise<T | undefined> {\n    await this.ready();\n    return this._restoreSession();\n  }\n\n  public async saveSession(session: T): Promise<void> {\n    await this.ready();\n    if (this.config.isPasscodeSetupNeeded) {\n      await this.setPasscode();\n    }\n    try {\n      await this.vault.storeValue('session', session);\n    } catch (e: any) {\n      // Catch the case where Biometrics with Passcode Fallback\n      // was enabled but the user disabled passcode or removed their\n      // fingerprints/faceid and try to recover by setting to passcode only\n      // mode.\n      if (e.code === VaultErrorCodes.SecurityNotAvailable) {\n        const authMode = await this.getAuthMode();\n        if (authMode === AuthMode.BiometricAndPasscode) {\n          await this.setAuthMode(AuthMode.PasscodeOnly);\n          return this.saveSession(session);\n        }\n      }\n      throw e;\n    }\n    this.session = session;\n  }\n\n  public async login(session: T, authMode?: AuthMode): Promise<void> {\n    await this.ready();\n    await this.logout();\n    await this._trySetAuthMode(authMode);\n    return this.saveSession(session);\n  }\n\n  public async getVault(): Promise<IdentityVault> {\n    await this.ready();\n    return this.vault;\n  }\n\n  private async initializeVault(): Promise<void> {\n    await this.platform.ready();\n\n    if (this.vault != null) {\n      return Promise.resolve();\n    }\n\n    if (this.vIonicNativeAuth == null) {\n      this.vIonicNativeAuth = this.getPlugin();\n    }\n\n    const readyPromise = new Promise<void>((resolve, reject) => {\n      this._readyResolve = resolve;\n      this._readyReject = reject;\n    });\n\n    const {\n      lockAfter,\n      hideScreenOnBackground,\n      shouldClearVaultAfterTooManyFailedAttempts,\n      allowSystemPinFallback,\n      androidPromptNegativeButtonText,\n      androidPromptTitle,\n      androidPromptSubtitle,\n      androidPromptDescription,\n      androidPINPromptTitle,\n      androidPINPromptSubtitle,\n      androidPINPromptConfirmTitle,\n      androidPINPromptVerifyTitle,\n      androidPINPromptConfirmButtonText,\n      androidPINPromptNegativeButtonText,\n      iosPromptText,\n    } = this.options;\n\n    this.vault = this.vIonicNativeAuth.getVault({\n      lockAfter,\n      hideScreenOnBackground,\n      shouldClearVaultAfterTooManyFailedAttempts,\n      allowSystemPinFallback,\n      androidPromptNegativeButtonText,\n      androidPromptTitle,\n      androidPromptSubtitle,\n      androidPromptDescription,\n      androidPINPromptTitle,\n      androidPINPromptSubtitle,\n      androidPINPromptConfirmTitle,\n      androidPINPromptVerifyTitle,\n      androidPINPromptConfirmButtonText,\n      androidPINPromptNegativeButtonText,\n      iosPromptText,\n      ...this.descriptor,\n      onLock: this.onLock.bind(this),\n      onConfig: this.onConfig.bind(this),\n      onError: this.onError.bind(this),\n      onUnlock: this.onUnlock.bind(this),\n      onReady: this.onReady.bind(this),\n    });\n\n    return readyPromise;\n  }\n\n  public getPlugin(): IonicNativeAuthPlugin {\n    return IonicNativeAuth;\n  }\n\n  public async getBiometricType(): Promise<BiometricType> {\n    await this.ready();\n    return this.vault.getBiometricType();\n  }\n\n  public async getAvailableHardware(): Promise<SupportedBiometricType[]> {\n    await this.ready();\n    return this.vault.getAvailableHardware();\n  }\n\n  public async lockOut(): Promise<void> {\n    await this.ready();\n    await this.vault.lock();\n    this.session = undefined;\n  }\n\n  public async logout(): Promise<void> {\n    await this.ready();\n    await this.vault.clear();\n    this.session = undefined;\n    this._config = await this.vault.getConfig();\n  }\n\n  public async hasStoredSession(): Promise<boolean> {\n    await this.ready();\n    return this.vault.isInUse();\n  }\n\n  public async setBiometricsEnabled(isBiometricsEnabled: boolean): Promise<void> {\n    await this.ready();\n    return this._setBiometricsEnabled(isBiometricsEnabled);\n  }\n\n  private async _setBiometricsEnabled(isBiometricsEnabled: boolean): Promise<void> {\n    return this.vault.setBiometricsEnabled(isBiometricsEnabled);\n  }\n\n  public async setHideScreenOnBackground(enabled: boolean): Promise<void> {\n    await this.ready();\n    return this.vault.setHideScreenOnBackground(enabled);\n  }\n\n  public async setPasscodeEnabled(isPasscodeEnabled: boolean): Promise<void> {\n    await this.ready();\n    await this._setPasscodeEnabled(isPasscodeEnabled);\n  }\n\n  private async _setPasscodeEnabled(isPasscodeEnabled: boolean): Promise<void> {\n    await this.vault.setPasscodeEnabled(isPasscodeEnabled);\n    this._config = await this.vault.getConfig();\n    if (this.config.isPasscodeSetupNeeded) {\n      await this._setPasscode();\n    }\n  }\n\n  public async isBiometricsEnabled(): Promise<boolean> {\n    await this.ready();\n    return this.vault.isBiometricsEnabled();\n  }\n\n  public async isBiometricsAvailable(): Promise<boolean> {\n    await this.ready();\n    return this.vault.isBiometricsAvailable();\n  }\n\n  public async isBiometricsSupported(): Promise<boolean> {\n    await this.ready();\n    return this.vault.isBiometricsSupported();\n  }\n\n  public async isSecureStorageModeEnabled(): Promise<boolean> {\n    await this.ready();\n    return this.vault.isSecureStorageModeEnabled();\n  }\n\n  public async isPasscodeEnabled(): Promise<boolean> {\n    await this.ready();\n    return this.vault.isPasscodeEnabled();\n  }\n\n  private async _setAuthMode(authMode?: AuthMode) {\n    authMode = authMode !== undefined ? authMode : this.config.authMode;\n    if (authMode === this.config.authMode) {\n      return;\n    }\n    switch (authMode) {\n      case AuthMode.BiometricOnly:\n        await this._setBiometricsEnabled(true);\n        await this._setPasscodeEnabled(false);\n        break;\n      case AuthMode.PasscodeOnly:\n        await this._setPasscodeEnabled(true);\n        await this._setBiometricsEnabled(false);\n        break;\n      case AuthMode.BiometricAndPasscode:\n        await this._setPasscodeEnabled(true);\n        await this._setBiometricsEnabled(true);\n        break;\n      case AuthMode.BiometricOrPasscode:\n        try {\n          await this._setBiometricsEnabled(true);\n          await this._setPasscodeEnabled(false);\n        } catch (error) {\n          await this._setPasscodeEnabled(true);\n        }\n        break;\n      case AuthMode.InMemoryOnly:\n        await this._setPasscodeEnabled(false);\n        await this._setBiometricsEnabled(false);\n        await this.vault.setSecureStorageModeEnabled(false);\n        break;\n      case AuthMode.SecureStorage:\n        // Note: Setting this mode automatically disables the other modes in native code.\n        await this.vault.setSecureStorageModeEnabled(true);\n        break;\n      default:\n        // eslint-disable-next-line no-throw-literal\n        throw { code: VaultErrorCodes.InvalidAuthMode, message: 'Invalid AuthMode' };\n    }\n  }\n\n  private async _trySetAuthMode(authMode?: AuthMode) {\n    try {\n      await this._setAuthMode(authMode);\n    } catch (error: any) {\n      if (error.code !== VaultErrorCodes.BiometricsNotEnabled && error.code !== VaultErrorCodes.SecurityNotAvailable) {\n        throw error;\n      }\n    }\n  }\n\n  public async setAuthMode(authMode?: AuthMode): Promise<void> {\n    await this.ready();\n    return this._setAuthMode(authMode);\n  }\n\n  public async getAuthMode(): Promise<AuthMode> {\n    await this.ready();\n    this._config = await this.vault.getConfig();\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this.config.authMode!;\n  }\n}\n","import type { VaultDescriptor, VaultOptions } from './definitions';\nimport { IonicIdentityVaultUser } from './vault-user';\n\ntype onPasscodeRequestCallback = (_isPasscodeSetRequest: boolean) => Promise<string | undefined>;\n\nclass MigratorVault extends IonicIdentityVaultUser<any> {\n  private static instance: MigratorVault | undefined = undefined;\n\n  /** @ignore */\n  constructor(options: VaultOptions, onPasscodeRequest?: onPasscodeRequestCallback, descriptor?: VaultDescriptor) {\n    super(\n      {\n        ready: () => Promise.resolve(true),\n      },\n      options,\n      descriptor\n    );\n\n    if (onPasscodeRequest) {\n      this.onPasscodeRequest = onPasscodeRequest;\n    }\n  }\n\n  public static getInstance(\n    options: VaultOptions,\n    onPasscodeRequest?: onPasscodeRequestCallback,\n    descriptor?: VaultDescriptor\n  ): MigratorVault {\n    if (!MigratorVault.instance) {\n      MigratorVault.instance = new MigratorVault(options, onPasscodeRequest, descriptor);\n    }\n    return MigratorVault.instance;\n  }\n}\n\nexport class VaultMigrator {\n  /** @ignore */\n  private migratorSession: MigratorVault;\n\n  /**\n   *\n   * @usage\n   * ```typescript\n   * const legacyVaultConfig = {\n   *  unlockOnAccess: true,\n   *  hideScreenOnBackground: true,\n   *  lockAfter: 5000,\n   *  // and more ....\n   * }\n   * const migrator = new VaultMigrator(legacyVaultConfig, customPasscodePrompt);\n   * ```\n   * @param options The legacy vault configuration options\n   * @param onPasscodeRequest An optional callback function that will be called when the vault attempts to request a passcode. The function returns a promise with a boolean that indicates if the passcode is being setup for the first time for the vault or not.\n   * @param descriptor An optional interface that describes the legacy vault.\n   */\n  constructor(\n    options: VaultOptions,\n    onPasscodeRequest?: (isPasscodeSetRequest: boolean) => Promise<string | undefined>,\n    descriptor?: VaultDescriptor\n  ) {\n    this.migratorSession = new MigratorVault(options, onPasscodeRequest, descriptor);\n  }\n\n  /**\n   * Exports the data of the legacy vault in its entirety.\n   *\n   * @usage\n   * ```typescript\n   * const data = await migrator.exportVault();\n   * console.log(\"@@VAULT DATA: \", JSON.stringify(data));\n   * ```\n   * @returns\n   */\n  async exportVault(): Promise<any | null> {\n    if (!(await this.migratorSession.hasStoredSession())) {\n      throw Error('no data in legacy vault');\n    }\n\n    await this.migratorSession.unlock();\n\n    const vault = await this.migratorSession.getVault();\n    const keys = await vault.getKeys();\n\n    const vaultData: any = {};\n\n    for (const key of keys) {\n      vaultData[key] = await vault.getValue(key);\n    }\n\n    return vaultData;\n  }\n\n  /**\n   * Clears out the legacy vault and removes it from the system.  Be sure to run {@link VaultMigrator.exportVault} before calling this method.\n   *\n   * @usage\n   * ```typescript\n   * const data = await migrator.exportVault();\n   * await importVault(data);\n   * await migrator.clear();\n   * ```\n   */\n  async clear(): Promise<void> {\n    const vault = await this.migratorSession.getVault();\n    return vault.clear();\n  }\n}\n"],"names":[],"mappings":"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"}