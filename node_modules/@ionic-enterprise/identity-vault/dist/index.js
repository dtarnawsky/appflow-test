/*! Ionic Enterprise Identity Vault: https://ionicframework.com/ - Commercially Licensed */
/**
 * The meaning of the error code in the thrown {@link VaultError}.
 */
var VaultErrorCodes;
(function (VaultErrorCodes) {
    /**
     * An unknown error happened.
     * @constant `0`
     */
    VaultErrorCodes[VaultErrorCodes["Unknown"] = 0] = "Unknown";
    /**
     * The operation failed because the vault was locked.
     * @constant `1`
     */
    VaultErrorCodes[VaultErrorCodes["VaultLocked"] = 1] = "VaultLocked";
    /**
     * The operation failed because the vault was unavailable.
     * The most likely cause of this error is that a vault has not been configured.
     * @constant `2`
     */
    VaultErrorCodes[VaultErrorCodes["VaultUnavailable"] = 2] = "VaultUnavailable";
    /**
     * The operation failed because the some of the vault provided arguments were invalid.
     * @constant `3`
     */
    VaultErrorCodes[VaultErrorCodes["InvalidArguments"] = 3] = "InvalidArguments";
    /**
     * The credentials were invalidated. This can happen when a user changes biometrics or passcode.
     * @constant `4`
     */
    VaultErrorCodes[VaultErrorCodes["InvalidatedCredential"] = 4] = "InvalidatedCredential";
    /**
     * Biometric security is unavailable due to a passcode not being set up at the system level.
     * In order to use biometric identification on the device a system level passcode must be set up by the user.
     * @constant `5`
     */
    VaultErrorCodes[VaultErrorCodes["SecurityNotAvailable"] = 5] = "SecurityNotAvailable";
    /**
     * User authentication failed.
     * @constant `6`
     */
    VaultErrorCodes[VaultErrorCodes["AuthFailed"] = 6] = "AuthFailed";
    /**
     * Too many failed authentication attempts made against the custom passcode vault, so the vault was cleared and user will need to login again.
     * @constant `7`
     */
    VaultErrorCodes[VaultErrorCodes["TooManyFailedAttempts"] = 7] = "TooManyFailedAttempts";
    /**
     * The user cancelled the native authentication dialog.
     *
     * **Note**: On iOS, this error code will also be thrown in the event that the native authentication dialog fails as a result of too many failed attempts.
     * The user will be forced to cancel the dialog, triggering this error code.
     *
     * On Android, this error also will be thrown if using {@link DeviceSecurityType.SystemPasscode} or {@link DeviceSecurityType.Both} in the event of too many failed attempts.
     * Its currently not possible to get the nature of failures from the native authentication dialog, and similar to iOS, the user will be forced to cancel the dialog, triggering this error code.
     * @constant `8`
     */
    VaultErrorCodes[VaultErrorCodes["UserCanceledInteraction"] = 8] = "UserCanceledInteraction";
    /**
     * The user provided mismatched passcodes.
     * @constant `9`
     */
    VaultErrorCodes[VaultErrorCodes["MismatchedPasscode"] = 9] = "MismatchedPasscode";
    /**
     * The operation requires passcode to be setup but it isn't set yet. Call {@link Vault.setCustomPasscode} to set it.
     * @constant `10`
     */
    VaultErrorCodes[VaultErrorCodes["MissingPasscode"] = 10] = "MissingPasscode";
    /**
     * The operation failed because the application tried to unlock the vault with passcode authentication,
     * but the vault is not configured to allow passcode authentication.
     * @constant `11`
     */
    VaultErrorCodes[VaultErrorCodes["PasscodeNotEnabled"] = 11] = "PasscodeNotEnabled";
    /**
     * The key was not found. This can happen when a user changes biometrics or passcode.
     * @constant `12`
     */
    VaultErrorCodes[VaultErrorCodes["KeyNotFound"] = 12] = "KeyNotFound";
    /**
     * The operation failed because biometric authentication is not enabled.
     * This can occur when biometrics is not supported by the device
     * or when biometrics has not been configured for the device or vault.
     * @constant `13`
     */
    VaultErrorCodes[VaultErrorCodes["BiometricsNotEnabled"] = 13] = "BiometricsNotEnabled";
    /**
     * @ignore
     */
    VaultErrorCodes[VaultErrorCodes["InvalidAuthMode"] = 14] = "InvalidAuthMode";
    /**
     * Biometrics have not been authed yet (Android only)
     * @constant `15`
     */
    VaultErrorCodes[VaultErrorCodes["MissingBiometrics"] = 15] = "MissingBiometrics";
    /**
     * {@link DeviceSecurityType.SystemPasscode} for {@link DeviceSecurityType} not available on this Android device.
     * @constant `16`
     */
    VaultErrorCodes[VaultErrorCodes["AndroidSystemPasscodeUnavailable"] = 16] = "AndroidSystemPasscodeUnavailable";
    /**
     * Biometrics have been locked out, usually because of too many failed attempts.
     *
     * **Note:** This error will never be thrown if using {@link DeviceSecurityType.SystemPasscode} or {@link DeviceSecurityType.Both}.
     * Its currently not possible to get the nature of failures from the native authentication dialog, so the only error that would be thrown is {@link VaultErrorCodes.UserCanceledInteraction} as the user
     * is forced to cancel the prompt.
     *
     * @constant `17`
     */
    VaultErrorCodes[VaultErrorCodes["AndroidBiometricsLockedOut"] = 17] = "AndroidBiometricsLockedOut";
    /**
     * Biometrics have been locked out, usually because of too many failed attempts.
     *
     * @constant `18`
     */
    VaultErrorCodes[VaultErrorCodes["iOSBiometricsLockedOut"] = 18] = "iOSBiometricsLockedOut";
    /**
     * An unexpected error has occurred in the Android keystore.
     * Some android devices (such as the Samsung S10) will return this error code when
     * a maximum number of failed attempts is reached and the device must be restarted.
     * See: [Max Uses Per Boot](https://source.android.com/security/keystore/tags#max_uses_per_boot)
     *
     * @constant `19`
     */
    VaultErrorCodes[VaultErrorCodes["AndroidUnexpectedKeystoreError"] = 19] = "AndroidUnexpectedKeystoreError";
})(VaultErrorCodes || (VaultErrorCodes = {}));
/**
 * The meaning of the error code in the thrown {@link DeviceError}.
 */
var DeviceErrorCodes;
(function (DeviceErrorCodes) {
    /**
     * An unknown error happened.
     * @constant `0`
     */
    DeviceErrorCodes[DeviceErrorCodes["Unknown"] = 0] = "Unknown";
    /**
     * The operation failed because the some of the vault provided arguments were invalid.
     * @constant `1`
     */
    DeviceErrorCodes[DeviceErrorCodes["InvalidArguments"] = 1] = "InvalidArguments";
    /**
     * The user cancelled the native authentication dialog.
     *
     * **Note**: On iOS, this error code will also be thrown in the event that the native authentication dialog fails as a result of too many failed attempts.
     * The user will be forced to cancel the dialog, triggering this error code.
     *
     * @constant `2`
     */
    DeviceErrorCodes[DeviceErrorCodes["UserCanceledInteraction"] = 2] = "UserCanceledInteraction";
    /**
     * Biometric security is unavailable due to a passcode not being set up at the system level.
     * In order to use biometric identification on the device a system level passcode must be set up by the user.
     * @constant `3`
     */
    DeviceErrorCodes[DeviceErrorCodes["SecurityNotAvailable"] = 3] = "SecurityNotAvailable";
    /**
     * User authentication failed.
     * @constant `4`
     */
    DeviceErrorCodes[DeviceErrorCodes["AuthFailed"] = 4] = "AuthFailed";
    /**
     * Biometrics have been locked out, usually because of too many failed attempts.
     *
     * @constant `5`
     */
    DeviceErrorCodes[DeviceErrorCodes["BiometricsLockedOut"] = 5] = "BiometricsLockedOut";
    /**
     * The operation failed because biometric authentication is not enabled.
     * This can occur when biometrics is not supported by the device
     * or when biometrics has not been configured for the device or vault.
     * @constant `6`
     */
    DeviceErrorCodes[DeviceErrorCodes["BiometricsNotEnabled"] = 6] = "BiometricsNotEnabled";
})(DeviceErrorCodes || (DeviceErrorCodes = {}));
/**
 * The possible values returned by {@link Device.getAvailableHardware}
 */
var SupportedBiometricType;
(function (SupportedBiometricType) {
    /** The device supports fingerprint scanning. */
    SupportedBiometricType["Fingerprint"] = "fingerprint";
    /** The device supports facial recognition. */
    SupportedBiometricType["Face"] = "face";
    /** The device supports iris scanning. */
    SupportedBiometricType["Iris"] = "iris";
})(SupportedBiometricType || (SupportedBiometricType = {}));
/**
 * Possible device biometric strength levels on Android (always `strong` on iOS).
 * [More Information](https://source.android.com/security/biometric/measure#tiered-authentication).
 */
var BiometricSecurityStrength;
(function (BiometricSecurityStrength) {
    /** Refers to Class 2 - Weak biometric security */
    BiometricSecurityStrength["Weak"] = "weak";
    /** Refers to Class 3 - Strong biometric security */
    BiometricSecurityStrength["Strong"] = "strong";
})(BiometricSecurityStrength || (BiometricSecurityStrength = {}));
/**
 * Possible app biometric permissions states on iOS (always `granted` on Android and on iOS with TouchID).
 */
var BiometricPermissionState;
(function (BiometricPermissionState) {
    /** App has been granted permission to use FaceID */
    BiometricPermissionState["Granted"] = "granted";
    /** App has been denied permission to use FaceID */
    BiometricPermissionState["Denied"] = "denied";
    /** User has not yet been prompted to allow FaceID */
    BiometricPermissionState["Prompt"] = "prompt";
})(BiometricPermissionState || (BiometricPermissionState = {}));
/**
 * When type is set to 'DeviceSecurity', determines which aspects of the device to use to secure the vault.
 * Note: Android only supports `SystemPasscode` on Android 11 and greater.
 * @default `Both`
 */
var DeviceSecurityType;
(function (DeviceSecurityType) {
    /** Will allow a system passcode to secure the vault. On Android, only supported on Android 11 and greater. */
    DeviceSecurityType["SystemPasscode"] = "SystemPasscode";
    /** WIll allow biometric hardware tos secure the vault. */
    DeviceSecurityType["Biometrics"] = "Biometrics";
    /** WIll allow both SystemPasscode or Biometrics as an option to secure the vault. */
    DeviceSecurityType["Both"] = "Both";
    /** No biometric security option will be used. */
    DeviceSecurityType["None"] = "None";
})(DeviceSecurityType || (DeviceSecurityType = {}));
/**
 * The type of vault
 */
var VaultType;
(function (VaultType) {
    /**
     * No additional security is required in the app as long as the device was unlocked with a secure method.
     *
     * On iOS, this vault is synchronized via iCloud or new device setup.
     * */
    VaultType["SecureStorage"] = "SecureStorage";
    /**
     * Uses additional device features to add an additional layer of security while the user is in the app.
     *
     * On iOS, this vault is NOT synchronized via iCloud or new device setup.
     * */
    VaultType["DeviceSecurity"] = "DeviceSecurity";
    /**
     * User will set a custom passcode that will be used to access the vault.
     *
     * On iOS, this vault is NOT synchronized via iCloud or new device setup.
     * */
    VaultType["CustomPasscode"] = "CustomPasscode";
    /** Data will persist only while the application is in memory.
     *
     *  On iOS, this vault is NOT synchronized via iCloud or new device setup.
     */
    VaultType["InMemory"] = "InMemory";
})(VaultType || (VaultType = {}));
/**
 * For Android, when type is {@link VaultType.DeviceSecurity} and deviceSecurityType is {@link DeviceSecurityType.Both}, this options specifies if you want to
 * prefer a Strong Cryptographic Vault or the System Passcode fallback when they both aren't available.
 * @default `StrongVault`
 */
var AndroidBiometricCryptoPreference;
(function (AndroidBiometricCryptoPreference) {
    /** Prefer to use a strong cryptographic vault. */
    AndroidBiometricCryptoPreference["StrongVault"] = "StrongVault";
    /** Prefer the system passcode fallback. */
    AndroidBiometricCryptoPreference["SystemPasscode"] = "SystemPasscode";
})(AndroidBiometricCryptoPreference || (AndroidBiometricCryptoPreference = {}));
// OLD METHODS
/**
 * The type of authentication the vault should be configured to allow.
 * @deprecated For use in legacy Vault Migrator only.
 * @ignore
 */
var AuthMode;
(function (AuthMode) {
    /**
     * Biometrics authentication should only be allowed
     */
    AuthMode[AuthMode["BiometricOnly"] = 0] = "BiometricOnly";
    /**
     * Passcode authentication should only be allowed
     */
    AuthMode[AuthMode["PasscodeOnly"] = 1] = "PasscodeOnly";
    /**
     * Both biometric and passcode authentication should be allowed
     */
    AuthMode[AuthMode["BiometricAndPasscode"] = 2] = "BiometricAndPasscode";
    /**
     * Both biometric and passcode authentication should be disabled.
     * With this setting all data in the vault will be cleared on lock or
     * if the app is closed. Stored data is kept only in memory.
     */
    AuthMode[AuthMode["InMemoryOnly"] = 3] = "InMemoryOnly";
    /**
     * Use biometrics if it is available, otherwise use passcode
     */
    AuthMode[AuthMode["BiometricOrPasscode"] = 4] = "BiometricOrPasscode";
    /**
     * Both biometric and passcode authentication will be disabled but any stored values
     * will persist and be stored securely at rest using the keychain and will be available
     * without needing to authenticate via passcode or biometrics when the device is unlocked.
     */
    AuthMode[AuthMode["SecureStorage"] = 5] = "SecureStorage";
})(AuthMode || (AuthMode = {}));

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

const STORAGE_KEYS = {
    DATA: 'data',
};
/**
 * THIS VAULT DOES NOT IMPLEMENT SECURE STORAGE IN THE BROWSER. It only exists
 * as a way to run browser-compatible code in place of Identity Vault. Browsers
 * do not have a secure storage element same as native devices. This class
 * is intended to be used to enable running your application in the browser while
 * simulating the functions of Identity Vault using sessionStorage.
 *
 * Represents a vault implementation for browser compatibility.
 */
class BrowserVault {
    /**
     * @usage
     * ```typescript
     * const vault = new Vault({
     *  key: 'com.company.myvaultapp',
     *  type: 'CustomPasscode',
     *  deviceSecurityType: 'Both',
     *  lockAfterBackgrounded: 2000,
     * });
     * ```
     * @param config
     */
    constructor(config) {
        /** @ignore */
        this.isVaultLocked = false;
        /** @ignore */
        this.isVaultEmpty = true;
        console.warn('THIS VAULT DOES NOT IMPLEMENT SECURE STORAGE IN THE BROWSER AND IS NOT INTENDED FOR PRODUCTION USE. It only exists as a way to run browser-compatible code in place of Identity Vault. Browsers do not have a secure storage element same as native devices. This class is intended to be used to enable running your application in the browser while simulating the functions of Identity Vault using sessionStorage.');
        this.config = Object.assign({
            deviceSecurityType: 'Both',
            androidBiometricsPreferStrongVaultOrSystemPasscode: 'StrongVault',
            shouldClearVaultAfterTooManyFailedAttempts: false,
            customPasscodeInvalidUnlockAttempts: 5,
            unlockVaultOnLoad: false,
        }, config);
        this.isVaultLocked = config.unlockVaultOnLoad ? false : true;
    }
    /** @deprecated Deprecated in favor of using the isEmpty method. */
    /** See {@link Vault.doesVaultExist} */
    doesVaultExist() {
        const data = this.getDataObj();
        return Promise.resolve(!!data);
    }
    /** See {@link Vault.clear} */
    clear() {
        this.unlockIfLocked();
        sessionStorage.removeItem(this.getKey(STORAGE_KEYS.DATA));
        this.isVaultEmpty = true;
        return Promise.resolve();
    }
    /** See {@link Vault.exportVault} */
    exportVault() {
        this.unlockIfLocked();
        const data = this.getDataObj();
        return Promise.resolve(data !== null && data !== void 0 ? data : {});
    }
    /** See {@link Vault.importVault} */
    importVault(data) {
        this.setDataObj(data);
        return Promise.resolve();
    }
    /** See {@link Vault.isLocked} */
    isLocked() {
        return Promise.resolve(this.isVaultLocked);
    }
    /** See {@link Vault.isEmpty} */
    isEmpty() {
        return Promise.resolve(this.isVaultEmpty);
    }
    /** See {@link Vault.getKeys} */
    getKeys() {
        this.unlockIfLocked();
        const data = this.getDataObj();
        if (!data)
            return Promise.resolve([]);
        return Promise.resolve(Object.keys(data));
    }
    /** See {@link Vault.getValue} */
    getValue(key) {
        var _a;
        this.unlockIfLocked();
        const data = this.getDataObj();
        return Promise.resolve((_a = data === null || data === void 0 ? void 0 : data[key]) !== null && _a !== void 0 ? _a : null);
    }
    /** See {@link Vault.lock} */
    lock() {
        var _a;
        (_a = this.lockCallback) === null || _a === void 0 ? void 0 : _a.call(this, { timeout: false });
        return Promise.resolve();
    }
    /** See {@link Vault.removeValue} */
    removeValue(key) {
        this.unlockIfLocked();
        const data = this.getDataObj();
        if (!data)
            return Promise.resolve();
        const _a = data, _b = key; _a[_b]; const dataAfterRemoval = __rest(_a, [typeof _b === "symbol" ? _b : _b + ""]);
        this.setDataObj(dataAfterRemoval);
        return Promise.resolve();
    }
    /** See {@link Vault.setCustomPasscode} */
    setCustomPasscode(passcode) {
        return Promise.resolve();
    }
    /** See {@link Vault.setValue} */
    setValue(key, value) {
        this.unlockIfLocked();
        const data = this.getDataObj();
        if (!data) {
            this.setDataObj({ [key]: value });
        }
        else {
            this.setDataObj(Object.assign(Object.assign({}, data), { [key]: value }));
        }
        return Promise.resolve();
    }
    /** See {@link Vault.onConfigChanged} */
    onConfigChanged(callback) {
        this.configCallback = callback;
    }
    /** See {@link Vault.onError} */
    onError(callback) {
        this.errorCallback = callback;
    }
    /** See {@link Vault.onLock} */
    onLock(callback) {
        this.lockCallback = callback;
    }
    onPasscodeRequested(callback) {
        // No passcode support
    }
    /** See {@link Vault.onUnlock} */
    onUnlock(callback) {
        this.unlockCallback = callback;
    }
    /** See {@link Vault.unlock} */
    unlock() {
        var _a;
        (_a = this.unlockCallback) === null || _a === void 0 ? void 0 : _a.call(this);
        return Promise.resolve();
    }
    /** See {@link Vault.updateConfig} */
    updateConfig(config) {
        var _a;
        this.config = config;
        (_a = this.configCallback) === null || _a === void 0 ? void 0 : _a.call(this, config);
        return Promise.resolve();
    }
    /** @ignore */
    requestBiometricPrompt() {
        this.unlockIfLocked();
        return Promise.resolve(true);
    }
    /** @ignore */
    unlockIfLocked() {
        if (this.isVaultLocked) {
            this.unlock();
        }
    }
    /** @ignore */
    getDataObj() {
        var _a;
        const value = sessionStorage.getItem(this.getKey(STORAGE_KEYS.DATA));
        if (!value)
            return null;
        try {
            const dataObj = JSON.parse(value);
            this.isVaultEmpty = Object.keys(dataObj).length <= 0;
            return dataObj;
        }
        catch (e) {
            (_a = this.errorCallback) === null || _a === void 0 ? void 0 : _a.call(this, {
                message: 'Unable to parse data store',
                code: VaultErrorCodes.Unknown,
            });
            return null;
        }
    }
    /** @ignore */
    setDataObj(data) {
        var _a;
        try {
            const dataStr = JSON.stringify(data);
            sessionStorage.setItem(this.getKey(STORAGE_KEYS.DATA), dataStr);
            this.isVaultEmpty = Object.keys(data).length <= 0;
        }
        catch (e) {
            (_a = this.errorCallback) === null || _a === void 0 ? void 0 : _a.call(this, {
                message: 'Unable to serialize data',
                code: VaultErrorCodes.Unknown,
            });
        }
    }
    /** @ignore */
    getKey(key) {
        return `IV-${this.config.key}-${key}`;
    }
}

/**
 * Represents a vault for secure value storage
 */
class Vault {
    /**
     * @usage
     * ```typescript
     * const vault = new Vault({
     *  key: 'com.company.myvaultapp',
     *  type: 'CustomPasscode',
     *  deviceSecurityType: DeviceSecurityType.None,
     *  lockAfterBackgrounded: 2000,
     * });
     * ```
     * @param config
     */
    constructor(config) {
        /** @ignore */
        this.defaultConfig = {
            deviceSecurityType: DeviceSecurityType.None,
            androidBiometricsPreferStrongVaultOrSystemPasscode: AndroidBiometricCryptoPreference.StrongVault,
            shouldClearVaultAfterTooManyFailedAttempts: false,
            customPasscodeInvalidUnlockAttempts: 5,
            unlockVaultOnLoad: false,
        };
        // set defaults
        this.config = Object.assign(this.defaultConfig, config);
        // setting sane defaults
        if (config.deviceSecurityType === DeviceSecurityType.None && config.type === VaultType.DeviceSecurity) {
            config.deviceSecurityType = DeviceSecurityType.Both;
        }
        this.resume = this.resume.bind(this);
        this.handleError = this.handleError.bind(this);
        this.setup().then(() => {
            this.getPersistedVaultConfig();
        });
    }
    /**
     * Resolves true if a vault with the same key already exists, and false if not.
     * The vault does not need to be unlocked to check.
     *
     * __Note:__
     *  - Using {@link Vault.removeValue | removeValue()} to remove all of your vault data will not cause this function to resolve false, however {@link Vault.clear | clear()} will.
     *  - A vault only exists once it has been interacted with at least once via any of the following instance methods.
     *    - {@link Vault.setValue | setValue()}
     *    - {@link Vault.removeValue | removeValue()}
     *    - {@link Vault.importVault | importVault()}
     *    - {@link Vault.exportVault | exportVault()}
     *    - {@link Vault.unlock | unlock()}
     *    - {@link Vault.updateConfig | updateConfig()}
     *
     * @usage
     * ```typescript
     * const vault = new Vault(existingVaultConfig);
     * const vaultExists = await vault.doesVaultExists()
     * if (!vaultExists) {
     *  // the vault does not exist...
     * }
     * ```
     *
     * @deprecated Deprecated in favor of using the {@link Vault.isEmpty | isEmpty()} method.
     */
    doesVaultExist() {
        return new Promise((resolve, reject) => {
            cordova.exec((data) => {
                resolve(JSON.parse(data));
            }, (error) => {
                this.handleError(resolve, reject, error, () => this.doesVaultExist());
            }, 'VaultPlugin', 'doesVaultExist', [this.config]);
        });
    }
    /**
     * Clears out the current vault and removes it from the system.
     * Note: The vault does not need to be unlocked in order to clear it. No credentials are checked
     * when clearing the vault.
     *
     * @usage
     * ```typescript
     * const vault = new Vault(existingVaultConfig);
     * await vault.clear();
     * ```
     */
    clear() {
        return new Promise((resolve, reject) => {
            cordova.exec((data) => {
                resolve();
            }, (error) => {
                this.handleError(resolve, reject, error, () => this.clear());
            }, 'VaultPlugin', 'clear', [this.config]);
        });
    }
    /**
     * Exports the data of the current vault in its entirety.
     * The data is a map with keys that are strings and values that are JSON.
     * Calling `exportVault` will attempt to unlock the vault if it is currently locked.
     *
     * @usage
     * ```typescript
     * const vault = new Vault(existingVaultConfig);
     * const data = await vault.exportVault();
     * ```
     *
     * @return The resolved object is a map with string keys and string values.
     *
     */
    exportVault() {
        return new Promise((resolve, reject) => {
            cordova.exec((data) => {
                resolve(JSON.parse(data));
            }, (error) => {
                this.handleError(resolve, reject, error, () => this.exportVault());
            }, 'VaultPlugin', 'exportVault', [this.config]);
        });
    }
    /**
     * Imports data into the vault, replacing the current contents of the vault.
     * The data is a map with keys that are strings and values that are JSON.
     * Calling `importVault` will attempt to unlock the vault if it is currently locked.
     *
     * @usage
     * ```typescript
     * const dataFromElsewhere = await getUserData();
     * const newVault = new Vault(vaultConfig);
     * await newVault.importVault(dataFromElsewhere);
     * ```
     *
     * @param data The entire data object to be imported. The shape of data must be {[key: string]: string}.
     *
     */
    importVault(data) {
        const jsonData = JSON.stringify(data);
        return new Promise((resolve, reject) => {
            cordova.exec(resolve, (error) => {
                this.handleError(resolve, reject, error, () => this.importVault(data));
            }, 'VaultPlugin', 'importVault', [this.config, jsonData]);
        });
    }
    /**
     * Checks if the vault is currently in a locked state, which signifies that the contents
     * of the secure vault are not currently accessible. `isLocked` can also return true if the
     * vault does not exist.
     *
     * @usage
     * ```typescript
     * const vault = new Vault(existingVaultConfig);
     * const locked = await vault.isLocked();
     * if (locked) {
     *  // vault is locked (or does not exist);
     * }
     * ```
     */
    isLocked() {
        return new Promise((resolve, reject) => {
            cordova.exec((data) => {
                resolve(JSON.parse(data));
            }, (error) => {
                this.handleError(resolve, reject, error);
            }, 'VaultPlugin', 'isLocked', [this.config]);
        });
    }
    /**
     * Returns an array of keys that are currently in the vault.
     * Calling `getKeys` will attempt to unlock the vault if it is currently locked.
     *
     * @usage
     * ```typescript
     * const vault = new Vault(existingVaultConfig);
     * const allKeys = await vault.getKeys();
     * allKeys.forEach((key) => {
     *  // do something with the key
     * });
     * ```
     */
    getKeys() {
        return new Promise((resolve, reject) => {
            cordova.exec((data) => {
                resolve(JSON.parse(data));
            }, (error) => {
                this.handleError(resolve, reject, error, () => this.getKeys());
            }, 'VaultPlugin', 'getKeys', [this.config]);
        });
    }
    /**
     * Gets the value for a given key. Returns null if the key does not exist.
     * Calling `getValue` will attempt to unlock the vault if it is currently locked.
     *
     * @usage
     * ```typescript
     * const vault = new Vault(existingVaultConfig);
     * const userFirstName = await vault.getValue<string>("firstname");
     * ```
     *
     * @param key The key to look up the value for
     *
     */
    getValue(key) {
        return new Promise((resolve, reject) => {
            cordova.exec((data) => {
                if (!data) {
                    // android returns null as an empty string, so manually convert it here
                    resolve(null);
                }
                else {
                    try {
                        resolve(JSON.parse(data));
                    }
                    catch (err) {
                        resolve(data);
                    }
                }
            }, (error) => {
                this.handleError(resolve, reject, error, () => this.getValue(key));
            }, 'VaultPlugin', 'getValue', [this.config, key]);
        });
    }
    /**
     * Locks the vault if it is currently unlocked.
     * Locking the vault with remove all secure data from memory inside of Identity Vault, but not your application.
     *
     * @usage
     * ```typescript
     * const vault = new Vault(existingVaultConfig);
     * await vault.lock();
     * ```
     */
    lock() {
        return new Promise((resolve, reject) => {
            cordova.exec((data) => {
                resolve();
            }, (error) => {
                this.handleError(resolve, reject, error);
            }, 'VaultPlugin', 'lock', [this.config]);
        });
    }
    /**
     * Removes a value from the vault.
     * Calling `removeValue` will attempt to unlock the vault if it is currently locked.
     *
     * @usage
     * ```typescript
     * const vault = new Vault(existingVaultConfig);
     * await vault.removeValue("address");
     * ```
     *
     * @param key The key to remove
     *
     */
    removeValue(key) {
        return new Promise((resolve, reject) => {
            cordova.exec(resolve, (error) => {
                this.handleError(resolve, reject, error, () => this.removeValue(key));
            }, 'VaultPlugin', 'removeValue', [this.config, key]);
        });
    }
    /**
     * When the vault type is set to 'CustomPasscode', this method sets the passcode required to
     * secure the vault. If the vault is unlocked this method can be used to change the passcode.
     *
     * This method is typically called in the `onPasscodeRequested` callback.
     *
     * @usage
     * ```typescript
     * const vault = new Vault(existingVaultConfig);
     * const code = window.prompt("Enter your passcode.");
     * if (code) {
     *  await vault.setCustomPasscode(code);
     * }
     * ```
     *
     * @param passcode The user supplied passcode to secure the vault with.
     *
     */
    setCustomPasscode(passcode) {
        return new Promise((resolve, reject) => {
            cordova.exec(resolve, (error) => {
                this.handleError(resolve, reject, error);
            }, 'VaultPlugin', 'setCustomPasscode', [this.config, passcode]);
        });
    }
    /**
     * Sets the value of an item in the vault.
     * Calling `setValue` will attempt to unlock the vault if it is currently locked.
     *
     * @usage
     * ```typescript
     * const vault = new Vault(existingVaultConfig);
     * await vault.setValue<string>("theme", theme);
     * ```
     *
     * @param key The key for the new value.
     * @param value The value to store in the vault. Value can be of any type, as it will be parsed to JSON in the vault.
     *
     */
    setValue(key, value) {
        const jsonValue = JSON.stringify(value);
        return new Promise((resolve, reject) => {
            cordova.exec(resolve, (error) => {
                this.handleError(resolve, reject, error, () => this.setValue(key, value));
            }, 'VaultPlugin', 'setValue', [this.config, key, jsonValue]);
        });
    }
    /**
     * Triggers when a config change occurs.
     *
     * @usage
     * ```typescript
     * vault.onConfigChanged((config) => {
     *  console.log("updated config: ", config);
     * });
     * ```
     * @param callback The callback function that will be called when the event triggers. Passes in the current vault config.
     *
     */
    onConfigChanged(callback) {
        cordova.exec((data) => {
            callback(JSON.parse(data));
        }, (error) => console.error(error), 'VaultPlugin', 'onConfigChanged', []);
    }
    /**
     * Triggers when an error occurs in the application.
     * Errors that come back as rejected promises also trigger this event.
     *
     * @usage
     * ```typescript
     * vault.onError((err) => {
     *  console.log('ERROR from callback', JSON.stringify(err));
     * });
     * ```
     *
     * @param callback The callback function that will be called when the event triggers. Passes in the error object.
     *
     */
    onError(callback) {
        cordova.exec(() => {
            // Do Nothing
        }, callback, 'VaultPlugin', 'onError', [this.config]);
    }
    /**
     * Triggers when the vault enters a locked state.
     *
     * @usage
     * ```typescript
     * vault.onLock((lockEvent) => { displayNotification(`Vault locked. Was from timeout: ${lockEvent.timeout}`); })
     * ```
     *
     * @param callback The callback function that will be called when the event triggers. Passes in an object with a boolean property of `timeout` indicating if the lock was due to a background timeout or not.
     *
     */
    onLock(callback) {
        cordova.exec((data) => {
            const d = JSON.parse(data);
            callback({ timeout: d.timeout });
        }, (error) => console.error(error), 'VaultPlugin', 'onLock', [this.config]);
    }
    onPasscodeRequested(callback) {
        this.passCodeRequestedCallback = callback;
    }
    /**
     * Triggers when the vault enters an unlocked state.
     *
     * @usage
     * ```typescript
     * vault.onUnlock(() => {
     *  console.log("vault is now unlocked");
     * });
     * ```
     * @param callback The callback function that will be called when the event triggers.
     *
     */
    onUnlock(callback) {
        cordova.exec(callback, (error) => console.error(error), 'VaultPlugin', 'onUnlock', [this.config]);
    }
    /**
     * Manually unlock the vault. Will trigger any authentication mechanism needed to access the vault (passcode, biometrics, etc..).
     *
     * @usage
     * ```typescript
     * const vault = new Vault(existingVaultConfig);
     * await vault.unlock();
     * ```
     */
    unlock() {
        return new Promise((resolve, reject) => {
            cordova.exec(() => {
                resolve();
            }, (error) => {
                this.handleError(resolve, reject, error, () => this.unlock());
            }, 'VaultPlugin', 'unlock', [this.config]);
        });
    }
    /**
     * Updates the configuration of the current vault.
     *
     *  @usage
     * ```typescript
     * async function changeVaultType(type: VaultType) {
     *  const vault = new Vault(this.existingVaultConfig);
     *  const newConfig = { ...this.existingVaultConfig, type };
     *  await vault.updateConfig(newConfig);
     *  this.existingVaultConfig = newConfig;
     * }
     * ```
     *
     * @param config The new config
     *
     */
    updateConfig(config) {
        return new Promise((resolve, reject) => {
            config = Object.assign(this.defaultConfig, config);
            // setting sane defaults
            if (config.deviceSecurityType === DeviceSecurityType.None && config.type === VaultType.DeviceSecurity) {
                config.deviceSecurityType = DeviceSecurityType.Both;
            }
            cordova.exec(() => {
                this.config = config;
                resolve();
            }, (error) => {
                this.handleError(resolve, reject, error, () => this.updateConfig(config));
            }, 'VaultPlugin', 'updateConfig', [config]);
        });
    }
    /**
     * Resolves true if a vault contains no data, and false if any data exists in the vault.
     * The vault does not need to be unlocked to check.
     *
     * __Note:__ Vaults created prior to version 5.2.0 will return false until the vault is unlocked for the first time after updating, even if the vault contains no data.
     * After which this method will return the expected value.
     *
     * @usage
     * ```typescript
     * const vault = new Vault(existingVaultConfig);
     * const vaultIsEmpty = await vault.isEmpty()
     * if (vaultIsEmpty) {
     *  // the vault is empty and contains no data...
     * }
     * ```
     */
    isEmpty() {
        return new Promise((resolve, reject) => {
            cordova.exec((data) => {
                resolve(JSON.parse(data));
            }, (error) => {
                this.handleError(resolve, reject, error);
            }, 'VaultPlugin', 'isEmpty', [this.config]);
        });
    }
    /** @ignore */
    async handleError(resolve, reject, error, retryFunc) {
        if (error.code === VaultErrorCodes.MissingPasscode && this.passCodeRequestedCallback) {
            const checkRetry = async () => {
                if (retryFunc) {
                    try {
                        const data = await retryFunc();
                        resolve(data);
                    }
                    catch (e) {
                        reject(e);
                    }
                }
            };
            const res = this.passCodeRequestedCallback(error.extra.isPasscodeSetRequest, (code) => {
                this.setCustomPasscode(code);
                checkRetry();
            });
            if (res instanceof Promise) {
                await res;
                await checkRetry();
            }
        }
        else if (error.code === VaultErrorCodes.MissingBiometrics) {
            cordova.exec(async () => {
                const data = await retryFunc();
                resolve(data);
            }, (e) => reject(e), 'VaultPlugin', 'requestBiometricPrompt', [this.config]);
        }
        else {
            reject(error);
        }
    }
    /** @ignore */
    requestBiometricPrompt() {
        return new Promise((resolve, reject) => {
            cordova.exec((data) => {
                resolve(JSON.parse(data));
            }, (error) => {
                this.handleError(resolve, reject, error, () => this.requestBiometricPrompt());
            }, 'VaultPlugin', 'requestBiometricPrompt', [this.config]);
        });
    }
    /**
     * @ignore
     */
    resume() {
        const noop = () => {
            // Do Nothing
        };
        cordova.exec(noop, (error) => {
            this.handleError(noop, noop, error, () => this.resume());
        }, 'VaultPlugin', 'appResumed', [this.config]);
    }
    /**
     * @ignore
     */
    setup() {
        return new Promise((resolve, reject) => {
            document.addEventListener('resume', this.resume, false);
            cordova.exec(resolve, (error) => {
                this.handleError(resolve, reject, error);
            }, 'VaultPlugin', 'setup', [this.config]);
        });
    }
    /**
     * @ignore
     */
    getPersistedVaultConfig() {
        return new Promise((resolve, reject) => {
            cordova.exec((data) => {
                if (!data) {
                    resolve();
                }
                else {
                    const vaultConfig = JSON.parse(data);
                    this.config = Object.assign(this.config, vaultConfig);
                    resolve();
                }
            }, (error) => {
                this.handleError(resolve, reject, error);
            }, 'VaultPlugin', 'getVaultConfig', [this.config]);
        });
    }
}

class Device {
    /** @ignore */
    constructor() {
        // Nothing
    }
    /**
     * Gets the types of biometrics the device supports.
     *
     * @usage
     * ```typescript
     * const hardware = await Device.getAvailableHardware();
     * hardware.forEach((biometricType) => console.log("Type: " + biometricType));
     * ```
     */
    static getAvailableHardware() {
        return new Promise((resolve, reject) => {
            if (!('cordova' in window)) {
                resolve([]);
                return;
            }
            cordova.exec((data) => {
                resolve(data);
            }, (error) => {
                Device.handleError(resolve, reject, error);
            }, 'DevicePlugin', 'getAvailableHardware', []);
        });
    }
    /**
     * Check whether biometrics are locked out on the device.
     *
     * On Android, the locked out state will only known after an attempted biometric unlock.
     *
     * @usage
     * ```typescript
     * const isLockedOut = await Device.isLockedOutOfBiometrics();
     * if (isLockedOut) {
     *  // device is locked out ...
     * }
     * ```
     */
    static isLockedOutOfBiometrics() {
        return new Promise((resolve, reject) => {
            if (!('cordova' in window)) {
                resolve(false);
                return;
            }
            cordova.exec((data) => {
                resolve(JSON.parse(data));
            }, (error) => {
                Device.handleError(resolve, reject, error);
            }, 'DevicePlugin', 'isLockedOutOfBiometrics', []);
        });
    }
    /**
     * Checks the device biometric strength level.
     *
     * On iOS this will always return 'strong'.
     *
     * @usage
     * ```typescript
     * const biometricStrength = await Device.getBiometricStrengthLevel();
     * ```
     */
    static getBiometricStrengthLevel() {
        return new Promise((resolve, reject) => {
            if (!('cordova' in window)) {
                resolve(BiometricSecurityStrength.Weak);
                return;
            }
            cordova.exec((data) => {
                resolve(data);
            }, (error) => {
                Device.handleError(resolve, reject, error);
            }, 'DevicePlugin', 'getBiometricStrengthLevel', []);
        });
    }
    /**
     * Check whether or not the screen will be obscured in app switcher mode.
     *
     * @usage
     * ```typescript
     * const willHideScreen = await Device.isHideScreenOnBackgroundEnabled();
     * ```
     */
    static isHideScreenOnBackgroundEnabled() {
        return new Promise((resolve, reject) => {
            if (!('cordova' in window)) {
                resolve(false);
                return;
            }
            cordova.exec((data) => {
                resolve(JSON.parse(data));
            }, (error) => {
                Device.handleError(resolve, reject, error);
            }, 'DevicePlugin', 'isHideScreenOnBackgroundEnabled', []);
        });
    }
    /**
     * Set whether or not the screen will be obscured in app switcher mode.
     * If enabled, by default the screen behind biometric prompts will be obscured via the splash screen.
     *
     * For Android, an optional boolean *dimBiometrics* can be set to obscure
     * the screen behind biometric prompts via dimming the background instead.
     *
     * @usage
     * ```typescript
     * await Device.setHideScreenOnBackground(true, true);
     * ```
     */
    static setHideScreenOnBackground(enabled = false, dimBiometrics = false) {
        return new Promise((resolve, reject) => {
            if (!('cordova' in window)) {
                resolve();
                return;
            }
            cordova.exec(() => {
                resolve();
            }, (error) => {
                Device.handleError(resolve, reject, error);
            }, 'DevicePlugin', 'setHideScreenOnBackground', [enabled, dimBiometrics]);
        });
    }
    /**
     * Check whether the device OS-level passcode has been set.
     *
     * @usage
     * ```typescript
     * const hasSystemPasscode = await Device.isSystemPasscodeSet();
     * if (hasSystemPasscode) {
     *  // device has a system passcode
     * }
     * ```
     */
    static isSystemPasscodeSet() {
        return new Promise((resolve, reject) => {
            if (!('cordova' in window)) {
                resolve(false);
                return;
            }
            cordova.exec((data) => {
                resolve(JSON.parse(data));
            }, (error) => {
                Device.handleError(resolve, reject, error);
            }, 'DevicePlugin', 'isSystemPasscodeSet', []);
        });
    }
    /**
     * Check whether or not biometrics is supported by the device and has been configured by the current user of the device.
     *
     * @usage
     * ```typescript
     * const biometricsEnabled = await Device.isBiometricsEnabled();
     * if (!biometricsEnabled) {
     *  // biometrics not enabled on this device...
     * }
     * ```
     */
    static isBiometricsEnabled() {
        return new Promise((resolve, reject) => {
            if (!('cordova' in window)) {
                resolve(false);
                return;
            }
            cordova.exec((data) => {
                console.log('biometrics is enabled: ', data);
                resolve(JSON.parse(data));
            }, (error) => {
                Device.handleError(resolve, reject, error);
            }, 'DevicePlugin', 'isBiometricsEnabled', []);
        });
    }
    /**
     * Returns the current state of biometric permissions.
     *
     * On Android and iOS devices with TouchID, this always returns `granted`.
     *
     * @usage
     * ```typescript
     * const permissions = await Device.isBiometricsAllowed();
     * if (permissions === BiometricPermissionState.Denied) {
     *  // user must enable FaceID for the application...
     * }
     * ```
     */
    static isBiometricsAllowed() {
        return new Promise((resolve, reject) => {
            if (!('cordova' in window)) {
                resolve(BiometricPermissionState.Denied);
                return;
            }
            cordova.exec((data) => {
                resolve(data);
            }, (error) => {
                Device.handleError(resolve, reject, error);
            }, 'DevicePlugin', 'isBiometricsAllowed', []);
        });
    }
    /**
     * Check whether or not biometrics is supported by the device.
     *
     * @usage
     * ```typescript
     * const biometricsSupported = await Device.isBiometricsSupported();
     * if (biometricsSupported) {
     *   // biometrics is supported on this device...
     * }
     * ```
     */
    static isBiometricsSupported() {
        return new Promise((resolve, reject) => {
            if (!('cordova' in window)) {
                resolve(false);
                return;
            }
            cordova.exec((data) => {
                resolve(JSON.parse(data));
            }, (error) => {
                Device.handleError(resolve, reject, error);
            }, 'DevicePlugin', 'isBiometricsSupported', []);
        });
    }
    /**
     * Check if the device has a secure hardware enclave.
     *
     * @usage
     * ```typescript
     * const hasSecureHardware = await Device.hasSecureHardware();
     * if (!hasSecureHardware) {
     *    // this device doesn't have secure hardware
     * }
     * ```
     */
    static hasSecureHardware() {
        return new Promise((resolve, reject) => {
            if (!('cordova' in window)) {
                resolve(false);
                return;
            }
            cordova.exec((data) => {
                resolve(JSON.parse(data));
            }, (error) => {
                Device.handleError(resolve, reject, error);
            }, 'DevicePlugin', 'hasSecureHardware', []);
        });
    }
    /**
     * Show a biometric prompt.
     *
     * @usage
     * ```typescript
     * try {
     *  const promptConfig = {...};
     *  await Device.showBiometricPrompt(promptConfig);
     *  // biometric prompt succeeded successfully
     * } catch (err) {
     *  // handle error
     * }
     * ```
     */
    static showBiometricPrompt(config) {
        return new Promise((resolve, reject) => {
            if (!('cordova' in window)) {
                resolve();
                return;
            }
            cordova.exec(() => {
                resolve();
            }, (error) => {
                Device.handleError(resolve, reject, error);
            }, 'DevicePlugin', 'showBiometricPrompt', [config]);
        });
    }
    /**
     * @ignore
     */
    static async handleError(resolve, reject, error, retryFunc) {
        reject(error);
    }
}

/**
 * @hidden
 *
 * @ignore
 */
// eslint-disable-next-line @typescript-eslint/ban-types
class IonicIdentityVaultUser {
    constructor(platform, options, descriptor) {
        this.platform = platform;
        this.options = options;
        this._readyCalled = false;
        this.descriptor = descriptor || { username: '_lastUser', vaultId: 'default' };
        this._readyPromise = this.initializeVault();
    }
    get token() {
        const session = this.session;
        return session === null || session === void 0 ? void 0 : session.token;
    }
    get username() {
        const session = this.session;
        return session === null || session === void 0 ? void 0 : session.username;
    }
    get config() {
        if (!this._config) {
            return undefined;
        }
        let authMode;
        const bioEnabled = this._config.isBiometricsEnabled;
        const passEnabled = this._config.isPasscodeEnabled;
        const secureStorageMode = this._config.isSecureStorageModeEnabled;
        if (secureStorageMode) {
            authMode = AuthMode.SecureStorage;
        }
        else if (bioEnabled && passEnabled) {
            authMode = AuthMode.BiometricAndPasscode;
        }
        else if (bioEnabled && !passEnabled) {
            authMode = AuthMode.BiometricOnly;
        }
        else if (!bioEnabled && passEnabled) {
            authMode = AuthMode.PasscodeOnly;
        }
        else if (!bioEnabled && !passEnabled) {
            authMode = AuthMode.InMemoryOnly;
        }
        return {
            authMode: authMode,
            isPasscodeSetupNeeded: this._config.isPasscodeSetupNeeded,
            lockAfter: this._config.lockAfter,
            hideScreenOnBackground: this._config.hideScreenOnBackground,
        };
    }
    // overidable event handlers
    onVaultLocked(_event) {
        /* Do Nothing */
    }
    onSessionRestoreError(_err) {
        /* Do Nothing */
    }
    onUnlockOnReadyError(_err) {
        /* Do Nothing */
    }
    onVaultUnlocked(_config) {
        /* Do Nothing */
    }
    onVaultReady(_config) {
        /* Do Nothing */
    }
    onSetupError(_error) {
        /* Do Nothing */
    }
    onConfigChange(_config) {
        /* Do Nothing */
    }
    onSessionRestored(_session) {
        /* Do Nothing */
    }
    async onPasscodeRequest(_isPasscodeSetRequest) {
        return;
    }
    async onReady(vault) {
        if (this._readyCalled) {
            return;
        }
        this._readyCalled = true;
        this.vault = vault;
        const inUse = await this.vault.isInUse();
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this._config = vault.config;
        const locked = await this.vault.isLocked();
        let restoreSessionError;
        try {
            if (this.options.restoreSessionOnReady && inUse) {
                await this._restoreSession();
            }
        }
        catch (e) {
            restoreSessionError = e;
        }
        let unlockOnReadyError;
        try {
            if (locked && this.options.unlockOnReady) {
                await this._unlock();
            }
        }
        catch (e) {
            unlockOnReadyError = e;
        }
        // Note Swallow all errors in init like Vault is Locked Etc.
        try {
            if (!inUse) {
                await this._trySetAuthMode(this.options.authMode);
            }
        }
        catch (e) {
            // Do Nothing
        }
        this._readyResolve();
        this.onVaultReady(this.config);
        if (restoreSessionError) {
            this.onSessionRestoreError(restoreSessionError);
        }
        if (unlockOnReadyError) {
            this.onUnlockOnReadyError(restoreSessionError);
        }
    }
    onLock(event) {
        this.session = undefined;
        this.onVaultLocked(event);
    }
    async onUnlock(config) {
        await this.ready();
        this._config = config;
        this.onVaultUnlocked(this.config);
    }
    onError(error) {
        this._readyReject(error);
        this.onSetupError(error);
    }
    onConfig(config) {
        this._config = config;
        this.onConfigChange(this.config);
    }
    async ready() {
        return this._readyPromise;
    }
    async _unlock(authMode) {
        const locked = await this.vault.isLocked();
        if (!locked) {
            return;
        }
        authMode = authMode !== undefined && authMode !== AuthMode.BiometricOrPasscode ? authMode : this.config.authMode;
        switch (authMode) {
            case AuthMode.BiometricOnly:
                return this.vault.unlock();
            case AuthMode.PasscodeOnly:
                return this.unlockWithPasscode();
            case AuthMode.BiometricAndPasscode:
                try {
                    await this.vault.unlock();
                    return;
                }
                catch (e) {
                    const handleableErrors = [
                        VaultErrorCodes.AuthFailed,
                        VaultErrorCodes.BiometricsNotEnabled,
                        VaultErrorCodes.UserCanceledInteraction,
                        VaultErrorCodes.InvalidatedCredential,
                    ];
                    if (handleableErrors.indexOf(e.code) > -1) {
                        await this.unlockWithPasscode();
                        // The user removed fingerprints/faceID and so the bio creds are gone
                        // if they are using passcode auth we can resave the credential to autoreset
                        // the mode to PasscodeOnly if bio is no longer available.
                        if (e.code === VaultErrorCodes.InvalidatedCredential) {
                            const session = await this.restoreSession();
                            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                            await this.saveSession(session);
                        }
                        return;
                    }
                    throw e;
                }
        }
    }
    async unlock(authMode) {
        await this.ready();
        return this._unlock(authMode);
    }
    async unlockWithPasscode() {
        const passcode = await this.onPasscodeRequest(false);
        return this.vault.unlock(true, passcode);
    }
    async _setPasscode() {
        const locked = await this.vault.isLocked();
        if (locked) {
            // eslint-disable-next-line no-throw-literal
            throw { code: VaultErrorCodes.VaultLocked, message: 'Operation not allowed while vault locked.' };
        }
        const passcode = await this.onPasscodeRequest(true);
        return this.vault.setPasscode(passcode);
    }
    async setPasscode() {
        await this.ready();
        return this._setPasscode();
    }
    async getSession() {
        await this.ready();
        if (this.options.unlockOnAccess) {
            await this._unlock();
        }
        return this.session;
    }
    async _restoreSession() {
        const inUse = await this.vault.isInUse();
        if (!inUse) {
            return;
        }
        if (this.options.unlockOnAccess) {
            await this._unlock();
        }
        this.session = await this.vault.getValue('session');
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.onSessionRestored(this.session);
        return this.session;
    }
    async restoreSession() {
        await this.ready();
        return this._restoreSession();
    }
    async saveSession(session) {
        await this.ready();
        if (this.config.isPasscodeSetupNeeded) {
            await this.setPasscode();
        }
        try {
            await this.vault.storeValue('session', session);
        }
        catch (e) {
            // Catch the case where Biometrics with Passcode Fallback
            // was enabled but the user disabled passcode or removed their
            // fingerprints/faceid and try to recover by setting to passcode only
            // mode.
            if (e.code === VaultErrorCodes.SecurityNotAvailable) {
                const authMode = await this.getAuthMode();
                if (authMode === AuthMode.BiometricAndPasscode) {
                    await this.setAuthMode(AuthMode.PasscodeOnly);
                    return this.saveSession(session);
                }
            }
            throw e;
        }
        this.session = session;
    }
    async login(session, authMode) {
        await this.ready();
        await this.logout();
        await this._trySetAuthMode(authMode);
        return this.saveSession(session);
    }
    async getVault() {
        await this.ready();
        return this.vault;
    }
    async initializeVault() {
        await this.platform.ready();
        if (this.vault != null) {
            return Promise.resolve();
        }
        if (this.vIonicNativeAuth == null) {
            this.vIonicNativeAuth = this.getPlugin();
        }
        const readyPromise = new Promise((resolve, reject) => {
            this._readyResolve = resolve;
            this._readyReject = reject;
        });
        const { lockAfter, hideScreenOnBackground, shouldClearVaultAfterTooManyFailedAttempts, allowSystemPinFallback, androidPromptNegativeButtonText, androidPromptTitle, androidPromptSubtitle, androidPromptDescription, androidPINPromptTitle, androidPINPromptSubtitle, androidPINPromptConfirmTitle, androidPINPromptVerifyTitle, androidPINPromptConfirmButtonText, androidPINPromptNegativeButtonText, iosPromptText, } = this.options;
        this.vault = this.vIonicNativeAuth.getVault(Object.assign(Object.assign({ lockAfter,
            hideScreenOnBackground,
            shouldClearVaultAfterTooManyFailedAttempts,
            allowSystemPinFallback,
            androidPromptNegativeButtonText,
            androidPromptTitle,
            androidPromptSubtitle,
            androidPromptDescription,
            androidPINPromptTitle,
            androidPINPromptSubtitle,
            androidPINPromptConfirmTitle,
            androidPINPromptVerifyTitle,
            androidPINPromptConfirmButtonText,
            androidPINPromptNegativeButtonText,
            iosPromptText }, this.descriptor), { onLock: this.onLock.bind(this), onConfig: this.onConfig.bind(this), onError: this.onError.bind(this), onUnlock: this.onUnlock.bind(this), onReady: this.onReady.bind(this) }));
        return readyPromise;
    }
    getPlugin() {
        return IonicNativeAuth;
    }
    async getBiometricType() {
        await this.ready();
        return this.vault.getBiometricType();
    }
    async getAvailableHardware() {
        await this.ready();
        return this.vault.getAvailableHardware();
    }
    async lockOut() {
        await this.ready();
        await this.vault.lock();
        this.session = undefined;
    }
    async logout() {
        await this.ready();
        await this.vault.clear();
        this.session = undefined;
        this._config = await this.vault.getConfig();
    }
    async hasStoredSession() {
        await this.ready();
        return this.vault.isInUse();
    }
    async setBiometricsEnabled(isBiometricsEnabled) {
        await this.ready();
        return this._setBiometricsEnabled(isBiometricsEnabled);
    }
    async _setBiometricsEnabled(isBiometricsEnabled) {
        return this.vault.setBiometricsEnabled(isBiometricsEnabled);
    }
    async setHideScreenOnBackground(enabled) {
        await this.ready();
        return this.vault.setHideScreenOnBackground(enabled);
    }
    async setPasscodeEnabled(isPasscodeEnabled) {
        await this.ready();
        await this._setPasscodeEnabled(isPasscodeEnabled);
    }
    async _setPasscodeEnabled(isPasscodeEnabled) {
        await this.vault.setPasscodeEnabled(isPasscodeEnabled);
        this._config = await this.vault.getConfig();
        if (this.config.isPasscodeSetupNeeded) {
            await this._setPasscode();
        }
    }
    async isBiometricsEnabled() {
        await this.ready();
        return this.vault.isBiometricsEnabled();
    }
    async isBiometricsAvailable() {
        await this.ready();
        return this.vault.isBiometricsAvailable();
    }
    async isBiometricsSupported() {
        await this.ready();
        return this.vault.isBiometricsSupported();
    }
    async isSecureStorageModeEnabled() {
        await this.ready();
        return this.vault.isSecureStorageModeEnabled();
    }
    async isPasscodeEnabled() {
        await this.ready();
        return this.vault.isPasscodeEnabled();
    }
    async _setAuthMode(authMode) {
        authMode = authMode !== undefined ? authMode : this.config.authMode;
        if (authMode === this.config.authMode) {
            return;
        }
        switch (authMode) {
            case AuthMode.BiometricOnly:
                await this._setBiometricsEnabled(true);
                await this._setPasscodeEnabled(false);
                break;
            case AuthMode.PasscodeOnly:
                await this._setPasscodeEnabled(true);
                await this._setBiometricsEnabled(false);
                break;
            case AuthMode.BiometricAndPasscode:
                await this._setPasscodeEnabled(true);
                await this._setBiometricsEnabled(true);
                break;
            case AuthMode.BiometricOrPasscode:
                try {
                    await this._setBiometricsEnabled(true);
                    await this._setPasscodeEnabled(false);
                }
                catch (error) {
                    await this._setPasscodeEnabled(true);
                }
                break;
            case AuthMode.InMemoryOnly:
                await this._setPasscodeEnabled(false);
                await this._setBiometricsEnabled(false);
                await this.vault.setSecureStorageModeEnabled(false);
                break;
            case AuthMode.SecureStorage:
                // Note: Setting this mode automatically disables the other modes in native code.
                await this.vault.setSecureStorageModeEnabled(true);
                break;
            default:
                // eslint-disable-next-line no-throw-literal
                throw { code: VaultErrorCodes.InvalidAuthMode, message: 'Invalid AuthMode' };
        }
    }
    async _trySetAuthMode(authMode) {
        try {
            await this._setAuthMode(authMode);
        }
        catch (error) {
            if (error.code !== VaultErrorCodes.BiometricsNotEnabled && error.code !== VaultErrorCodes.SecurityNotAvailable) {
                throw error;
            }
        }
    }
    async setAuthMode(authMode) {
        await this.ready();
        return this._setAuthMode(authMode);
    }
    async getAuthMode() {
        await this.ready();
        this._config = await this.vault.getConfig();
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return this.config.authMode;
    }
}

class MigratorVault extends IonicIdentityVaultUser {
    /** @ignore */
    constructor(options, onPasscodeRequest, descriptor) {
        super({
            ready: () => Promise.resolve(true),
        }, options, descriptor);
        if (onPasscodeRequest) {
            this.onPasscodeRequest = onPasscodeRequest;
        }
    }
    static getInstance(options, onPasscodeRequest, descriptor) {
        if (!MigratorVault.instance) {
            MigratorVault.instance = new MigratorVault(options, onPasscodeRequest, descriptor);
        }
        return MigratorVault.instance;
    }
}
MigratorVault.instance = undefined;
class VaultMigrator {
    /**
     *
     * @usage
     * ```typescript
     * const legacyVaultConfig = {
     *  unlockOnAccess: true,
     *  hideScreenOnBackground: true,
     *  lockAfter: 5000,
     *  // and more ....
     * }
     * const migrator = new VaultMigrator(legacyVaultConfig, customPasscodePrompt);
     * ```
     * @param options The legacy vault configuration options
     * @param onPasscodeRequest An optional callback function that will be called when the vault attempts to request a passcode. The function returns a promise with a boolean that indicates if the passcode is being setup for the first time for the vault or not.
     * @param descriptor An optional interface that describes the legacy vault.
     */
    constructor(options, onPasscodeRequest, descriptor) {
        this.migratorSession = new MigratorVault(options, onPasscodeRequest, descriptor);
    }
    /**
     * Exports the data of the legacy vault in its entirety.
     *
     * @usage
     * ```typescript
     * const data = await migrator.exportVault();
     * console.log("@@VAULT DATA: ", JSON.stringify(data));
     * ```
     * @returns
     */
    async exportVault() {
        if (!(await this.migratorSession.hasStoredSession())) {
            throw Error('no data in legacy vault');
        }
        await this.migratorSession.unlock();
        const vault = await this.migratorSession.getVault();
        const keys = await vault.getKeys();
        const vaultData = {};
        for (const key of keys) {
            vaultData[key] = await vault.getValue(key);
        }
        return vaultData;
    }
    /**
     * Clears out the legacy vault and removes it from the system.  Be sure to run {@link VaultMigrator.exportVault} before calling this method.
     *
     * @usage
     * ```typescript
     * const data = await migrator.exportVault();
     * await importVault(data);
     * await migrator.clear();
     * ```
     */
    async clear() {
        const vault = await this.migratorSession.getVault();
        return vault.clear();
    }
}

export { AndroidBiometricCryptoPreference, AuthMode, BiometricPermissionState, BiometricSecurityStrength, BrowserVault, Device, DeviceErrorCodes, DeviceSecurityType, SupportedBiometricType, Vault, VaultErrorCodes, VaultMigrator, VaultType };
//# sourceMappingURL=index.js.map
