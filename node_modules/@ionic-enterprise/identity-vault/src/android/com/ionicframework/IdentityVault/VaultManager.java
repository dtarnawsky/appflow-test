package com.ionicframework.IdentityVault;

import android.app.Activity;
import android.content.Context;
import android.content.SharedPreferences;
import android.os.Build;
import androidx.annotation.RequiresApi;
import androidx.appcompat.app.AppCompatActivity;
import androidx.arch.core.util.Function;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import org.apache.cordova.CallbackContext;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

@RequiresApi(api = Build.VERSION_CODES.M)
public class VaultManager {

    private static final HashMap<String, VaultBase> vaults = new HashMap<>();
    private AppCompatActivity activity;
    private Function<IdentityVaultConfig, Void> onConfigChangedCallback;

    public static VaultBase getVault(String key) {
        return vaults.get(key);
    }

    public static HashMap<String, Object> getVaultSharedPrefNameAndBiometricsCypherKey(
        IdentityVaultConfig config,
        AppCompatActivity activity
    ) {
        HashMap<String, Object> map = new HashMap<>();

        SharedPreferences persistedValuesSharedPrefs = activity.getSharedPreferences("iv:" + config.key, Context.MODE_PRIVATE);
        map.put("persistedValuesSharedPrefsName", "iv:" + config.key);

        if (persistedValuesSharedPrefs.contains("data")) {
            // an old vault exists
            map.put("dataSharedPrefsName", "iv:" + config.key);
            map.put("biometricCypherKey", config.key);
        } else {
            // no old vault, use new vault
            map.put("dataSharedPrefsName", String.format("iv:%s-%s[%s]", config.key, config.type, config.deviceSecurityType));
            map.put("biometricCypherKey", String.format("%s-%s[%s]", config.key, config.type, config.deviceSecurityType));
        }

        return map;
    }

    public void setup(IdentityVaultConfig config, Activity activity) throws VaultError {
        this.activity = (AppCompatActivity) activity;

        if (config.unlockVaultOnLoad) {
            VaultBase vault = this.getOrCreateVault(config);
            vault.appLaunched();
        }
    }

    public void clear(IdentityVaultConfig config) throws VaultError {
        VaultBase vault = this.getOrCreateVault(config, true);
        try {
            vault.clear();
        } catch (VaultError e) {
            vault.handleError(e);
            throw e;
        }
    }

    protected void migrateDeviceSecurityVault(IdentityVaultConfig config) throws VaultError {
        VaultBase invalidVault = vaults.get(config.key);
        if (invalidVault != null) {
            if (invalidVault instanceof DeviceSecurityStrongVault || invalidVault instanceof DeviceSecurityWeakVault) {
                boolean isInvalidated = false;

                if (invalidVault instanceof DeviceSecurityStrongVault && ((DeviceSecurityStrongVault) invalidVault).invalidated) {
                    isInvalidated = true;
                }

                if (invalidVault instanceof DeviceSecurityWeakVault && ((DeviceSecurityWeakVault) invalidVault).invalidated) {
                    isInvalidated = true;
                }

                if (isInvalidated) {
                    invalidVault.clear();

                    VaultBase newVault = DeviceSecurityFactory.getDeviceSecurityVault(this.activity, config, Device.getInstance(), true);

                    if (invalidVault.onLockCallback != null) {
                        newVault.onLockCallback = invalidVault.onLockCallback;
                    }

                    if (invalidVault.onUnlockCallback != null) {
                        newVault.onUnlockCallback = invalidVault.onUnlockCallback;
                    }

                    if (invalidVault.onErrorCallback != null) {
                        newVault.onErrorCallback = invalidVault.onErrorCallback;
                    }

                    vaults.remove(config.key);
                    vaults.put(config.key, newVault);
                }
            }
        }
    }

    /** @deprecated Deprecated in favor of using the isEmpty method. */
    @Deprecated
    public boolean doesVaultExist(IdentityVaultConfig config) throws VaultError {
        VaultBase vault = this.getOrCreateVault(config);
        return vault.doesVaultExist();
    }

    public String exportVault(IdentityVaultConfig config) throws VaultError {
        VaultBase vault = this.getOrCreateVault(config);
        try {
            HashMap<String, String> data = vault.exportVault();
            JSONObject jsonObject = new JSONObject(data);
            return jsonObject.toString();
        } catch (VaultError e) {
            vault.handleError(e);
            throw e;
        }
    }

    public String getKeys(IdentityVaultConfig config) throws VaultError {
        VaultBase vault = this.getOrCreateVault(config);
        try {
            String[] keys = vault.getKeys();
            JSONArray jsonObject = new JSONArray(keys);
            return jsonObject.toString();
        } catch (VaultError e) {
            vault.handleError(e);
            throw e;
        } catch (JSONException e) {
            e.printStackTrace();
            VaultError vaultError = new VaultError("Error in getKeys");
            vault.handleError(vaultError);
            throw vaultError;
        }
    }

    public String getValue(IdentityVaultConfig config, String key) throws VaultError {
        VaultBase vault = this.getOrCreateVault(config);
        try {
            return vault.getValue(key);
        } catch (VaultError e) {
            vault.handleError(e);
            throw e;
        }
    }

    public IdentityVaultConfig getVaultConfig(IdentityVaultConfig config) throws VaultError {
        VaultBase vault = this.getOrCreateVault(config);
        return vault.config;
    }

    public void importVault(IdentityVaultConfig config, String json) throws VaultError {
        VaultBase vault = this.getOrCreateVault(config);
        try {
            HashMap<String, String> data = new HashMap<>();
            JSONObject jsonObject = new JSONObject(json);
            for (Iterator<String> it = jsonObject.keys(); it.hasNext();) {
                String key = it.next();
                String value = jsonObject.getString(key);
                data.put(key, value);
            }
            vault.importVault(data);
        } catch (VaultError e) {
            vault.handleError(e);
            throw e;
        } catch (JSONException e) {
            e.printStackTrace();
        }
    }

    public boolean isEmpty(IdentityVaultConfig config) throws VaultError {
        VaultBase vault = this.getOrCreateVault(config, true);
        return vault.isEmpty();
    }

    public boolean isLocked(IdentityVaultConfig config) throws VaultError {
        VaultBase vault = this.getOrCreateVault(config);
        return vault.isLocked();
    }

    public void lock(IdentityVaultConfig config) throws VaultError {
        VaultBase vault = this.getOrCreateVault(config);
        vault.lock(false);
    }

    public void removeValue(IdentityVaultConfig config, String key) throws VaultError {
        VaultBase vault = this.getOrCreateVault(config);
        try {
            vault.removeValue(key);
        } catch (VaultError e) {
            vault.handleError(e);
            throw e;
        }
    }

    public void setCustomPasscode(IdentityVaultConfig config, String passcode) throws VaultError {
        VaultBase vault = this.getOrCreateVault(config);
        vault.setCustomPasscode(passcode);
    }

    public void setValue(IdentityVaultConfig config, String key, String value) throws VaultError {
        VaultBase vault = this.getOrCreateVault(config);
        try {
            vault.setValue(key, value);
        } catch (VaultError e) {
            vault.handleError(e);
            throw e;
        }
    }

    public void unlock(IdentityVaultConfig config) throws VaultError {
        VaultBase vault = this.getOrCreateVault(config);
        try {
            vault.unlock();
        } catch (VaultError e) {
            vault.handleError(e);
            throw e;
        }
    }

    public void updateConfig(IdentityVaultConfig newConfig) throws VaultError {
        VaultBase oldVault = this.getOrCreateVault(newConfig);
        String passcodeFromOldVault = oldVault.customPasscode;
        if (passcodeFromOldVault == null && newConfig.type.equals("CustomPasscode")) {
            throw new MissingPasscodeError(true);
        }

        HashMap<String, String> data = new HashMap<String, String>();

        if (!oldVault.isEmpty()) {
            oldVault.unlock();
            data = oldVault.exportVault();
        }

        try {
            if (!(newConfig.type.equals("DeviceSecurity") && oldVault.config.type.equals("DeviceSecurity"))) {
                oldVault.clear();
            } else {
                oldVault.clearTypes();
            }

            VaultBase newVault = StateStore.pendingVault != null ? StateStore.pendingVault : createVault(newConfig);
            if (newVault instanceof CustomPasscodeVault) {
                newVault.customPasscode = passcodeFromOldVault;
            }

            if (newVault.config.type.equals("DeviceSecurity") && StateStore.pendingVault == null) {
                StateStore.pendingVault = newVault;
            }

            newVault.importVault(data);
            vaults.put(newVault.config.key, newVault);
            StateStore.pendingVault = null;

            if (oldVault.onLockCallback != null) {
                newVault.onLock(oldVault.onLockCallback);
            }

            if (oldVault.onUnlockCallback != null) {
                newVault.onUnlock(oldVault.onUnlockCallback);
            }

            if (oldVault.onErrorCallback != null) {
                newVault.onError(oldVault.onErrorCallback);
            }

            if (this.onConfigChangedCallback != null) {
                this.onConfigChangedCallback.apply(newConfig);
            }
        } catch (VaultError error) {
            // if there was an error, keep the old vault in place
            if (passcodeFromOldVault != null) {
                oldVault.customPasscode = passcodeFromOldVault;
            }
            if (data != null) {
                oldVault.importVault(data);
            }
            vaults.put(oldVault.config.key, oldVault);

            oldVault.handleError(error);
            throw error;
        }
    }

    public void onConfigChanged(Function<IdentityVaultConfig, Void> callback) {
        this.onConfigChangedCallback = callback;
    }

    public void onLock(IdentityVaultConfig config, Function<Boolean, Void> callback) throws VaultError {
        VaultBase vault = this.getOrCreateVault(config);
        vault.onLock(callback);
    }

    public void onUnlock(IdentityVaultConfig config, Function<Void, Void> callback) throws VaultError {
        VaultBase vault = this.getOrCreateVault(config);
        vault.onUnlock(callback);
    }

    public void onError(IdentityVaultConfig config, Function<ErrorCallbackArgs, Void> callback) throws VaultError {
        VaultBase vault = this.getOrCreateVault(config);
        vault.onError(callback);
    }

    protected void vaultManagerAppEnteredBackground() {
        for (Map.Entry<String, VaultBase> set : vaults.entrySet()) {
            set.getValue().backgroundEntered();
        }
    }

    protected void verifyDeviceSecuritySettings(VaultBase vault) throws VaultError {
        if (vault instanceof DeviceSecurityStrongVault || vault instanceof DeviceSecurityWeakVault) {
            VaultBase currentSupportedVault = DeviceSecurityFactory.getDeviceSecurityVault(
                this.activity,
                vault.config,
                Device.getInstance()
            );

            if (!currentSupportedVault.getClass().equals(vault.getClass())) {
                if (vault instanceof DeviceSecurityStrongVault) {
                    DeviceSecurityStrongVault deviceSecurityVault = (DeviceSecurityStrongVault) vault;
                    deviceSecurityVault.setIsInvalidated(true);
                }

                if (vault instanceof DeviceSecurityWeakVault) {
                    DeviceSecurityWeakVault deviceSecurityVault = (DeviceSecurityWeakVault) vault;
                    deviceSecurityVault.setIsInvalidated(true);
                }
            }
        }
    }

    protected void vaultManagerAppResumed(IdentityVaultConfig config) throws VaultError {
        VaultBase vault = this.getOrCreateVault(config);
        try {
            verifyDeviceSecuritySettings(vault);
            vault.appResumed();
        } catch (VaultError error) {
            vault.handleError(error);
            throw error;
        }
    }

    private VaultBase getOrCreateVault(IdentityVaultConfig config) throws VaultError {
        return this.getOrCreateVault(config, false);
    }

    private VaultBase getOrCreateVault(IdentityVaultConfig config, boolean ignoreAuth) throws VaultError {
        VaultBase vault = vaults.get(config.key);
        if (vault == null) {
            vault = createVault(config, ignoreAuth);
            vaults.put(config.key, vault);
        }
        return vault;
    }

    private VaultBase createVault(IdentityVaultConfig config) throws VaultError {
        return this.createVault(config, false);
    }

    private VaultBase createVault(IdentityVaultConfig config, boolean ignoreAuth) throws VaultError {
        VaultBase vault;

        HashMap<String, Object> sharedPrefNameAndBioCypherKey = VaultManager.getVaultSharedPrefNameAndBiometricsCypherKey(config, activity);
        String sharedPrefName = (String) sharedPrefNameAndBioCypherKey.get("persistedValuesSharedPrefsName");

        String vaultType = VaultBase.getPersistedVaultType(sharedPrefName, this.activity);

        if (vaultType != null) {
            config.type = vaultType;
        }

        String vaultDeviceSecurityType = VaultBase.getPersistedVaultDeviceSecurityType(sharedPrefName, this.activity);
        if (vaultDeviceSecurityType != null) {
            config.deviceSecurityType = vaultDeviceSecurityType;
        }

        switch (config.type) {
            case "CustomPasscode":
                vault = new CustomPasscodeVault(config, this.activity);
                break;
            case "DeviceSecurity":
                vault = DeviceSecurityFactory.getDeviceSecurityVault(this.activity, config, Device.getInstance(), ignoreAuth);
                break;
            case "SecureStorage":
                vault = new SecureStorageVault(config, this.activity);
                break;
            case "InMemory":
                vault = new InMemoryVault(config, this.activity);
                break;
            default:
                throw new VaultError("Vault Config type " + config.type + " is not a valid type");
        }
        return vault;
    }
}
