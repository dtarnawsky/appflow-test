package com.ionicframework.IdentityVault;

import android.content.Context;
import android.content.SharedPreferences;
import android.os.Build;
import androidx.annotation.RequiresApi;
import androidx.appcompat.app.AppCompatActivity;
import androidx.arch.core.util.Function;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import javax.crypto.Cipher;
import org.apache.cordova.CallbackContext;
import org.json.JSONException;
import org.json.JSONObject;

@RequiresApi(api = Build.VERSION_CODES.M)
abstract class VaultBase {

    protected final AppCompatActivity activity;
    public final IdentityVaultConfig config;
    protected Function<Boolean, Void> onLockCallback;
    protected Function<Void, Void> onUnlockCallback;
    protected Function<ErrorCallbackArgs, Void> onErrorCallback;
    protected HashMap<String, String> data;
    protected String customPasscode;
    protected int allowedInvalidUnlockAttempts = 0;
    protected Date backgroundEnteredAt;
    protected String dataSharedPrefsName;
    protected String persistedValuesSharedPrefsName;
    protected String biometricCypherKey;

    protected abstract String getVaultType();

    protected abstract String getVaultStrength();

    public VaultBase(IdentityVaultConfig config, AppCompatActivity activity) {
        this.config = config;
        this.activity = activity;

        HashMap<String, Object> sharedPrefNameAndBioCypherKey = VaultManager.getVaultSharedPrefNameAndBiometricsCypherKey(config, activity);
        this.dataSharedPrefsName = (String) sharedPrefNameAndBioCypherKey.get("dataSharedPrefsName");
        this.persistedValuesSharedPrefsName = (String) sharedPrefNameAndBioCypherKey.get("persistedValuesSharedPrefsName");
        this.biometricCypherKey = (String) sharedPrefNameAndBioCypherKey.get("biometricCypherKey");
    }

    public static String getPersistedVaultType(String sharedPrefName, AppCompatActivity activity) throws VaultError {
        SharedPreferences pref = activity.getSharedPreferences(sharedPrefName, Context.MODE_PRIVATE);
        return pref.getString("vaultType", null);
    }

    public static String getPersistedVaultDeviceSecurityType(String sharedPrefName, AppCompatActivity activity) {
        SharedPreferences pref = activity.getSharedPreferences(sharedPrefName, Context.MODE_PRIVATE);
        return pref.getString("vaultDeviceSecurityType", null);
    }

    public static String getPersistedVaultStrength(String sharedPrefName, AppCompatActivity activity) {
        SharedPreferences pref = activity.getSharedPreferences(sharedPrefName, Context.MODE_PRIVATE);
        return pref.getString("vaultStrength", null);
    }

    public void clear() throws VaultError {
        this.clearStoredData();
        this.clearIsEmptyFlag();
        this.data = null;
        this.customPasscode = null;
        BiometricCipherHelper.removeKey(this.biometricCypherKey);
        BiometricCipherHelper.removeKey(this.dataSharedPrefsName);
        BiometricCipherHelper.removeKey(this.persistedValuesSharedPrefsName);
    }

    public void clearTypes() throws VaultError {
        try {
            SharedPreferences pref = this.activity.getSharedPreferences(persistedValuesSharedPrefsName, Context.MODE_PRIVATE);
            SharedPreferences.Editor editor = pref.edit();
            editor.remove("vaultType");
            editor.remove("vaultDeviceSecurityType");
            editor.remove("vaultStrength");
            editor.apply();
        } catch (Exception e) {
            throw new VaultError(e.getLocalizedMessage());
        }
    }

    /** @deprecated Deprecated in favor of using the isEmpty method. */
    @Deprecated
    public boolean doesVaultExist() {
        return this.checkIfVaultExists();
    }

    public HashMap<String, String> exportVault() throws VaultError {
        this.unlock();
        return this.data;
    }

    public String[] getKeys() throws VaultError {
        if (!this.doesVaultExist()) {
            return null;
        }
        this.unlock();
        return this.data.keySet().toArray(new String[0]);
    }

    public String getValue(String key) throws VaultError {
        if (!this.doesVaultExist()) {
            return null;
        }
        this.unlock();
        return this.data.get(key);
    }

    public void importVault(HashMap<String, String> data) throws VaultError {
        this.unlock();
        this.data = data;
        this.storeData();
    }

    public boolean isEmpty() {
        return this.getIsEmptyFlag();
    }

    public boolean isLocked() {
        return this.data == null;
    }

    public void lock(boolean wasTimeout) {
        if (!this.isLocked() && this.doesVaultExist()) {
            this.data = null;
            this.customPasscode = null;

            if (this.onLockCallback != null) {
                this.onLockCallback.apply(wasTimeout);
            }
        }
    }

    public void requestBiometricPrompt() throws VaultError {
        throw new SecurityNotAvailableError();
    }

    public void removeValue(String key) throws VaultError {
        this.unlock();
        this.data.remove(key);
        this.storeData();
    }

    public void setCustomPasscode(String passcode) throws VaultError {
        boolean isPasscodeVault = this instanceof CustomPasscodeVault;
        if (isPasscodeVault && this.customPasscode != null && !this.customPasscode.equals(passcode)) {
            HashMap<String, String> data = this.exportVault();
            this.customPasscode = passcode;
            this.importVault(data);
        } else {
            this.customPasscode = passcode;
        }
    }

    public void setValue(String key, String value) throws VaultError {
        this.unlock();
        this.data.put(key, value);
        this.storeData();
    }

    public void unlock() throws VaultError {
        this.unlock(true);
    }

    public void unlock(boolean forceUnlock) throws VaultError {
        if (this.isLocked()) {
            if (this.doesVaultExist() || forceUnlock) {
                this.getData();
                if (this.onUnlockCallback != null) {
                    this.onUnlockCallback.apply(null);
                }
            }
        }
    }

    public void onUnlock(Function<Void, Void> callback) {
        this.onUnlockCallback = callback;
    }

    public void onLock(Function<Boolean, Void> callback) {
        this.onLockCallback = callback;
    }

    public void onError(Function<ErrorCallbackArgs, Void> callback) {
        this.onErrorCallback = callback;
    }

    protected void appLaunched() throws VaultError {
        if (this.config.unlockVaultOnLoad) {
            this.unlock(false);
        }
    }

    protected void appResumed() throws VaultError {
        try {
            if (this.config.lockAfterBackgrounded != null && this.backgroundEnteredAt != null) {
                long elapsed = Math.abs(new Date().getTime() - this.backgroundEnteredAt.getTime());
                if (elapsed >= this.config.lockAfterBackgrounded) {
                    this.lock(true);
                }
            }

            this.backgroundEnteredAt = null;

            if (this.isLocked() && this.config.unlockVaultOnLoad) {
                this.unlock(false);
            }
        } catch (VaultError e) {
            throw e;
        } catch (Exception e) {
            throw new VaultError(e.getLocalizedMessage());
        }
    }

    protected void backgroundEntered() {
        if (this.config.lockAfterBackgrounded != null) {
            this.backgroundEnteredAt = new Date();
        }
    }

    private boolean checkIfVaultExists() {
        //todo: should we check existence of key as well?
        if (!this.isLocked()) {
            return true;
        }
        SharedPreferences pref = this.activity.getSharedPreferences(dataSharedPrefsName, Context.MODE_PRIVATE);
        return pref.contains("data");
    }

    private boolean checkIfVaultStrengthConsistent() {
        SharedPreferences pref = this.activity.getSharedPreferences(persistedValuesSharedPrefsName, Context.MODE_PRIVATE);
        String persistedVaultStrength = pref.getString("vaultStrength", null);

        if (persistedVaultStrength == null) {
            return false;
        }

        return persistedVaultStrength.equals(this.getVaultStrength());
    }

    private boolean isDecryptionSuccessful(JSONObject decryptedData) {
        if (decryptedData.length() == 3 && decryptedData.has("data") && decryptedData.has("iv") && decryptedData.has("salt")) {
            return false;
        }

        return true;
    }

    protected void clearStoredData() throws VaultError {
        try {
            SharedPreferences pref = this.activity.getSharedPreferences(dataSharedPrefsName, Context.MODE_PRIVATE);
            SharedPreferences.Editor editor = pref.edit();
            editor.remove("data");
            editor.apply();

            SharedPreferences persistedValuesPref =
                this.activity.getSharedPreferences(persistedValuesSharedPrefsName, Context.MODE_PRIVATE);
            SharedPreferences.Editor persistedValuesPrefEditor = persistedValuesPref.edit();
            persistedValuesPrefEditor.remove("vaultType");
            persistedValuesPrefEditor.remove("vaultDeviceSecurityType");
            persistedValuesPrefEditor.remove("vaultStrength");
            persistedValuesPrefEditor.apply();
        } catch (Exception e) {
            throw new VaultError(e.getLocalizedMessage());
        }
    }

    protected void getData() throws VaultError {
        try {
            if (this.data == null) {
                data = new HashMap<>();
                SharedPreferences pref = this.activity.getSharedPreferences(dataSharedPrefsName, Context.MODE_PRIVATE);
                String encryptedJsonString = pref.getString("data", null);

                if (encryptedJsonString != null) {
                    String passcode = this instanceof DeviceSecurityStrongVault
                        ? ((DeviceSecurityStrongVault) this).masterPasscode
                        : this.customPasscode;
                    String decryptedJsonString = CryptoData.decrypt(
                        dataSharedPrefsName,
                        encryptedJsonString,
                        passcode,
                        activity.getApplicationContext()
                    );
                    //String decryptedJsonString = AsymmetricCrypto.decrypt(encryptedJsonString, dataSharedPrefsName, passcode, this.activity);
                    JSONObject jsonObject = new JSONObject(decryptedJsonString);

                    if (!isDecryptionSuccessful(jsonObject)) {
                        if (this instanceof DeviceSecurityStrongVault || this instanceof DeviceSecurityWeakVault) {
                            if (!checkIfVaultStrengthConsistent()) {
                                this.clear();
                                throw new InvalidatedCredentialsError();
                            }
                        }
                    }

                    for (Iterator<String> it = jsonObject.keys(); it.hasNext();) {
                        String key = it.next();
                        String value = jsonObject.getString(key);
                        this.data.put(key, value);
                    }
                    this.refreshIsEmptyFlag();
                } else {
                    this.storeData();
                }

                this.setFailedUnlockAttempts(0);
            }
        } catch (AuthFailedError e) {
            this.lock(false);
            if (this instanceof CustomPasscodeVault) {
                int failedUnlockAttempts = this.getFailedUnlockAttempts();
                failedUnlockAttempts += 1;
                if (failedUnlockAttempts >= this.allowedInvalidUnlockAttempts) {
                    this.clear();
                    this.setFailedUnlockAttempts(0);
                    throw new TooManyFailedAttemptsError();
                }
                this.setFailedUnlockAttempts(failedUnlockAttempts);
            }
            throw e;
        } catch (JSONException e) {
            if (!this.checkIfVaultStrengthConsistent()) {
                this.clear();
                throw new InvalidatedCredentialsError();
            }
            throw new VaultError(e.getLocalizedMessage());
        } catch (Exception e) {
            throw new VaultError(e.getLocalizedMessage());
        }
    }

    protected void storeData() throws VaultError {
        try {
            JSONObject dataJsonObject = new JSONObject(this.data);
            String dataJsonString = dataJsonObject.toString();
            String passcode = this instanceof DeviceSecurityStrongVault
                ? ((DeviceSecurityStrongVault) this).masterPasscode
                : this.customPasscode;
            String encryptedDataJson = CryptoData.encrypt(dataSharedPrefsName, dataJsonString, passcode, activity.getApplicationContext());
            String vaultType = this.getVaultType();
            String vaultStrength = this.getVaultStrength();

            SharedPreferences pref = this.activity.getSharedPreferences(dataSharedPrefsName, Context.MODE_PRIVATE);
            SharedPreferences.Editor editor = pref.edit();
            editor.putString("data", encryptedDataJson);
            editor.apply();

            SharedPreferences persistedValuesPref =
                this.activity.getSharedPreferences(persistedValuesSharedPrefsName, Context.MODE_PRIVATE);
            SharedPreferences.Editor persistedValuesPrefEditor = persistedValuesPref.edit();
            persistedValuesPrefEditor.putString("vaultType", vaultType);
            persistedValuesPrefEditor.putString("vaultDeviceSecurityType", config.deviceSecurityType);
            persistedValuesPrefEditor.putString("vaultStrength", vaultStrength);
            persistedValuesPrefEditor.apply();

            this.refreshIsEmptyFlag();
        } catch (Exception e) {
            throw new VaultError(e.getLocalizedMessage());
        }
    }

    private int getFailedUnlockAttempts() {
        SharedPreferences pref = this.activity.getSharedPreferences(persistedValuesSharedPrefsName, Context.MODE_PRIVATE);
        return pref.getInt("unlockAttempts", 0);
    }

    private void setFailedUnlockAttempts(int failedUnlockAttempts) {
        SharedPreferences pref = this.activity.getSharedPreferences(persistedValuesSharedPrefsName, Context.MODE_PRIVATE);
        SharedPreferences.Editor editor = pref.edit();
        editor.putInt("unlockAttempts", failedUnlockAttempts);
        editor.apply();
    }

    private void refreshIsEmptyFlag() {
        if (!this.isLocked()) {
            this.setIsEmptyFlag(this.data.keySet().toArray(new String[0]).length <= 0);
        }
    }

    private void clearIsEmptyFlag() {
        SharedPreferences pref = this.activity.getSharedPreferences(persistedValuesSharedPrefsName, Context.MODE_PRIVATE);
        SharedPreferences.Editor editor = pref.edit();
        editor.remove("isEmpty");
        editor.apply();
    }

    private boolean getIsEmptyFlag() {
        SharedPreferences pref = this.activity.getSharedPreferences(persistedValuesSharedPrefsName, Context.MODE_PRIVATE);
        if (pref.contains("isEmpty")) {
            return pref.getBoolean("isEmpty", true);
        } else {
            if (pref.contains("data")) {
                setIsEmptyFlag(false);
                return false;
            } else {
                setIsEmptyFlag(true);
                return true;
            }
        }
    }

    private void setIsEmptyFlag(boolean empty) {
        SharedPreferences pref = this.activity.getSharedPreferences(persistedValuesSharedPrefsName, Context.MODE_PRIVATE);
        SharedPreferences.Editor editor = pref.edit();
        editor.putBoolean("isEmpty", empty);
        editor.apply();
    }

    protected void handleError(VaultError error) {
        if (!(error instanceof MissingBiometricsError) && !(error instanceof MismatchedDeviceSecurityVault)) {
            if (this.onErrorCallback != null) {
                ErrorCallbackArgs args = new ErrorCallbackArgs();
                args.error = VaultErrors.toJSON(error);
                args.vaultKey = this.config.key;
                this.onErrorCallback.apply(args);
            }
        }
    }
}
