package com.ionicframework.IdentityVault;

import android.os.Build;
import android.security.keystore.KeyPermanentlyInvalidatedException;
import android.security.keystore.KeyProperties;
import android.security.keystore.KeyProtection;
import android.util.Base64;
import androidx.annotation.RequiresApi;
import java.nio.charset.StandardCharsets;
import java.security.InvalidKeyException;
import java.security.KeyStore;
import java.security.MessageDigest;
import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.Collections;
import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.GCMParameterSpec;
import org.json.JSONObject;

@RequiresApi(api = Build.VERSION_CODES.M)
public class PairedAESKeysHelper {

    private static final String CIPHER_INSTANCE = "AES/GCM/NoPadding";

    public static String encryptMasterPasscode(String alias, String deviceSecurityType, String newPassword) throws VaultError {
        try {
            createKeys(alias, deviceSecurityType);
            KeyStore keyStore = KeyStore.getInstance("AndroidKeyStore");
            keyStore.load(null);
            SecretKey secretKey = (SecretKey) keyStore.getKey(alias + "-encrypt_key", null);
            Cipher cipher = Cipher.getInstance(CIPHER_INSTANCE);
            cipher.init(Cipher.ENCRYPT_MODE, secretKey);
            byte[] iv = cipher.getIV();
            byte[] securePasswordBytes = encodeStringToBase64Bytes(newPassword);
            byte[] encryptedSecurePasswordBytes = cipher.doFinal(securePasswordBytes);
            JSONObject jsonObject = new JSONObject();
            jsonObject.put("encryptedPassword", encodeBytesToBase64String(encryptedSecurePasswordBytes));
            jsonObject.put("iv", encodeBytesToBase64String(iv));
            return jsonObject.toString();
        } catch (Exception e) {
            e.printStackTrace();
            throw new VaultError(e.getLocalizedMessage());
        }
    }

    protected static String generateSecurePassword() throws VaultError {
        try {
            SecureRandom randomNumber = new SecureRandom();
            ArrayList<Character> valueObj = new ArrayList<>();
            // ASCII Decimal values between 32 and 127 without any quotes or backticks
            for (int i = 33; i < 127; i++) {
                if (i != 34 && i != 39 && i != 96) {
                    valueObj.add((char) i);
                }
            }
            Collections.rotate(valueObj, 5);
            StringBuilder stringBuilder = new StringBuilder();
            for (int length = 0; length < 15; length++) {
                stringBuilder.append(valueObj.get(randomNumber.nextInt(valueObj.size())));
            }
            String str = stringBuilder.toString();
            MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");
            messageDigest.update(str.getBytes());
            return bytesToHexString(messageDigest.digest());
        } catch (Exception e) {
            e.printStackTrace();
            throw new VaultError(e.getLocalizedMessage());
        }
    }

    private static void createKeys(String alias, String deviceSecurityType) throws VaultError {
        try {
            KeyGenerator keyGen = KeyGenerator.getInstance("AES");
            keyGen.init(256);
            SecretKey secretKey = keyGen.generateKey();

            KeyStore keyStore = KeyStore.getInstance("AndroidKeyStore");
            keyStore.load(null);

            KeyProtection.Builder encryptKeyBuilder = new KeyProtection.Builder(KeyProperties.PURPOSE_ENCRYPT);
            encryptKeyBuilder.setBlockModes(KeyProperties.BLOCK_MODE_GCM).setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE);
            keyStore.setEntry(alias + "-encrypt_key", new KeyStore.SecretKeyEntry(secretKey), encryptKeyBuilder.build());

            KeyProtection.Builder decryptionKeyBuilder = new KeyProtection.Builder(KeyProperties.PURPOSE_DECRYPT);
            decryptionKeyBuilder
                .setBlockModes(KeyProperties.BLOCK_MODE_GCM)
                .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)
                .setUserAuthenticationRequired(true);

            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
                switch (deviceSecurityType) {
                    case "SystemPasscode":
                        decryptionKeyBuilder.setUserAuthenticationParameters(0, KeyProperties.AUTH_DEVICE_CREDENTIAL);
                        break;
                    case "Biometrics":
                        decryptionKeyBuilder.setUserAuthenticationParameters(0, KeyProperties.AUTH_BIOMETRIC_STRONG);
                        break;
                    case "Both":
                        decryptionKeyBuilder.setUserAuthenticationParameters(
                            0,
                            KeyProperties.AUTH_BIOMETRIC_STRONG | KeyProperties.AUTH_DEVICE_CREDENTIAL
                        );
                        break;
                }
            } else {
                decryptionKeyBuilder.setUserAuthenticationValidityDurationSeconds(-1);
            }

            if (Build.VERSION.SDK_INT >= 24) {
                decryptionKeyBuilder.setInvalidatedByBiometricEnrollment(true);
            }

            /*
            boolean supportsHardwareSecurity = Device.getInstance().hasSecureHardware();
            if (Build.VERSION.SDK_INT >= 28 && supportsHardwareSecurity) {
                decryptionKeyBuilder.setIsStrongBoxBacked(true);
            }
            */

            keyStore.setEntry(alias + "-decrypt_key", new KeyStore.SecretKeyEntry(secretKey), decryptionKeyBuilder.build());
            secretKey = null;
        } catch (Exception e) {
            e.printStackTrace();
            throw new VaultError(e.getLocalizedMessage());
        }
    }

    public static Cipher getDecryptionCipher(String alias, String iv) throws VaultError {
        try {
            byte[] ivData = encodeBase64StringToBytes(iv);
            KeyStore keyStore = KeyStore.getInstance("AndroidKeyStore");
            keyStore.load(null);
            SecretKey secretKey = (SecretKey) keyStore.getKey(alias + "-decrypt_key", null);
            Cipher cipher = Cipher.getInstance(CIPHER_INSTANCE);
            GCMParameterSpec gcmParameterSpec = new GCMParameterSpec(128, ivData);
            cipher.init(Cipher.DECRYPT_MODE, secretKey, gcmParameterSpec);
            return cipher;
        } catch (KeyPermanentlyInvalidatedException e) {
            throw new InvalidatedCredentialsError();
        } catch (InvalidKeyException e) {
            e.printStackTrace();
            throw new UnexpectedKeystoreError(e.getLocalizedMessage());
        } catch (Exception e) {
            e.printStackTrace();
            throw new VaultError(e.getLocalizedMessage());
        }
    }

    protected static byte[] encodeBase64StringToBytes(String base64String) {
        return Base64.decode(base64String, Base64.DEFAULT);
    }

    protected static byte[] encodeStringToBase64Bytes(String stringToEncode) {
        return Base64.decode(stringToEncode.getBytes(StandardCharsets.UTF_8), Base64.DEFAULT);
    }

    protected static String encodeBytesToBase64String(byte[] bytes) {
        return Base64.encodeToString(bytes, Base64.DEFAULT);
    }

    private static String bytesToHexString(byte[] bytes) {
        StringBuilder sb = new StringBuilder();
        for (byte aByte : bytes) {
            String hex = Integer.toHexString(0xFF & aByte);
            if (hex.length() == 1) {
                sb.append('0');
            }
            sb.append(hex);
        }
        return sb.toString();
    }
}
