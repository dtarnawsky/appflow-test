import parse from 'url-parse';
import { UrlHelper } from './urlHelper';
import { IonicBaseAuth } from './base-auth';
import { logging } from './logging';
export class IonicAuthWeb extends IonicBaseAuth {
    constructor(options, handlers) {
        super(options, handlers);
        this.options = options;
        this.handlers = handlers;
        this.logTag = 'IonicWebAuth: ';
        this.logger.debug(this.logTag, 'ctor options', options);
        window.addEventListener('message', event => {
            this.logger.debug(this.logTag, 'event: ', event);
        });
    }
    async internalGetToken(_codeName, _code, _grantType, _verifier, scope) {
        this.logger.debug(this.logTag, 'getting token');
        // setup the env for a new token request
        const keys = await this.authConfig.generateChallengeAndVerifier();
        await this.session.setAuthData(keys);
        const nonce = (await this.session.getNonce()) || '';
        // setup the url for the token
        let urlInfo = await this.authConfig.getAuthorizeUrl(nonce, keys.challenge, {});
        let url = new URL(urlInfo.url);
        url.searchParams.set('prompt', 'none');
        url.searchParams.set('scope', scope);
        url.searchParams.set('response_type', 'token');
        this.logger.debug(this.logTag, 'url for internalGetToken: ', url.href);
        const result = await this.hiddenLoadUrl(url.href);
        const callbackString = result.callback;
        if (callbackString != undefined && callbackString != '') {
            const parsedUrl = parse(callbackString, true);
            let result = UrlHelper.parseHash(parsedUrl.hash);
            const authResult = {
                accessToken: result.access_token,
                idToken: result.id_token,
                refreshToken: result.refresh_token,
                expiresIn: result.expires_in,
                scope: result.scope,
                tokenType: result.token_type,
            };
            this.logger.debug(this.logTag, 'returning authResult: ', authResult);
            return authResult;
        }
        else {
            var error = 'could not get token';
            this.logger.error(error);
            throw error;
        }
    }
    async internalHandleCallback(url, externalCallback) {
        this.logger.debug(this.logTag, 'handleCallback url:' + url);
        const parsedUrl = parse(url, true);
        const searchParams = new URLSearchParams(parsedUrl.hash);
        this.logger.debug(this.logTag, 'searchParams: ', JSON.stringify(searchParams));
        if (searchParams.has('error_description')) {
            const errorDescription = searchParams.get('error_description');
            this.logger.debug('error_description' + errorDescription);
            throw new Error(errorDescription);
        }
        const query_params = parsedUrl.query;
        this.logger.debug(this.logTag, 'query params: ', query_params);
        const hash = UrlHelper.parseHash(parsedUrl.hash);
        this.logger.debug(this.logTag, 'hash: ', hash);
        if ((hash.access_token != undefined && hash.id_token != undefined) ||
            (this.options.webAuthFlow &&
                this.options.webAuthFlow === 'PKCE' &&
                query_params.code != undefined)) {
            let result = {};
            const session = await this.session.getAuthData();
            if (!session) {
                throw new Error('No session data stored');
            }
            this.logger.debug(this.logTag, 'got a session');
            if (query_params.code != undefined) {
                var options = {
                    grant_type: 'authorization_code',
                    client_id: this.options.clientID,
                    code_verifier: session.verifier,
                    code: query_params.code,
                    redirect_uri: String(this.options.redirectUri),
                };
                result = await this.postToken(options);
            }
            else {
                result = hash;
            }
            return await this.handleAuthResult(result);
        }
        else {
            var error = 'Web only supports implicit login with id and access token returned from the authorize call or PKCE';
            this.logger.error(error);
            throw error;
        }
    }
    async refreshSession(tokenName) {
        this.logger.debug(this.logTag, 'refreshing session');
        await this.getOverrideDiscoveryUrl();
        if (tokenName) {
            this.logger.debug(this.logTag, 'refreshing other token: ', tokenName);
            const scope = await this.session.getTokenScopes(tokenName);
            const authResult = await this.internalGetToken('', '', '', undefined, scope);
            await this.setSession(authResult, tokenName, scope);
            return;
        }
        if (this.options.webAuthFlow === 'PKCE') {
            const refreshToken = await this.getRefreshToken();
            if (!refreshToken) {
                throw new Error('No refresh token available');
            }
            let options = {
                grant_type: 'refresh_token',
                client_id: this.options.clientID,
                refresh_token: refreshToken,
            };
            const result = await this.postToken(options);
            await this.handleAuthResult(result);
        }
        else {
            const keys = await this.authConfig.generateChallengeAndVerifier();
            await this.session.clearAuthData();
            await this.session.setAuthData(keys);
            this.logger.debug(this.logTag, 'keys: ', keys);
            const nonce = (await this.session.getNonce()) || '';
            this.logger.debug(this.logTag, 'nonce: ', nonce);
            let url = await this.authConfig.getAuthorizeUrl(nonce, keys.challenge, {});
            url.url = url.url + '&prompt=none';
            this.logger.debug(this.logTag, 'url for refresh: ', url.url);
            try {
                const result = await this.hiddenLoadUrl(url.url);
                this.logger.debug(this.logTag, 'result for refresh: ', result);
                const callbackString = result.callback;
                if (callbackString != undefined && callbackString != '') {
                    this.logger.debug(this.logTag, 'calling handleCallback');
                    await this.internalHandleCallback(callbackString, false);
                }
            }
            catch (e) {
                var error = 'Failed to refresh session';
                this.logger.error(error);
                throw error;
            }
        }
    }
    async handleAuthResult(result) {
        if (this.storage.setAuthResponse) {
            await this.storage.setAuthResponse(result);
        }
        this.logger.debug(this.logTag, 'result: ', result);
        const authResult = {
            accessToken: result.access_token,
            idToken: result.id_token,
            refreshToken: result.refresh_token,
            expiresIn: result.expires_in,
            scope: result.scope,
            tokenType: result.token_type,
        };
        await this.setSession(authResult);
        this.logger.debug(this.logTag, 'clear auth data');
        await this.session.clearAuthData();
        this.logger.debug(this.logTag, 'return auth result', authResult);
        return authResult;
    }
    async postToken(options) {
        const tokenUrlInfo = await this.authConfig.getTokenUrl();
        const tokenUrl = tokenUrlInfo.url || '';
        const headers = Object.assign(Object.assign({}, tokenUrlInfo.headers), { 'Content-Type': 'application/x-www-form-urlencoded' });
        options = Object.assign(Object.assign({}, tokenUrlInfo.payload), options);
        const bodyParams = Object.keys(options)
            .map(key => {
            return encodeURIComponent(key) + '=' + encodeURIComponent(options[key]);
        })
            .join('&');
        const response = await fetch(tokenUrl, {
            method: 'POST',
            headers: headers,
            body: bodyParams,
        });
        if (!response.ok) {
            const jsonRes = await response.json();
            const errorMessage = `POST to token endpoint failed with error: ${jsonRes.error_description ? jsonRes.error_description : jsonRes.error}`;
            this.logger.error(errorMessage);
            throw errorMessage;
        }
        return JSON.parse(await response.text());
    }
    hiddenLoadUrl(url) {
        try {
            return new Promise((resolve, reject) => {
                this.logger.debug(this.logTag, 'opening browser.');
                let iframeLocation;
                const iframe = document.createElement('iframe');
                iframe.style.display = 'none';
                iframe.src = url;
                document.getElementsByTagName('body')[0].appendChild(iframe);
                iframe.src = url;
                const that = this;
                var timer = window.setInterval(() => {
                    try {
                        if (iframe === null) {
                            return;
                        }
                        if (iframe.contentWindow !== null) {
                            iframeLocation = iframe.contentWindow.location;
                        }
                        else if (iframe.contentDocument !== null) {
                            iframeLocation = iframe.contentDocument.location;
                        }
                        else {
                            this.logger.debug(this.logTag, 'no doc or window');
                            return;
                        }
                        if (!encodeURI(iframeLocation.href).indexOf(encodeURI(that.options.redirectUri))) {
                            window.clearInterval(timer);
                            const href = iframeLocation.href;
                            this.logger.debug(this.logTag, 'closing iframe: ', href);
                            if (iframe.parentNode !== null) {
                                iframe.parentNode.removeChild(iframe);
                            }
                            this.logger.debug(this.logTag, 'calling resolve');
                            resolve({ event: 'opened', callback: href });
                        }
                        return;
                    }
                    catch (e) {
                        window.clearInterval(timer);
                        this.logger.error(this.logTag, e.message);
                        reject(e.message);
                    }
                }, 1);
            });
        }
        catch (err) {
            this.logger.error(this.logTag, 'hiddenLoadUrl error: ', err);
            throw err;
        }
    }
    showUrl(url, _options, urlToCloseWindow = this.options.redirectUri) {
        try {
            if (this.options.implicitLogin !== 'CURRENT') {
                // POPUP
                return new Promise((resolve, reject) => {
                    this.logger.debug(this.logTag, 'opening browser.');
                    let popupLocation;
                    const popup = window.open(url, '_system');
                    var timer = window.setInterval(() => {
                        if (!popup || popup.closed) {
                            window.clearInterval(timer);
                            const error = 'popup window closed without navigating to result url';
                            this.logger.error(this.logTag, error);
                            reject(error);
                        }
                        try {
                            if (!popup) {
                                return;
                            }
                            popupLocation = popup.location;
                            if (!encodeURI(popupLocation.href).indexOf(encodeURI(urlToCloseWindow))) {
                                window.clearInterval(timer);
                                const popupString = popupLocation.toString();
                                this.logger.debug(this.logTag, 'closing popup: ', popupLocation);
                                popup.close();
                                this.logger.debug(this.logTag, 'closed popup', popupString);
                                resolve({ event: 'opened', callback: popupString });
                            }
                            return;
                        }
                        catch (e) {
                            // While the URL is at the auth provider, we will get a DOMException error trying to access the window.
                            // We eat the error and try again.
                        }
                    }, 1);
                });
            }
            else {
                // CURRENT
                logging.debug(this.logTag, 'about to navigate forward');
                window.location.replace(url);
                return new Promise(() => { });
            }
        }
        catch (err) {
            this.logger.error(this.logTag, 'showUrl error: ', err);
            throw err;
        }
    }
}
//# sourceMappingURL=ionic-auth-web.js.map